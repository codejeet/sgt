#!/usr/bin/env bash
set -euo pipefail

# sgt — Simple GitHub Gastown
# Lightweight orchestration: GitHub Issues + Claude Code + tmux
# Feature-compatible with Gas Town, powered by GitHub instead of beads

SGT_VERSION="0.5.0"
SGT_ROOT="${SGT_ROOT:-$HOME/sgt}"
SGT_CONFIG="$SGT_ROOT/.sgt"
SGT_RIGS="$SGT_CONFIG/rigs"
SGT_POLECATS="$SGT_CONFIG/polecats"
SGT_AGENTS="$SGT_CONFIG/agents"
SGT_LOG="$SGT_ROOT/sgt.log"
SGT_DAEMON_PID="$SGT_CONFIG/daemon.pid"
SGT_DAEMON_LOCK="$SGT_CONFIG/daemon.lock"
SGT_DEACON_HEARTBEAT="$SGT_CONFIG/deacon-heartbeat.json"
SGT_DAEMON_INTERVAL="${SGT_DAEMON_INTERVAL:-180}" # 3 minutes
SGT_MAYOR_INTERVAL="${SGT_MAYOR_INTERVAL:-600}" # 10 minutes
SGT_MAYOR_LOCK_LEASE_SECS="${SGT_MAYOR_LOCK_LEASE_SECS:-}" # defaults to interval + 120s
SGT_MAYOR_DISPATCH_COOLDOWN="${SGT_MAYOR_DISPATCH_COOLDOWN:-21600}" # 6 hours
SGT_MAYOR_WAKE_DEDUPE_TTL="${SGT_MAYOR_WAKE_DEDUPE_TTL:-15}" # 15 seconds
SGT_DEACON_HEARTBEAT_STALE_SECS="${SGT_DEACON_HEARTBEAT_STALE_SECS:-300}" # 5 minutes
SGT_MAYOR_CRITICAL_ALERT_COOLDOWN="${SGT_MAYOR_CRITICAL_ALERT_COOLDOWN:-3600}" # 1 hour
SGT_MOLECULES="$SGT_ROOT/molecules"
SGT_ESCALATION="$SGT_CONFIG/escalation.json"
SGT_MAYOR_FIFO="$SGT_CONFIG/mayor.fifo"
SGT_MAYOR_LOCK="$SGT_CONFIG/mayor.lock"
SGT_MAYOR_CRITICAL_ALERT_STATE="$SGT_CONFIG/mayor-critical-alert.state"
SGT_MAYOR_DECISION_LOG_ALERT_STATE="$SGT_CONFIG/mayor-decision-log-alert.state"
SGT_MAYOR_REVIEW_WATCHDOG_STATE="$SGT_CONFIG/mayor-review-watchdog.state"
SGT_MAYOR_CI_WATCHDOG_STATE="$SGT_CONFIG/mayor-ci-watchdog.state"
SGT_MAYOR_DECISION_LOG_ALERT_COOLDOWN="${SGT_MAYOR_DECISION_LOG_ALERT_COOLDOWN:-600}" # 10 minutes
SGT_NOTIFY="$SGT_CONFIG/notify.json"
# Review queue removed in v0.5.0 — refinery handles review inline

# AI backend (claude|codex)
# Priority: CLI flags (per-run) > env SGT_AI_BACKEND > $SGT_CONFIG/settings.env > default
SGT_SETTINGS_ENV="$SGT_CONFIG/settings.env"

# ─── Helpers ──────────────────────────────────────────────────────────

die()  { echo "sgt: $*" >&2; exit 1; }
info() { echo "» $*"; }
warn() { echo "⚠ $*" >&2; }

# ─── UI helpers (color + layout) ──────────────────────────────────────

# Disable color via NO_COLOR=1 or when stdout is not a TTY.
_ui_color_enabled() {
  [[ -t 1 ]] && [[ -z "${NO_COLOR:-}" ]]
}

_c() {
  # Usage: _c "1;32"  (SGR code)
  _ui_color_enabled || return 0
  printf "\033[%sm" "$1"
}

_reset() { _c "0"; }
_bold()  { _c "1"; }
_dim()   { _c "2"; }

_fg_gray()   { _c "90"; }
_fg_red()    { _c "31"; }
_fg_green()  { _c "32"; }
_fg_yellow() { _c "33"; }
_fg_blue()   { _c "34"; }
_fg_mag()    { _c "35"; }
_fg_cyan()   { _c "36"; }

_term_cols() {
  local cols="${COLUMNS:-}"
  if [[ -z "$cols" ]]; then
    cols=$(tput cols 2>/dev/null || echo 80)
  fi
  # Guardrails
  [[ "$cols" =~ ^[0-9]+$ ]] || cols=80
  (( cols < 40 )) && cols=40
  echo "$cols"
}

_status_pr_title_cols() {
  local cols
  cols="$(_term_cols)"
  [[ "$cols" =~ ^[0-9]+$ ]] || cols=80
  cols=$((cols - 10))
  (( cols < 0 )) && cols=0
  echo "$cols"
}

_repeat() {
  local ch="$1" n="$2"
  (( n <= 0 )) && return 0
  local out=""
  local i
  for (( i=0; i<n; i++ )); do
    out+="$ch"
  done
  printf "%s" "$out"
}

_section() {
  # Rounded box header line (single line, compact)
  local title="$1"
  local cols fill
  cols=$(_term_cols)
  # "╭─ " + title + " " + fill + "╮"
  fill=$(( cols - ${#title} - 6 ))
  (( fill < 0 )) && fill=0
  printf "%s%s╭─ %s %s╮%s\n" "$(_bold)" "$(_fg_cyan)" "$title" "$(_repeat "─" "$fill")" "$(_reset)"
}

_status_badge() {
  # Usage: _status_badge on|off|alive|dead|open|merged|closed|unknown
  local s="$1"
  case "$s" in
    on|alive|OPEN|MERGED)
      printf "%s%s%s%s" "$(_bold)" "$(_fg_green)" "$s" "$(_reset)" ;;
    off|dead|CLOSED)
      printf "%s%s%s%s" "$(_bold)" "$(_fg_red)" "$s" "$(_reset)" ;;
    *)
      printf "%s%s%s%s" "$(_bold)" "$(_fg_yellow)" "$s" "$(_reset)" ;;
  esac
}

log_event() {
  echo "[$(date -Iseconds)] $*" >> "$SGT_LOG"
}

_MAYOR_DECISION_LOG_LAST_ERROR=""
_MAYOR_DISPATCH_TRIGGER_KEY=""
_MAYOR_DISPATCH_TRIGGER_FILE=""
_REFINERY_MERGE_ATTEMPT_KEY=""
_REFINERY_MERGE_ATTEMPT_FILE=""

_decision_log_alert_cooldown_secs() {
  local raw="${SGT_MAYOR_DECISION_LOG_ALERT_COOLDOWN:-600}"
  if [[ ! "$raw" =~ ^[0-9]+$ ]]; then
    raw="600"
  fi
  echo "$raw"
}

_mayor_decision_log_failure_state_read() {
  local ts="" context="" workspace="" error=""
  if [[ -f "$SGT_MAYOR_DECISION_LOG_ALERT_STATE" ]]; then
    IFS='|' read -r ts context workspace error < "$SGT_MAYOR_DECISION_LOG_ALERT_STATE" 2>/dev/null || true
  fi
  if [[ ! "$ts" =~ ^[0-9]+$ ]]; then
    ts=""
  fi
  echo "${ts}|${context}|${workspace}|${error}"
}

_mayor_decision_log_failure_state_write() {
  local ts="${1:-}" context="${2:-}" workspace="${3:-}" error="${4:-}"
  local state_tmp="${SGT_MAYOR_DECISION_LOG_ALERT_STATE}.tmp.$$"
  printf '%s|%s|%s|%s\n' \
    "$ts" \
    "$(_escape_wake_value "$context")" \
    "$(_escape_wake_value "$workspace")" \
    "$(_escape_wake_value "$error")" > "$state_tmp"
  mv "$state_tmp" "$SGT_MAYOR_DECISION_LOG_ALERT_STATE"
}

_mayor_decision_log_failure_state_clear() {
  rm -f "$SGT_MAYOR_DECISION_LOG_ALERT_STATE"
}

_mayor_decision_log_append() {
  local entry="${1:-}"
  local workspace="${2:-$SGT_ROOT}"
  local log_file="$SGT_CONFIG/mayor-decisions.log"
  local py_bin payload py_out
  local ts
  ts="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
  _MAYOR_DECISION_LOG_LAST_ERROR=""

  if ! mkdir -p "$SGT_CONFIG" 2>/dev/null; then
    _MAYOR_DECISION_LOG_LAST_ERROR="failed to create $SGT_CONFIG"
    return 1
  fi

  py_bin="$(command -v python3 || command -v python || true)"
  if [[ -z "$py_bin" ]]; then
    _MAYOR_DECISION_LOG_LAST_ERROR="python command not found"
    return 1
  fi

  payload="$(printf '[%s] workspace=%s\n%s\n' "$ts" "$workspace" "$entry")"
  if ! py_out="$(
    SGT_MAYOR_DECISION_LOG_APPEND_PAYLOAD="$payload" \
      "$py_bin" - "$log_file" 2>&1 <<'PY'
import fcntl
import os
import sys

path = sys.argv[1]
payload = os.environ.get("SGT_MAYOR_DECISION_LOG_APPEND_PAYLOAD", "").encode("utf-8")
if payload and not payload.endswith(b"\n"):
    payload += b"\n"
fd = os.open(path, os.O_WRONLY | os.O_APPEND | os.O_CREAT, 0o644)
try:
    fcntl.flock(fd, fcntl.LOCK_EX)
    start = os.lseek(fd, 0, os.SEEK_END)
    try:
        offset = 0
        while offset < len(payload):
            wrote = os.write(fd, payload[offset:])
            if wrote <= 0:
                raise RuntimeError("short write")
            offset += wrote
        os.fsync(fd)
    except Exception as err:
        # Keep entries all-or-nothing: never leave torn/truncated append payloads.
        rollback_err = None
        try:
            os.ftruncate(fd, start)
            os.fsync(fd)
        except Exception as rollback_exc:
            rollback_err = rollback_exc
        if rollback_err is not None:
            raise RuntimeError(f"{err}; rollback failed: {rollback_err}") from err
        raise
finally:
    os.close(fd)
PY
  )"; then
    py_out="$(_one_line "${py_out:-append failed}")"
    _MAYOR_DECISION_LOG_LAST_ERROR="failed to append+fsync $log_file ($py_out)"
    return 1
  fi
}

_mayor_record_decision() {
  local entry="${1:-}"
  local context="${2:-cycle}"
  local workspace="${3:-$SGT_ROOT}"
  if _mayor_decision_log_append "$entry" "$workspace"; then
    _mayor_decision_log_failure_state_clear
    return 0
  fi
  local err now cooldown prev_ts prev_context prev_workspace prev_error age notify_status warn_line
  err="$(_escape_quotes "${_MAYOR_DECISION_LOG_LAST_ERROR:-unknown}")"
  now="$(date +%s)"
  cooldown="$(_decision_log_alert_cooldown_secs)"
  IFS='|' read -r prev_ts prev_context prev_workspace prev_error <<< "$(_mayor_decision_log_failure_state_read)"
  age=0
  if [[ "$prev_ts" =~ ^[0-9]+$ ]]; then
    age=$((now - prev_ts))
    if [[ "$age" -lt 0 ]]; then
      age=0
    fi
  fi
  _mayor_decision_log_failure_state_write "$now" "$context" "$workspace" "${_MAYOR_DECISION_LOG_LAST_ERROR:-unknown}"

  if [[ ! "$prev_ts" =~ ^[0-9]+$ || "$cooldown" -eq 0 || "$age" -ge "$cooldown" ]]; then
    if _mayor_notify_rigger "mayor warning: decision-log write failed context=$context error=${_MAYOR_DECISION_LOG_LAST_ERROR:-unknown}"; then
      notify_status="sent"
    else
      notify_status="unavailable"
    fi
  else
    notify_status="suppressed"
  fi

  warn_line="MAYOR_DECISION_LOG_WRITE_FAILED context=$context workspace=\"$(_escape_quotes "$workspace")\" error=\"$err\" notify=$notify_status cooldown=${cooldown}s"
  echo "[mayor] warning: $warn_line"
  log_event "$warn_line"
  return 1
}

_repo_owner_repo() {
  local repo="${1:-}"
  repo="${repo#https://github.com/}"
  repo="${repo#http://github.com/}"
  echo "$repo"
}

_repo_pr_url() {
  local repo="${1:-}" pr="${2:-}"
  local owner_repo
  owner_repo="$(_repo_owner_repo "$repo")"
  if [[ -z "$owner_repo" || -z "$pr" ]]; then
    echo ""
    return 0
  fi
  echo "https://github.com/$owner_repo/pull/$pr"
}

_repo_issue_url() {
  local repo="${1:-}" issue="${2:-}"
  local owner_repo
  owner_repo="$(_repo_owner_repo "$repo")"
  if [[ -z "$owner_repo" || -z "$issue" || "$issue" == "0" ]]; then
    echo ""
    return 0
  fi
  echo "https://github.com/$owner_repo/issues/$issue"
}

_one_line() {
  local value="${1:-}"
  printf '%s' "$value" | tr '\n' ' ' | sed -E 's/[[:space:]]+/ /g; s/^ //; s/ $//'
}

_escape_quotes() {
  local value
  value="$(_one_line "$1")"
  value="${value//\"/\\\"}"
  echo "$value"
}

_escape_wake_value() {
  local value
  value="$(_one_line "$1")"
  value="${value//|//}"
  echo "$value"
}

_wake_field() {
  local reason="${1:-}" key="${2:-}"
  local part
  IFS='|' read -r -a parts <<< "$reason"
  for part in "${parts[@]}"; do
    if [[ "$part" == "$key="* ]]; then
      echo "${part#${key}=}"
      return 0
    fi
  done
  echo ""
}

_dedupe_wake_reasons() {
  local -A seen=()
  local reason
  for reason in "$@"; do
    [[ -n "$reason" ]] || continue
    if [[ -z "${seen[$reason]+x}" ]]; then
      seen["$reason"]=1
      echo "$reason"
    fi
  done
}

_wake_requires_dispatch_decision() {
  local reason="${1:-}"
  [[ "$reason" == merged:* || "$reason" == dog-approved:* ]]
}

_mayor_dispatch_trigger_key() {
  local reason="${1:-}" pr repo merged_head owner_repo
  if [[ "$reason" =~ ^merged:pr#([0-9]+):# ]]; then
    pr="${BASH_REMATCH[1]}"
  else
    return 1
  fi
  repo="$(_wake_field "$reason" "repo")"
  merged_head="$(_wake_field "$reason" "merged_head")"
  [[ -n "$repo" && -n "$merged_head" ]] || return 1
  owner_repo="$(_repo_owner_repo "$repo")"
  [[ -n "$owner_repo" ]] || owner_repo="$repo"
  echo "${owner_repo}|pr=${pr}|merged_head=${merged_head}"
}

_mayor_dispatch_trigger_key_id() {
  local key="${1:-}"
  if command -v sha256sum >/dev/null 2>&1; then
    printf '%s' "$key" | sha256sum | awk '{print $1}'
  elif command -v shasum >/dev/null 2>&1; then
    printf '%s' "$key" | shasum -a 256 | awk '{print $1}'
  else
    printf '%s' "$key" | tr -c '[:alnum:]_.-' '_'
  fi
}

_mayor_dispatch_trigger_claim() {
  local reason="${1:-}" key key_id key_dir key_file
  _MAYOR_DISPATCH_TRIGGER_KEY=""
  _MAYOR_DISPATCH_TRIGGER_FILE=""
  key="$(_mayor_dispatch_trigger_key "$reason" || true)"
  [[ -n "$key" ]] || return 2
  key_id="$(_mayor_dispatch_trigger_key_id "$key")"
  key_dir="$SGT_CONFIG/mayor-dispatch-triggers"
  key_file="$key_dir/$key_id"
  mkdir -p "$key_dir" || return 2
  _MAYOR_DISPATCH_TRIGGER_KEY="$key"
  _MAYOR_DISPATCH_TRIGGER_FILE="$key_file"
  if ! ( set -o noclobber; : > "$key_file" ) 2>/dev/null; then
    return 1
  fi
  cat > "$key_file" <<EOF
KEY=$key
REASON=$reason
CLAIMED_AT=$(date -Iseconds)
EOF
  return 0
}

_mayor_wake_dedupe_ttl_secs() {
  local raw="${SGT_MAYOR_WAKE_DEDUPE_TTL:-15}"
  if [[ ! "$raw" =~ ^[0-9]+$ ]]; then
    raw="15"
  fi
  echo "$raw"
}

_wake_trigger_key() {
  local reason="${1:-}"
  if [[ -z "$reason" || "$reason" == "periodic" ]]; then
    echo ""
    return 0
  fi
  echo "${reason%%|*}"
}

_wake_trigger_should_suppress() {
  local last_seen="${1:-}" now="${2:-}" ttl="${3:-}"
  if [[ -z "$last_seen" || ! "$last_seen" =~ ^[0-9]+$ ]]; then
    return 1
  fi
  if [[ ! "$now" =~ ^[0-9]+$ || ! "$ttl" =~ ^[0-9]+$ ]]; then
    return 1
  fi
  if [[ "$ttl" -eq 0 || "$now" -lt "$last_seen" ]]; then
    return 1
  fi
  local age=$((now - last_seen))
  [[ "$age" -lt "$ttl" ]]
}

_mayor_lock_lease_secs() {
  local raw="${SGT_MAYOR_LOCK_LEASE_SECS:-}"
  local interval="${SGT_MAYOR_INTERVAL:-600}"
  local fallback=$((interval + 120))
  if [[ -z "$raw" ]]; then
    raw="$fallback"
  fi
  if [[ ! "$raw" =~ ^[0-9]+$ || "$raw" -eq 0 ]]; then
    raw="$fallback"
  fi
  echo "$raw"
}

_mayor_lock_owner_live() {
  local owner_pid="${1:-}"
  [[ "$owner_pid" =~ ^[0-9]+$ ]] || return 1
  kill -0 "$owner_pid" 2>/dev/null
}

_mayor_lock_read() {
  local lock_file="${1:-$SGT_MAYOR_LOCK}"
  local owner_pid="" started_at="" lease_until=""

  if [[ -f "$lock_file" ]]; then
    owner_pid="$(awk -F= '$1=="ownerPid"{print $2; exit}' "$lock_file" 2>/dev/null || true)"
    started_at="$(awk -F= '$1=="startedAt"{print $2; exit}' "$lock_file" 2>/dev/null || true)"
    lease_until="$(awk -F= '$1=="leaseUntil"{print $2; exit}' "$lock_file" 2>/dev/null || true)"
  fi

  echo "${owner_pid}|${started_at}|${lease_until}"
}

_mayor_lock_write() {
  local lock_file="${1:-$SGT_MAYOR_LOCK}"
  local owner_pid="${2:-}"
  local started_at="${3:-}"
  local lease_until="${4:-}"

  cat > "$lock_file" <<EOF
ownerPid=$owner_pid
startedAt=$started_at
leaseUntil=$lease_until
EOF
}

_mayor_lock_claim() {
  local lock_file="${SGT_MAYOR_LOCK:-$SGT_CONFIG/mayor.lock}"
  local now lease_secs lease_until
  now="$(date +%s)"
  lease_secs="$(_mayor_lock_lease_secs)"
  lease_until=$((now + lease_secs))

  mkdir -p "$SGT_CONFIG"
  exec {lock_fd}<>"$lock_file"
  flock -x "$lock_fd"

  local owner_pid started_at existing_lease
  IFS='|' read -r owner_pid started_at existing_lease <<< "$(_mayor_lock_read "$lock_file")"

  local decision reason new_started_at
  decision="acquired"
  reason="empty-or-invalid"
  new_started_at="$now"

  if [[ "$owner_pid" =~ ^[0-9]+$ && "$started_at" =~ ^[0-9]+$ && "$existing_lease" =~ ^[0-9]+$ ]]; then
    if [[ "$owner_pid" -eq "$$" ]]; then
      decision="reused"
      reason="same-owner"
      new_started_at="$started_at"
    elif _mayor_lock_owner_live "$owner_pid" && [[ "$existing_lease" -gt "$now" ]]; then
      decision="blocked-live"
      reason="owner-live-with-valid-lease"
      echo "${decision}|${owner_pid}|${started_at}|${existing_lease}|${reason}"
      flock -u "$lock_fd"
      exec {lock_fd}>&-
      return 1
    else
      decision="stolen"
      if _mayor_lock_owner_live "$owner_pid"; then
        reason="lease-expired"
      else
        reason="owner-dead"
      fi
      new_started_at="$now"
    fi
  fi

  _mayor_lock_write "$lock_file" "$$" "$new_started_at" "$lease_until"
  echo "${decision}|$$|${new_started_at}|${lease_until}|${reason}"
  flock -u "$lock_fd"
  exec {lock_fd}>&-
}

_mayor_lock_release() {
  local owner_pid="${1:-$$}"
  local lock_file="${SGT_MAYOR_LOCK:-$SGT_CONFIG/mayor.lock}"
  [[ -f "$lock_file" ]] || return 0

  exec {lock_fd}<>"$lock_file" || return 0
  flock -x "$lock_fd"
  local current_owner current_started current_lease
  IFS='|' read -r current_owner current_started current_lease <<< "$(_mayor_lock_read "$lock_file")"
  if [[ "$current_owner" == "$owner_pid" ]]; then
    rm -f "$lock_file"
  fi
  flock -u "$lock_fd"
  exec {lock_fd}>&-
}

_mayor_lock_snapshot() {
  local now owner_pid started_at lease_until
  now="$(date +%s)"
  IFS='|' read -r owner_pid started_at lease_until <<< "$(_mayor_lock_read "$SGT_MAYOR_LOCK")"
  if [[ ! "$owner_pid" =~ ^[0-9]+$ || ! "$started_at" =~ ^[0-9]+$ || ! "$lease_until" =~ ^[0-9]+$ ]]; then
    echo "none|||"
    return 0
  fi

  local owner_live="dead" lease_state="expired"
  if _mayor_lock_owner_live "$owner_pid"; then
    owner_live="live"
  fi
  if [[ "$lease_until" -gt "$now" ]]; then
    lease_state="valid"
  fi
  echo "${owner_live}/${lease_state}|${owner_pid}|${started_at}|${lease_until}"
}

_mayor_merge_queue_count() {
  local mq_count=0
  if [[ -d "$SGT_CONFIG/merge-queue" ]]; then
    local mqf
    for mqf in "$SGT_CONFIG/merge-queue"/*; do
      [[ -f "$mqf" ]] || continue
      mq_count=$((mq_count + 1))
    done
  fi
  echo "$mq_count"
}

_mayor_snapshot_resolve_counts() {
  local snapshot_raw="${1:-}" live_raw="${2:-}"
  local snapshot="$snapshot_raw" live="$live_raw"
  local chosen source status

  [[ "$snapshot" =~ ^[0-9]+$ ]] || snapshot=-1
  [[ "$live" =~ ^[0-9]+$ ]] || live=-1

  # Deterministic precedence:
  # 1) If live is available and differs, live wins (stale snapshot).
  # 2) If live is unavailable, snapshot is kept.
  # 3) If both are available and equal, snapshot is accepted as in-sync.
  if [[ "$live" -lt 0 ]]; then
    chosen="$snapshot"
    source="snapshot"
    status="live-unavailable"
  elif [[ "$snapshot" -lt 0 ]]; then
    chosen="$live"
    source="live"
    status="snapshot-invalid"
  elif [[ "$snapshot" -eq "$live" ]]; then
    chosen="$snapshot"
    source="snapshot"
    status="in-sync"
  else
    chosen="$live"
    source="live"
    status="stale-snapshot"
  fi

  echo "${snapshot}|${live}|${chosen}|${source}|${status}"
}

_mayor_merge_queue_revalidate_once() {
  local snapshot_count="${1:-}"
  local live_count
  live_count="$(_mayor_merge_queue_count)"
  _mayor_snapshot_resolve_counts "$snapshot_count" "$live_count"
}

_normalize_label() {
  local label="${1:-}"
  label="$(_one_line "$label")"
  label="$(printf '%s' "$label" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/-/g; s/^-+//; s/-+$//')"
  echo "$label"
}

_symptom_signature() {
  local raw="${1:-}"
  raw="$(_one_line "$raw")"
  raw="$(printf '%s' "$raw" | tr '[:upper:]' '[:lower:]' | sed -E 's/[0-9]+/ num /g; s/[^a-z]+/ /g; s/[[:space:]]+/ /g; s/^ //; s/ $//')"
  echo "$raw"
}

_dispatch_cooldown_secs() {
  local raw="${SGT_MAYOR_DISPATCH_COOLDOWN:-21600}"
  if [[ ! "$raw" =~ ^[0-9]+$ ]]; then
    raw="21600"
  fi
  echo "$raw"
}

_deacon_heartbeat_stale_secs() {
  local raw="${SGT_DEACON_HEARTBEAT_STALE_SECS:-300}"
  if [[ ! "$raw" =~ ^[0-9]+$ ]]; then
    raw="300"
  fi
  echo "$raw"
}

_critical_alert_cooldown_secs() {
  local raw="${SGT_MAYOR_CRITICAL_ALERT_COOLDOWN:-3600}"
  if [[ ! "$raw" =~ ^[0-9]+$ ]]; then
    raw="3600"
  fi
  echo "$raw"
}

_deacon_heartbeat_snapshot() {
  if [[ ! -f "$SGT_DEACON_HEARTBEAT" ]]; then
    echo "-1||missing"
    return 0
  fi

  python3 - "$SGT_DEACON_HEARTBEAT" <<'PY' 2>/dev/null || echo "-1||invalid"
import datetime
import json
import time
import sys

path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
except Exception:
    print("-1||invalid")
    raise SystemExit(0)

raw_ts = str(data.get("timestamp", "")).strip()
if not raw_ts:
    print("-1||invalid")
    raise SystemExit(0)

try:
    dt = datetime.datetime.fromisoformat(raw_ts)
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=datetime.timezone.utc)
    ts_epoch = int(dt.timestamp())
except Exception:
    print(f"-1|{raw_ts}|invalid")
    raise SystemExit(0)

age = int(time.time()) - ts_epoch
if age < 0:
    age = 0
print(f"{age}|{raw_ts}|ok")
PY
}

_deacon_heartbeat_health() {
  local age="${1:-}" stale_secs="${2:-300}"
  [[ "$age" =~ ^-?[0-9]+$ ]] || {
    echo "unknown"
    return 0
  }
  if [[ "$age" -lt 0 ]]; then
    echo "unknown"
  elif [[ "$age" -gt "$stale_secs" ]]; then
    echo "stale"
  else
    echo "healthy"
  fi
}

_mayor_critical_alert_signature() {
  local rig="${1:-}" repo="${2:-}" issues="${3:-}"
  local payload sig=""
  payload="$rig|$repo|$issues"
  if command -v sha1sum &>/dev/null; then
    sig="$(printf '%s' "$payload" | sha1sum 2>/dev/null | awk '{print $1}')"
  fi
  if [[ -z "$sig" ]]; then
    sig="$(_symptom_signature "$payload")"
  fi
  echo "$sig"
}

_mayor_should_notify_critical_alert() {
  local rig="${1:-}" repo="${2:-}" issues="${3:-}"
  [[ -n "$rig" && -n "$repo" && -n "$issues" ]] || return 1

  local cooldown_secs
  cooldown_secs="$(_critical_alert_cooldown_secs)"
  if [[ "$cooldown_secs" -eq 0 ]]; then
    return 0
  fi

  local now signature
  now=$(date +%s)
  signature="$(_mayor_critical_alert_signature "$rig" "$repo" "$issues")"
  [[ -n "$signature" ]] || return 0

  local prev_signature="" prev_epoch=""
  if [[ -f "$SGT_MAYOR_CRITICAL_ALERT_STATE" ]]; then
    local prev_line
    prev_line=$(awk -F'|' -v key="$rig" '$1==key {print; exit}' "$SGT_MAYOR_CRITICAL_ALERT_STATE" 2>/dev/null || true)
    if [[ -n "$prev_line" ]]; then
      IFS='|' read -r _ prev_signature prev_epoch <<< "$prev_line"
    fi
  fi

  if [[ "$prev_signature" == "$signature" && "$prev_epoch" =~ ^[0-9]+$ ]]; then
    local age=$((now - prev_epoch))
    if [[ "$age" -lt 0 ]]; then
      age=0
    fi
    if [[ "$age" -lt "$cooldown_secs" ]]; then
      return 1
    fi
  fi

  local state_tmp
  state_tmp="$(mktemp)"
  if [[ -f "$SGT_MAYOR_CRITICAL_ALERT_STATE" ]]; then
    awk -F'|' -v key="$rig" '$1!=key {print $0}' "$SGT_MAYOR_CRITICAL_ALERT_STATE" > "$state_tmp" 2>/dev/null || true
  fi
  printf '%s|%s|%s\n' "$rig" "$signature" "$now" >> "$state_tmp"
  mv "$state_tmp" "$SGT_MAYOR_CRITICAL_ALERT_STATE"
  return 0
}

_mayor_critical_alert_message() {
  local rig="${1:-}" repo="${2:-}" issues="${3:-}"
  local first count
  first="$(printf '%s\n' "$issues" | sed '/^[[:space:]]*$/d' | head -1)"
  count="$(printf '%s\n' "$issues" | sed '/^[[:space:]]*$/d' | wc -l | tr -d ' ')"
  [[ "$count" =~ ^[0-9]+$ ]] || count=1

  local more=""
  if [[ "$count" -gt 1 ]]; then
    more=" (+$((count - 1)) more)"
  fi
  echo "critical/high issues on $rig repo=$repo: ${first:-unknown}${more}"
}

_mayor_review_unclear_stale_secs() {
  local raw="${SGT_MAYOR_REVIEW_UNCLEAR_STALE_SECS:-900}"
  [[ "$raw" =~ ^[0-9]+$ ]] || raw=900
  echo "$raw"
}

_mayor_ci_check_stale_secs() {
  local raw="${SGT_MAYOR_CI_CHECK_STALE_SECS:-900}"
  [[ "$raw" =~ ^[0-9]+$ ]] || raw=900
  echo "$raw"
}

_mayor_ci_watchdog_dedupe_window_secs() {
  local raw="${SGT_MAYOR_CI_WATCHDOG_DEDUPE_SECS:-1800}"
  [[ "$raw" =~ ^[0-9]+$ ]] || raw=1800
  echo "$raw"
}

_mayor_ci_watchdog_signature() {
  local state="${1:-}" since_epoch="${2:-}" check_url="${3:-}"
  printf 'state=%s|since=%s|url=%s' "${state:-unknown}" "${since_epoch:-0}" "${check_url:-unknown}"
}

_mayor_ci_watchdog_state_key() {
  local rig="${1:-}" repo="${2:-}" pr="${3:-}" check_name="${4:-}"
  printf '%s|%s|%s|%s' "${rig:-unknown}" "${repo:-unknown}" "${pr:-0}" "${check_name:-unknown}"
}

_mayor_should_notify_ci_watchdog() {
  local rig="${1:-}" repo="${2:-}" pr="${3:-}" check_name="${4:-}" state="${5:-}" since_epoch="${6:-}" check_url="${7:-}" now_epoch="${8:-}"
  [[ -n "$rig" && -n "$repo" && -n "$pr" && -n "$check_name" && -n "$state" ]] || return 1

  local key signature now prev_line prev_signature prev_notified state_tmp dedupe_window age
  key="$(_mayor_ci_watchdog_state_key "$rig" "$repo" "$pr" "$check_name")"
  signature="$(_mayor_ci_watchdog_signature "$state" "$since_epoch" "$check_url")"
  now="${now_epoch:-$(date +%s)}"
  [[ "$now" =~ ^[0-9]+$ ]] || now="$(date +%s)"
  dedupe_window="$(_mayor_ci_watchdog_dedupe_window_secs)"
  [[ "$dedupe_window" =~ ^[0-9]+$ ]] || dedupe_window=0
  prev_signature=""
  prev_notified=""

  if [[ -f "$SGT_MAYOR_CI_WATCHDOG_STATE" ]]; then
    prev_line=$(awk -F'\t' -v key="$key" '$1==key {print; exit}' "$SGT_MAYOR_CI_WATCHDOG_STATE" 2>/dev/null || true)
    if [[ -n "$prev_line" ]]; then
      IFS=$'\t' read -r _ prev_signature prev_notified <<< "$prev_line"
    fi
  fi

  if [[ "$dedupe_window" -gt 0 && "$prev_signature" == "$signature" && "$prev_notified" =~ ^[0-9]+$ ]]; then
    age=$((now - prev_notified))
    if [[ "$age" -lt 0 ]]; then
      age=0
    fi
    if [[ "$age" -lt "$dedupe_window" ]]; then
      return 1
    fi
  fi

  state_tmp="$(mktemp)"
  if [[ -f "$SGT_MAYOR_CI_WATCHDOG_STATE" ]]; then
    awk -F'\t' -v key="$key" '$1!=key {print $0}' "$SGT_MAYOR_CI_WATCHDOG_STATE" > "$state_tmp" 2>/dev/null || true
  fi
  printf '%s\t%s\t%s\n' "$key" "$signature" "$now" >> "$state_tmp"
  mv "$state_tmp" "$SGT_MAYOR_CI_WATCHDOG_STATE"
  return 0
}

_mayor_ci_watchdog_reconcile_state() {
  local line rig repo pr check_name key state_tmp
  declare -A active_keys=()
  for line in "${@+"$@"}"; do
    [[ -n "$line" ]] || continue
    IFS='|' read -r rig repo pr _ check_name _ _ _ _ _ _ _ <<< "$line"
    key="$(_mayor_ci_watchdog_state_key "$rig" "$repo" "$pr" "$check_name")"
    active_keys["$key"]=1
  done

  [[ -f "$SGT_MAYOR_CI_WATCHDOG_STATE" ]] || return 0
  state_tmp="$(mktemp)"
  while IFS=$'\t' read -r key signature notified_at; do
    [[ -n "$key" ]] || continue
    if [[ -n "${active_keys[$key]:-}" ]]; then
      printf '%s\t%s\t%s\n' "$key" "$signature" "$notified_at" >> "$state_tmp"
    fi
  done < "$SGT_MAYOR_CI_WATCHDOG_STATE"
  mv "$state_tmp" "$SGT_MAYOR_CI_WATCHDOG_STATE"
}

_mayor_ci_watchdog_collect_from_check_stream() {
  local rig="${1:-}" repo="${2:-}" pr="${3:-}" issue="${4:-0}" pr_url="${5:-}" issue_url="${6:-}" now_epoch="${7:-$(date +%s)}" threshold="${8:-$(_mayor_ci_check_stale_secs)}"
  [[ "$now_epoch" =~ ^[0-9]+$ ]] || now_epoch="$(date +%s)"
  [[ "$threshold" =~ ^[0-9]+$ ]] || threshold=0

  local check_name check_state started_at check_link started_epoch age check_url
  while IFS=$'\t' read -r check_name check_state started_at check_link; do
    [[ -n "$check_name" ]] || continue
    [[ "$check_state" == "QUEUED" || "$check_state" == "IN_PROGRESS" ]] || continue
    [[ -n "$started_at" ]] || continue
    started_epoch="$(date -d "$started_at" +%s 2>/dev/null || true)"
    [[ "$started_epoch" =~ ^[0-9]+$ ]] || continue
    age=$((now_epoch - started_epoch))
    if [[ "$age" -lt 0 ]]; then
      age=0
    fi
    if [[ "$age" -ge "$threshold" ]]; then
      check_url="${check_link:-$pr_url}"
      printf '%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s\n' \
        "${rig:-unknown}" "${repo:-unknown}" "${pr:-0}" "${issue:-0}" "${check_name}" "${check_state}" \
        "${started_epoch}" "${age}" "${threshold}" "${check_url:-unknown}" "${pr_url:-unknown}" "${issue_url:-unknown}"
    fi
  done
}

_mayor_ci_watchdog_collect_stale() {
  local now_epoch="${1:-$(date +%s)}"
  local threshold="${2:-$(_mayor_ci_check_stale_secs)}"
  [[ "$now_epoch" =~ ^[0-9]+$ ]] || now_epoch="$(date +%s)"
  [[ "$threshold" =~ ^[0-9]+$ ]] || threshold=0
  [[ -d "$SGT_RIGS" ]] || return 0

  local rig_file rig repo owner_repo pr_num pr_url checks_stream
  for rig_file in "$SGT_RIGS"/*; do
    [[ -f "$rig_file" ]] || continue
    rig="$(basename "$rig_file")"
    repo="$(cat "$rig_file" 2>/dev/null || true)"
    [[ -n "$repo" ]] || continue
    owner_repo="$(_repo_owner_repo "$repo")"
    [[ -n "$owner_repo" ]] || continue

    while IFS=$'\t' read -r pr_num pr_url; do
      [[ "$pr_num" =~ ^[0-9]+$ ]] || continue
      checks_stream="$(
        gh pr checks "$pr_num" --repo "$repo" --required \
          --json name,state,startedAt,link \
          --jq '.[] | "\(.name // \"\")\t\(.state // \"\")\t\(.startedAt // \"\")\t\(.link // \"\")"' \
          2>/dev/null || true
      )"
      [[ -n "$checks_stream" ]] || continue
      _mayor_ci_watchdog_collect_from_check_stream "$rig" "$owner_repo" "$pr_num" "0" "$pr_url" "unknown" "$now_epoch" "$threshold" <<< "$checks_stream"
    done < <(
      gh pr list --repo "$repo" --state open --limit 100 --json number,url \
        --jq '.[] | "\(.number)\t\(.url // \"\")"' \
        2>/dev/null || true
    )
  done
}

_mayor_ci_watchdog_status_snapshot() {
  local threshold now_epoch line count oldest_age age
  threshold="$(_mayor_ci_check_stale_secs)"
  now_epoch="$(date +%s)"
  count=0
  oldest_age=0
  while IFS= read -r line; do
    [[ -n "$line" ]] || continue
    IFS='|' read -r _ _ _ _ _ _ _ age _ _ _ _ <<< "$line"
    [[ "$age" =~ ^[0-9]+$ ]] || age=0
    count=$((count + 1))
    if [[ "$age" -gt "$oldest_age" ]]; then
      oldest_age="$age"
    fi
  done < <(_mayor_ci_watchdog_collect_stale "$now_epoch" "$threshold")
  printf '%s|%s|%s\n' "$count" "$oldest_age" "$threshold"
}

_mayor_review_watchdog_signature() {
  local state="${1:-}" unclear_since="${2:-}" head_sha="${3:-}"
  printf 'state=%s|since=%s|head=%s' "${state:-unknown}" "${unclear_since:-0}" "${head_sha:-unknown}"
}

_mayor_should_notify_review_watchdog() {
  local rig="${1:-}" repo="${2:-}" pr="${3:-}" state="${4:-}" unclear_since="${5:-}" head_sha="${6:-}"
  [[ -n "$rig" && -n "$repo" && -n "$pr" && -n "$state" ]] || return 1

  local key signature now prev_line prev_signature state_tmp
  key="${rig}|${repo}|${pr}"
  signature="$(_mayor_review_watchdog_signature "$state" "$unclear_since" "$head_sha")"
  now="$(date +%s)"
  prev_signature=""

  if [[ -f "$SGT_MAYOR_REVIEW_WATCHDOG_STATE" ]]; then
    prev_line=$(awk -F'\t' -v key="$key" '$1==key {print; exit}' "$SGT_MAYOR_REVIEW_WATCHDOG_STATE" 2>/dev/null || true)
    if [[ -n "$prev_line" ]]; then
      IFS=$'\t' read -r _ prev_signature _ <<< "$prev_line"
    fi
  fi

  if [[ "$prev_signature" == "$signature" ]]; then
    return 1
  fi

  state_tmp="$(mktemp)"
  if [[ -f "$SGT_MAYOR_REVIEW_WATCHDOG_STATE" ]]; then
    awk -F'\t' -v key="$key" '$1!=key {print $0}' "$SGT_MAYOR_REVIEW_WATCHDOG_STATE" > "$state_tmp" 2>/dev/null || true
  fi
  printf '%s\t%s\t%s\n' "$key" "$signature" "$now" >> "$state_tmp"
  mv "$state_tmp" "$SGT_MAYOR_REVIEW_WATCHDOG_STATE"
  return 0
}

_mayor_review_watchdog_collect_stale() {
  local now_epoch="${1:-$(date +%s)}"
  local threshold="${2:-$(_mayor_review_unclear_stale_secs)}"
  local merge_dir="$SGT_CONFIG/merge-queue"
  [[ "$threshold" =~ ^[0-9]+$ ]] || threshold=0
  [[ "$now_epoch" =~ ^[0-9]+$ ]] || now_epoch="$(date +%s)"
  [[ -d "$merge_dir" ]] || return 0

  local f mqname mq_rig mq_pr mq_repo mq_issue mq_head_sha mq_review_state mq_review_unclear_since age
  for f in "$merge_dir"/*; do
    [[ -f "$f" ]] || continue
    mqname="$(basename "$f")"
    mq_pr=""
    mq_rig=""
    mq_repo=""
    mq_issue=""
    mq_head_sha=""
    mq_review_state=""
    mq_review_unclear_since=""
    eval "$(grep -E '^(RIG|PR|REPO|ISSUE|HEAD_SHA|REVIEW_STATE|REVIEW_UNCLEAR_SINCE)=' "$f")"
    mq_rig="${RIG:-}"
    mq_pr="${PR:-}"
    mq_repo="${REPO:-}"
    mq_issue="${ISSUE:-0}"
    mq_head_sha="${HEAD_SHA:-}"
    mq_review_state="${REVIEW_STATE:-REVIEW_PENDING}"
    mq_review_unclear_since="${REVIEW_UNCLEAR_SINCE:-}"
    [[ "$mq_review_state" == "REVIEW_UNCLEAR" ]] || continue
    [[ "$mq_review_unclear_since" =~ ^[0-9]+$ ]] || continue
    age=$((now_epoch - mq_review_unclear_since))
    if [[ "$age" -lt 0 ]]; then
      age=0
    fi
    if [[ "$age" -ge "$threshold" ]]; then
      printf '%s|%s|%s|%s|%s|%s|%s|%s|%s|%s\n' \
        "${mqname:-unknown}" "${mq_rig:-unknown}" "${mq_pr:-}" "${mq_repo:-}" "${mq_issue:-0}" \
        "${mq_review_state}" "${mq_review_unclear_since}" "${age}" "${mq_head_sha:-}" "${threshold}"
    fi
  done
}

_mayor_review_watchdog_status_snapshot() {
  local threshold now_epoch line count oldest_age age
  threshold="$(_mayor_review_unclear_stale_secs)"
  now_epoch="$(date +%s)"
  count=0
  oldest_age=0
  while IFS= read -r line; do
    [[ -n "$line" ]] || continue
    IFS='|' read -r _ _ _ _ _ _ _ age _ _ <<< "$line"
    [[ "$age" =~ ^[0-9]+$ ]] || age=0
    count=$((count + 1))
    if [[ "$age" -gt "$oldest_age" ]]; then
      oldest_age="$age"
    fi
  done < <(_mayor_review_watchdog_collect_stale "$now_epoch" "$threshold")
  printf '%s|%s|%s\n' "$count" "$oldest_age" "$threshold"
}

_mayor_pre_dispatch_revalidate() {
  local repo="${1:-}"
  local owner_repo owner name snapshot open_prs open_authorized
  owner_repo="$(_repo_owner_repo "$repo")"
  owner="${owner_repo%%/*}"
  name="${owner_repo#*/}"

  if [[ -z "$owner" || -z "$name" || "$owner" == "$name" ]]; then
    echo "revalidation failed: invalid repo '$repo'"
    return 1
  fi

  snapshot=$(
    gh api graphql \
      -f query='query($owner:String!, $name:String!) {
        repository(owner:$owner, name:$name) {
          openPullRequests: pullRequests(states: OPEN) { totalCount }
          openAuthorizedIssues: issues(states: OPEN, labels: ["sgt-authorized"]) { totalCount }
        }
      }' \
      -F owner="$owner" \
      -F name="$name" \
      --jq '.data.repository | "\(.openPullRequests.totalCount)|\(.openAuthorizedIssues.totalCount)"' \
      2>/dev/null || true
  )

  if [[ -z "$snapshot" || "$snapshot" != *"|"* ]]; then
    echo "revalidation failed: unable to query live state"
    return 1
  fi

  IFS='|' read -r open_prs open_authorized <<< "$snapshot"
  [[ "$open_prs" =~ ^[0-9]+$ ]] || open_prs=-1
  [[ "$open_authorized" =~ ^[0-9]+$ ]] || open_authorized=-1

  if [[ "$open_prs" -ne 0 || "$open_authorized" -ne 0 ]]; then
    echo "live state dirty: open_prs=$open_prs open_authorized_issues=$open_authorized"
    return 1
  fi

  return 0
}

_pr_head_sha() {
  local repo="${1:-}" pr="${2:-}"
  [[ -n "$repo" && -n "$pr" ]] || return 1
  gh pr view "$pr" --repo "$repo" --json headRefOid --jq '.headRefOid // ""' 2>/dev/null || true
}

_merge_queue_set_field() {
  local queue_file="${1:-}" field="${2:-}" value="${3:-}"
  [[ -n "$queue_file" && -f "$queue_file" && -n "$field" ]] || return 1
  if grep -q "^${field}=" "$queue_file"; then
    sed -i -E "s|^${field}=.*|${field}=${value}|" "$queue_file"
  else
    printf '%s=%s\n' "$field" "$value" >> "$queue_file"
  fi
}

_merge_queue_set_head_sha() {
  local queue_file="${1:-}" head_sha="${2:-}"
  _merge_queue_set_field "$queue_file" "HEAD_SHA" "$head_sha"
}

_merge_queue_mark_review_state() {
  local queue_file="${1:-}" review_state="${2:-}"
  [[ -n "$queue_file" && -f "$queue_file" && -n "$review_state" ]] || return 1
  local now review_unclear_since
  now="$(date +%s)"
  review_unclear_since=""
  if [[ "$review_state" == "REVIEW_UNCLEAR" ]]; then
    review_unclear_since=$(grep -E '^REVIEW_UNCLEAR_SINCE=' "$queue_file" 2>/dev/null | tail -1 | cut -d= -f2- || true)
    if [[ ! "$review_unclear_since" =~ ^[0-9]+$ ]]; then
      review_unclear_since="$now"
    fi
  fi
  _merge_queue_set_field "$queue_file" "REVIEW_STATE" "$review_state" || return 1
  _merge_queue_set_field "$queue_file" "REVIEW_UPDATED_AT" "$now" || return 1
  _merge_queue_set_field "$queue_file" "REVIEW_UNCLEAR_SINCE" "$review_unclear_since" || return 1
}

_merge_queue_repo_pr_key() {
  local repo="${1:-}" pr="${2:-}"
  local owner_repo
  owner_repo="$(_repo_owner_repo "$repo")"
  [[ -n "$owner_repo" ]] || owner_repo="$repo"
  echo "${owner_repo}|pr=${pr}"
}

_merge_queue_canonical_name() {
  local rig="${1:-}" pr="${2:-}"
  echo "${rig}-pr${pr}"
}

_merge_queue_find_by_repo_pr() {
  local repo="${1:-}" pr="${2:-}"
  local key merge_dir f q_repo q_pr q_key
  key="$(_merge_queue_repo_pr_key "$repo" "$pr")"
  merge_dir="$SGT_CONFIG/merge-queue"
  [[ -d "$merge_dir" ]] || return 1
  for f in "$merge_dir"/*; do
    [[ -f "$f" ]] || continue
    q_repo=""
    q_pr=""
    eval "$(grep -E '^(REPO|PR)=' "$f" 2>/dev/null || true)"
    q_repo="${REPO:-}"
    q_pr="${PR:-}"
    [[ -n "$q_repo" && -n "$q_pr" ]] || continue
    q_key="$(_merge_queue_repo_pr_key "$q_repo" "$q_pr")"
    if [[ "$q_key" == "$key" ]]; then
      echo "$f"
      return 0
    fi
  done
  return 1
}

_merge_queue_enqueue_polecat() {
  local rig="${1:-}" repo="${2:-}" branch="${3:-}" issue="${4:-}" pr="${5:-}" head_sha="${6:-}"
  local auto_merge="${7:-true}" backend="${8:-$(_ai_backend_default)}" polecat="${9:-}" source="${10:-unknown}"
  [[ -n "$rig" && -n "$repo" && -n "$pr" ]] || return 1

  local merge_dir queue_key owner_repo queue_name queue_file existing_file existing_name reason reason_code
  merge_dir="$SGT_CONFIG/merge-queue"
  mkdir -p "$merge_dir"

  queue_key="$(_merge_queue_repo_pr_key "$repo" "$pr")"
  owner_repo="$(_repo_owner_repo "$repo")"
  [[ -n "$owner_repo" ]] || owner_repo="$repo"
  queue_name="$(_merge_queue_canonical_name "$rig" "$pr")"
  queue_file="$merge_dir/$queue_name"

  existing_file="$(_merge_queue_find_by_repo_pr "$repo" "$pr" || true)"
  if [[ -n "$existing_file" ]]; then
    existing_name="$(basename "$existing_file")"
    reason_code="duplicate-queue-key"
    reason="duplicate queue key (repo+pr) already queued"
    echo "[merge-queue/$rig] duplicate queue skipped — reason_code=$reason_code reason=\"$reason\" key=$queue_key existing=$existing_name incoming=$queue_name source=$source"
    log_event "MERGE_QUEUE_DUPLICATE_SKIP rig=$rig repo=$owner_repo pr=#$pr reason_code=$reason_code reason=\"$(_escape_quotes "$reason")\" key=\"$(_escape_quotes "$queue_key")\" existing=$existing_name incoming=$queue_name source=$source"
    return 1
  fi

  cat > "$queue_file" <<MQSTATE
POLECAT=${polecat:-$queue_name}
RIG=$rig
REPO=$repo
BRANCH=$branch
ISSUE=${issue:-0}
PR=$pr
HEAD_SHA=$head_sha
AUTO_MERGE=$auto_merge
BACKEND=$backend
TYPE=polecat
REVIEW_STATE=REVIEW_PENDING
REVIEW_UPDATED_AT=$(date +%s)
REVIEW_UNCLEAR_SINCE=
QUEUED=$(date -Iseconds)
MQSTATE
  return 0
}

_refinery_merge_attempt_key() {
  local repo="${1:-}" pr="${2:-}" head_sha="${3:-}"
  local owner_repo
  owner_repo="$(_repo_owner_repo "$repo")"
  [[ -n "$owner_repo" ]] || owner_repo="$repo"
  echo "${owner_repo}|pr=${pr}|head=${head_sha:-unknown}"
}

_refinery_merge_attempt_key_id() {
  local key="${1:-}"
  if command -v sha256sum >/dev/null 2>&1; then
    printf '%s' "$key" | sha256sum | awk '{print $1}'
  elif command -v shasum >/dev/null 2>&1; then
    printf '%s' "$key" | shasum -a 256 | awk '{print $1}'
  else
    printf '%s' "$key" | tr -c '[:alnum:]_.-' '_'
  fi
}

_refinery_merge_attempt_claim() {
  local repo="${1:-}" pr="${2:-}" head_sha="${3:-}" queue_name="${4:-}"
  local key key_id key_dir key_file
  _REFINERY_MERGE_ATTEMPT_KEY=""
  _REFINERY_MERGE_ATTEMPT_FILE=""
  key="$(_refinery_merge_attempt_key "$repo" "$pr" "$head_sha")"
  key_id="$(_refinery_merge_attempt_key_id "$key")"
  key_dir="$SGT_CONFIG/refinery-merge-attempts"
  key_file="$key_dir/$key_id"
  mkdir -p "$key_dir" || return 1
  _REFINERY_MERGE_ATTEMPT_KEY="$key"
  _REFINERY_MERGE_ATTEMPT_FILE="$key_file"
  if ! ( set -o noclobber; : > "$key_file" ) 2>/dev/null; then
    return 1
  fi
  cat > "$key_file" <<EOF
KEY=$key
REPO=$repo
PR=$pr
HEAD_SHA=${head_sha:-unknown}
QUEUE=${queue_name:-unknown}
CLAIMED_AT=$(date -Iseconds)
EOF
  return 0
}

_refinery_merge_attempt_release() {
  local key_file="${1:-}"
  [[ -n "$key_file" ]] || key_file="${_REFINERY_MERGE_ATTEMPT_FILE:-}"
  [[ -n "$key_file" ]] || return 0
  rm -f "$key_file" 2>/dev/null || true
}

_refinery_merge_retry_max_attempts() {
  local raw="${SGT_REFINERY_MERGE_MAX_ATTEMPTS:-3}"
  [[ "$raw" =~ ^[0-9]+$ ]] || raw=3
  (( raw < 1 )) && raw=1
  echo "$raw"
}

_refinery_merge_retry_base_ms() {
  local raw="${SGT_REFINERY_MERGE_RETRY_BASE_MS:-1000}"
  [[ "$raw" =~ ^[0-9]+$ ]] || raw=1000
  echo "$raw"
}

_refinery_merge_retry_jitter_ms() {
  local raw="${SGT_REFINERY_MERGE_RETRY_JITTER_MS:-400}"
  [[ "$raw" =~ ^[0-9]+$ ]] || raw=400
  echo "$raw"
}

_refinery_merge_retry_delay_secs() {
  local attempt="${1:-1}"
  local base_ms jitter_ms scaled_base jitter_ms_actual total_ms
  [[ "$attempt" =~ ^[0-9]+$ ]] || attempt=1
  (( attempt < 1 )) && attempt=1
  base_ms="$(_refinery_merge_retry_base_ms)"
  jitter_ms="$(_refinery_merge_retry_jitter_ms)"
  scaled_base=$((base_ms * attempt))
  jitter_ms_actual=0
  if (( jitter_ms > 0 )); then
    jitter_ms_actual=$((RANDOM % (jitter_ms + 1)))
  fi
  total_ms=$((scaled_base + jitter_ms_actual))
  printf '%d.%03d' "$((total_ms / 1000))" "$((total_ms % 1000))"
}

_refinery_merge_error_class() {
  local raw="${1:-}" lc
  lc="$(printf '%s' "$raw" | tr '[:upper:]' '[:lower:]')"
  if [[ "$lc" =~ secondary[[:space:]-]*rate[[:space:]-]*limit|abuse[[:space:]]+detection ]]; then
    echo "secondary-rate-limit"
  elif [[ "$lc" =~ timed?[[:space:]-]*out|timeout|deadline[[:space:]]+exceeded ]]; then
    echo "timeout"
  elif [[ "$lc" =~ (^|[^0-9])5[0-9][0-9]([^0-9]|$)|http[[:space:]]*5[0-9][0-9]|server[[:space:]]+error|bad[[:space:]]+gateway|service[[:space:]]+unavailable|gateway[[:space:]]+timeout ]]; then
    echo "http-5xx"
  elif [[ "$lc" =~ connection[[:space:]]+reset|connection[[:space:]]+refused|network[[:space:]]+is[[:space:]]+unreachable|temporary[[:space:]]+failure|no[[:space:]]+such[[:space:]]+host|tls|eof|i/o[[:space:]]+timeout|context[[:space:]]+canceled ]]; then
    echo "network"
  else
    echo "non-transient"
  fi
}

_refinery_merge_error_is_transient() {
  local klass="${1:-}"
  case "$klass" in
    timeout|network|http-5xx|secondary-rate-limit) return 0 ;;
    *) return 1 ;;
  esac
}

_refinery_merge_error_requires_auto_retry_reason() {
  local raw="${1:-}" lc
  lc="$(printf '%s' "$raw" | tr '[:upper:]' '[:lower:]')"
  if [[ "$lc" =~ requires?[[:space:]-]*auto[[:space:]-]*merge|auto[[:space:]-]*merge[[:space:]]+is[[:space:]]+required|must[[:space:]]+use[[:space:]-]*auto[[:space:]-]*merge|branch[[:space:]]+policy[^[:cntrl:]]*auto[[:space:]-]*merge|enable[[:space:]]+pull[[:space:]]+request[[:space:]-]*auto[[:space:]-]*merge|enablepullrequestautomerge ]]; then
    echo "branch-policy-requires-auto-merge"
    return 0
  fi
  return 1
}

_refinery_revalidate_pr_open_head() {
  local repo="${1:-}" pr="${2:-}" expected_head_sha="${3:-}" queue_file="${4:-}"
  local live_snapshot live_state live_head_sha
  live_snapshot=$(gh pr view "$pr" --repo "$repo" --json state,headRefOid --jq '.state + "|" + (.headRefOid // "")' 2>/dev/null || true)
  if [[ -z "$live_snapshot" || "$live_snapshot" != *"|"* ]]; then
    echo "unable to query live PR state"
    return 1
  fi
  IFS='|' read -r live_state live_head_sha <<< "$live_snapshot"
  if [[ "$live_state" != "OPEN" ]]; then
    echo "pr state drifted to ${live_state:-unknown}"
    return 1
  fi
  if [[ -n "$expected_head_sha" && "$live_head_sha" != "$expected_head_sha" ]]; then
    if [[ -n "$queue_file" ]]; then
      _merge_queue_set_head_sha "$queue_file" "$live_head_sha" || true
    fi
    echo "head sha drifted expected=${expected_head_sha:-unknown} live=${live_head_sha:-unknown}"
    return 1
  fi
  echo "$live_head_sha"
}

_resling_pre_dispatch_revalidate() {
  local repo="${1:-}" issue_number="${2:-}" source_pr="${3:-}"
  local issue_state pr_snapshot pr_state pr_mergeable

  issue_state=$(gh issue view "$issue_number" --repo "$repo" --json state --jq '.state' 2>/dev/null || true)
  if [[ -z "$issue_state" ]]; then
    echo "unable to query live issue state for #$issue_number"
    return 1
  fi
  if [[ "$issue_state" != "OPEN" ]]; then
    echo "issue #$issue_number state=$issue_state"
    return 1
  fi

  if [[ -n "$source_pr" && "$source_pr" != "0" ]]; then
    pr_snapshot=$(gh pr view "$source_pr" --repo "$repo" --json state,mergeable --jq '.state + "|" + (.mergeable // "")' 2>/dev/null || true)
    if [[ -z "$pr_snapshot" || "$pr_snapshot" != *"|"* ]]; then
      echo "unable to query live PR state for #$source_pr"
      return 1
    fi
    IFS='|' read -r pr_state pr_mergeable <<< "$pr_snapshot"
    if [[ "$pr_state" != "OPEN" ]]; then
      echo "source PR #$source_pr state=$pr_state"
      return 1
    fi
    if [[ "$pr_mergeable" != "MERGEABLE" ]]; then
      echo "source PR #$source_pr mergeable=${pr_mergeable:-unknown}"
      return 1
    fi
  fi
}

_find_recent_duplicate_issue() {
  local repo="${1:-}" title="${2:-}" cooldown_secs="${3:-0}"
  shift 3 || true
  local labels=("$@")
  [[ -n "$repo" && -n "$title" ]] || return 1
  [[ "$cooldown_secs" =~ ^[0-9]+$ ]] || cooldown_secs=0
  [[ "$cooldown_secs" -gt 0 ]] || return 1

  local target_signature
  target_signature="$(_symptom_signature "$title")"
  [[ -n "$target_signature" ]] || return 1

  local required_labels=() label norm_label
  for label in "${labels[@]+"${labels[@]}"}"; do
    norm_label="$(_normalize_label "$label")"
    [[ -n "$norm_label" ]] && required_labels+=("$norm_label")
  done

  local issues_tsv
  issues_tsv=$(
    gh issue list --repo "$repo" --state all --limit 100 \
      --json number,title,state,url,createdAt,closedAt,labels \
      --jq '.[] | [
        (.number|tostring),
        .url,
        .state,
        (.title | ascii_downcase | gsub("[0-9]+";" num ") | gsub("[^a-z]+";" ") | gsub(" +";" ") | sub("^ ";"") | sub(" $";"")),
        (.labels | map(.name | ascii_downcase) | join(",")),
        .createdAt,
        (.closedAt // "")
      ] | @tsv' 2>/dev/null || true
  )
  [[ -n "$issues_tsv" ]] || return 1

  local now_epoch best_ref=0 best_match=""
  now_epoch=$(date +%s)
  local issue_number issue_url issue_state issue_sig issue_labels created_at closed_at
  while IFS=$'\t' read -r issue_number issue_url issue_state issue_sig issue_labels created_at closed_at; do
    [[ -n "$issue_number" ]] || continue
    [[ "$issue_sig" == "$target_signature" ]] || continue

    local labels_ok=true required
    for required in "${required_labels[@]+"${required_labels[@]}"}"; do
      if [[ ",$issue_labels," != *",$required,"* ]]; then
        labels_ok=false
        break
      fi
    done
    [[ "$labels_ok" == "true" ]] || continue

    local reference_at="$created_at"
    if [[ "${issue_state^^}" == "CLOSED" && -n "$closed_at" ]]; then
      reference_at="$closed_at"
    fi
    local reference_epoch
    reference_epoch=$(date -d "$reference_at" +%s 2>/dev/null || echo 0)
    [[ "$reference_epoch" -gt 0 ]] || continue

    local age=$((now_epoch - reference_epoch))
    [[ "$age" -lt 0 ]] && age=0
    if [[ "$age" -le "$cooldown_secs" && "$reference_epoch" -ge "$best_ref" ]]; then
      best_ref="$reference_epoch"
      best_match="${issue_number}|${issue_url}|${issue_state}|${age}"
    fi
  done <<< "$issues_tsv"

  [[ -n "$best_match" ]] && echo "$best_match"
}

# Notify via OpenClaw (delivered) if configured. No-op if missing.
_notify_openclaw() {
  local message="${1:-}"
  [[ -n "$message" ]] || return 0
  command -v openclaw &>/dev/null || return 0
  [[ -f "$SGT_NOTIFY" ]] || return 0

  local channel="" to="" reply_to=""
  local notify_out=""
  local py_bin=""
  local py_parse_notify='import json, sys
path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
except Exception:
    sys.exit(1)
def get(keys):
    for k in keys:
        v = data.get(k)
        if v is None:
            continue
        v = str(v).strip()
        if v:
            return v
    return ""
print(get(["channel"]))
print(get(["to"]))
print(get(["reply_to", "reply-to", "replyTo"]))'

  # Avoid heredoc inside command substitution to prevent bash parser warnings.
  if command -v python3 &>/dev/null; then
    py_bin="python3"
  elif command -v python &>/dev/null; then
    py_bin="python"
  else
    return 0
  fi

  notify_out="$("$py_bin" -c "$py_parse_notify" "$SGT_NOTIFY" 2>/dev/null)" || return 0

  local fields=()
  while IFS= read -r line; do fields+=("$line"); done <<< "$notify_out"
  channel="${fields[0]:-}"
  to="${fields[1]:-}"
  reply_to="${fields[2]:-}"
  [[ -n "$channel" ]] || channel="last"

  local cmd=(openclaw agent --agent gastown --deliver --message "$message" --channel "$channel")
  [[ -n "$to" ]] && cmd+=(--to "$to")
  [[ -n "$reply_to" ]] && cmd+=(--reply-to "$reply_to")

  "${cmd[@]}" &>/dev/null &
  disown 2>/dev/null
  log_event "OPENCLAW_NOTIFY channel=$channel to=$to reply_to=$reply_to message=$message"
}

# Wake the mayor via FIFO (non-blocking, fire-and-forget)
_wake_mayor() {
  local reason="${1:-unknown}"
  if [[ -p "$SGT_MAYOR_FIFO" ]]; then
    # Non-blocking write — don't hang if nobody's reading
    echo "$reason" > "$SGT_MAYOR_FIFO" &
    disown 2>/dev/null
  fi
}

# Wake a rig's refinery via FIFO (non-blocking)
_wake_refinery() {
  local rig="$1"
  local reason="${2:-unknown}"
  local fifo="$SGT_CONFIG/refinery-${rig}.fifo"
  if [[ -p "$fifo" ]]; then
    echo "$reason" > "$fifo" &
    disown 2>/dev/null
  fi
}

ensure_init() {
  [[ -d "$SGT_CONFIG" ]] || die "not initialized — run: sgt init"
  # Load settings if present
  if [[ -f "$SGT_SETTINGS_ENV" ]]; then
    # shellcheck disable=SC1090
    source "$SGT_SETTINGS_ENV" 2>/dev/null || true
  fi
}

_ai_backend_default() {
  local b="${SGT_AI_BACKEND:-}"
  if [[ -z "$b" && -f "$SGT_SETTINGS_ENV" ]]; then
    b=$(grep -E '^SGT_AI_BACKEND=' "$SGT_SETTINGS_ENV" 2>/dev/null | head -1 | cut -d= -f2 | tr -d '"' || true)
  fi
  b="${b:-claude}"
  case "$b" in
    claude|codex) echo "$b" ;;
    *) die "invalid SGT_AI_BACKEND '$b' (expected claude|codex)" ;;
  esac
}

_ai_cmd() {
  # Print a command that runs the selected backend with a prompt.
  # Usage: _ai_cmd <backend> <prompt>
  local backend="$1" prompt="$2"
  case "$backend" in
    claude)
      printf 'claude %q --dangerously-skip-permissions' "$prompt"
      ;;
    codex)
      # Non-interactive agent run; allow full access like the previous claude invocation.
      # Force Codex CLI to use OpenAI directly (ignore any local proxy env like OPENAI_BASE_URL).
      printf 'OPENAI_BASE_URL= OPENAI_API_BASE= OPENAI_HOST= codex exec --dangerously-bypass-approvals-and-sandbox --skip-git-repo-check --color auto %q' "$prompt"
      ;;
    *)
      die "unknown backend: $backend"
      ;;
  esac
}

_ai_promptfile() {
  # Run a backend using a prompt read from a file; echoes agent output to stdout.
  # Usage: _ai_promptfile <backend> <workdir> <prompt_file>
  local backend="$1" workdir="$2" prompt_file="$3"
  case "$backend" in
    claude)
      ( cd "$workdir" && claude -p "Read $(basename "$prompt_file")." --dangerously-skip-permissions )
      ;;
    codex)
      local out="$workdir/.codex-last-message.txt"
      rm -f "$out" 2>/dev/null || true
      # Feed the file content as stdin prompt (more reliable than shell-escaping huge text)
      ( cd "$workdir" && OPENAI_BASE_URL= OPENAI_API_BASE= OPENAI_HOST= codex exec --dangerously-bypass-approvals-and-sandbox --skip-git-repo-check --color never -o "$out" - < "$prompt_file" >/dev/null 2>&1 ) || true
      cat "$out" 2>/dev/null || true
      ;;
    *)
      die "unknown backend: $backend"
      ;;
  esac
}

_ai_prompt() {
  # Run a backend with a prompt string (non-interactive); echoes agent output to stdout.
  # Usage: _ai_prompt <backend> <workdir> <prompt>
  local backend="$1" workdir="$2" prompt="$3"
  case "$backend" in
    claude)
      ( cd "$workdir" && claude -p "$prompt" --dangerously-skip-permissions )
      ;;
    codex)
      local out="$workdir/.codex-last-message.txt"
      rm -f "$out" 2>/dev/null || true
      ( cd "$workdir" && printf "%s" "$prompt" | OPENAI_BASE_URL= OPENAI_API_BASE= OPENAI_HOST= codex exec --dangerously-bypass-approvals-and-sandbox --skip-git-repo-check --color never -o "$out" - >/dev/null 2>&1 ) || true
      cat "$out" 2>/dev/null || true
      ;;
    *)
      die "unknown backend: $backend"
      ;;
  esac
}

ensure_rig() {
  local name="$1"
  [[ -f "$SGT_RIGS/$name" ]] || die "rig '$name' not found — run: sgt rig list"
}

rig_repo() {
  local name="$1"
  cat "$SGT_RIGS/$name"
}

rig_owner_repo() {
  local name="$1"
  local repo
  repo="$(rig_repo "$name")"
  echo "${repo#https://github.com/}"
}

rig_path() {
  local name="$1"
  echo "$SGT_ROOT/rigs/$name"
}

# Check if an issue has the sgt-authorized label
# Security gate can be disabled by setting: SGT_REQUIRE_AUTH_LABEL=0
_has_sgt_authorized() {
  local repo="$1" issue="$2"
  if [[ "${SGT_REQUIRE_AUTH_LABEL:-1}" == "0" ]]; then
    return 0
  fi
  [[ -n "$issue" && "$issue" != "0" ]] || return 1
  local labels
  labels=$(gh issue view "$issue" --repo "$repo" --json labels --jq '.labels[].name' 2>/dev/null || true)
  echo "$labels" | grep -qx "sgt-authorized"
}

# Ensure the sgt-authorized label exists on a repo (idempotent)
_ensure_sgt_authorized_label() {
  local repo="$1"
  gh label create "sgt-authorized" --repo "$repo" \
    --description "Authorized for sgt processing — do not apply manually" \
    --color "0E8A16" --force 2>/dev/null || true
}

# Generate polecat name: <rig>-<short-id>
polecat_name() {
  local rig="$1"
  echo "${rig}-$(head -c4 /dev/urandom | xxd -p)"
}

# List all rig names
list_rigs() {
  ls -1 "$SGT_RIGS" 2>/dev/null || true
}

# ─── Init ─────────────────────────────────────────────────────────────

cmd_init() {
  mkdir -p "$SGT_CONFIG" "$SGT_RIGS" "$SGT_POLECATS" "$SGT_AGENTS" "$SGT_ROOT/rigs" "$SGT_ROOT/polecats" "$SGT_CONFIG/merge-queue" "$SGT_CONFIG/dogs"
  touch "$SGT_LOG"
  if [[ ! -f "$SGT_SETTINGS_ENV" ]]; then
    cat > "$SGT_SETTINGS_ENV" <<EOF
# sgt settings (sourced by bash)
# Supported: SGT_AI_BACKEND=claude|codex
SGT_AI_BACKEND=claude
EOF
  fi
  log_event "INIT sgt workspace at $SGT_ROOT"
  info "initialized sgt at $SGT_ROOT"
}

# ─── Rig Commands ─────────────────────────────────────────────────────

cmd_rig_add() {
  local name="${1:-}" repo="${2:-}"
  [[ -n "$name" ]] || die "usage: sgt rig add <name> <github-repo>"
  [[ -n "$repo" ]] || die "usage: sgt rig add <name> <github-repo>"
  ensure_init

  if [[ "$repo" =~ ^https?:// ]]; then
    repo="$repo"
  elif [[ "$repo" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9._-]+$ ]]; then
    repo="https://github.com/$repo"
  else
    die "repo must be 'owner/repo' or a full URL"
  fi

  echo "$repo" > "$SGT_RIGS/$name"

  local rpath
  rpath="$(rig_path "$name")"
  if [[ ! -d "$rpath" ]]; then
    info "cloning $repo → $rpath"
    git clone "$repo" "$rpath"
  else
    info "rig directory exists, pulling latest"
    git -C "$rpath" pull --ff-only 2>/dev/null || true
  fi

  _write_claude_md "$rpath"
  _ensure_sgt_authorized_label "$repo"
  log_event "RIG_ADD $name $repo"
  info "rig '$name' added ($repo)"
}

cmd_rig_list() {
  ensure_init
  if [[ -z "$(ls -A "$SGT_RIGS" 2>/dev/null)" ]]; then
    info "no rigs — run: sgt rig add <name> <repo>"
    return
  fi
  for f in "$SGT_RIGS"/*; do
    local name repo
    name="$(basename "$f")"
    repo="$(cat "$f")"
    local active
    active=$(find "$SGT_POLECATS" -name "${name}-*" 2>/dev/null | wc -l)
    local witness_alive="off"
    tmux has-session -t "sgt-witness-${name}" 2>/dev/null && witness_alive="on"
    local refinery_alive="off"
    tmux has-session -t "sgt-refinery-${name}" 2>/dev/null && refinery_alive="on"
    echo "  $name  $repo"
    echo "    polecats: $active  witness: $witness_alive  refinery: $refinery_alive"
  done
}

cmd_rig_remove() {
  local name="${1:-}"
  [[ -n "$name" ]] || die "usage: sgt rig remove <name>"
  ensure_init
  ensure_rig "$name"

  local active
  active=$(find "$SGT_POLECATS" -name "${name}-*" 2>/dev/null | wc -l)
  if [[ "$active" -gt 0 ]]; then
    die "rig '$name' has $active active polecats — nuke them first"
  fi

  rm -f "$SGT_RIGS/$name"
  log_event "RIG_REMOVE $name"
  info "rig '$name' removed (repo directory kept at $(rig_path "$name"))"
}

# ─── Sling (Dispatch Work) ────────────────────────────────────────────

cmd_sling() {
  local rig="${1:-}"
  [[ -n "$rig" ]] || die "usage: sgt sling <rig> <task description> [--convoy <milestone>] [--label <label>]"
  shift

  local task="" convoy="" labels=() branch_prefix="sgt" auto_merge=false
  local backend="$(_ai_backend_default)"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --convoy)  convoy="$2"; shift 2 ;;
      --label)   labels+=("$2"); shift 2 ;;
      --auto-merge) auto_merge=true; shift ;;
      --backend) backend="$2"; shift 2 ;;
      *)         task="${task:+$task }$1"; shift ;;
    esac
  done

  [[ -n "$task" ]] || die "no task description provided"
  ensure_init
  ensure_rig "$rig"

  case "$backend" in claude|codex) ;; *) die "invalid backend $backend (expected claude|codex)" ;; esac

  local repo rpath pname branch session_name
  repo="$(rig_repo "$rig")"
  rpath="$(rig_path "$rig")"
  pname="$(polecat_name "$rig")"
  branch="${branch_prefix}/${pname}"
  session_name="sgt-${pname}"

  # ── 1. Create GitHub Issue ──
  info "creating issue on $(basename "$repo")..."
  _ensure_sgt_authorized_label "$repo"
  labels+=("sgt-authorized")
  local label_args=""
  for l in "${labels[@]+"${labels[@]}"}"; do
    label_args="$label_args --label $l"
  done

  local dispatch_cooldown duplicate_issue
  dispatch_cooldown="$(_dispatch_cooldown_secs)"
  if [[ "$dispatch_cooldown" -gt 0 ]]; then
    duplicate_issue=$(_find_recent_duplicate_issue "$repo" "$task" "$dispatch_cooldown" "${labels[@]+"${labels[@]}"}" || true)
    if [[ -n "$duplicate_issue" ]]; then
      local dup_number dup_url dup_state dup_age
      IFS='|' read -r dup_number dup_url dup_state dup_age <<< "$duplicate_issue"
      warn "suppressing duplicate dispatch: #$dup_number ($dup_state, ${dup_age}s ago) matches symptom signature"
      log_event "SLING_SUPPRESS_DUPLICATE rig=$rig match=#$dup_number cooldown=${dispatch_cooldown}s title=\"$(_escape_quotes "$task")\""
      info "duplicate issue within cooldown: $dup_url"
      return 0
    fi
  fi

  if [[ "${SGT_MAYOR_DISPATCH_REVALIDATE:-0}" == "1" ]]; then
    local revalidation_reason
    if ! revalidation_reason=$(_mayor_pre_dispatch_revalidate "$repo"); then
      echo "[mayor] dispatch skipped on $rig - $revalidation_reason"
      local stale_entry=""
      stale_entry+="MAYOR DISPATCH SKIP (stale-state)"$'\n'
      stale_entry+="  rig=$rig"$'\n'
      stale_entry+="  reason=$revalidation_reason"$'\n'
      stale_entry+="  task=\"$(_escape_quotes "$task")\""
      _mayor_record_decision "$stale_entry" "dispatch-skip-stale" "$SGT_ROOT" || true
      log_event "MAYOR_DISPATCH_SKIP_STALE rig=$rig reason=\"$(_escape_quotes "$revalidation_reason")\" title=\"$(_escape_quotes "$task")\""
      return 0
    fi
  fi

  local issue_url issue_number
  local issue_body
  printf -v issue_body '## Task

%s

---

*Created by sgt — polecat: `%s`*
*Branch: `%s`*' "$task" "$pname" "$branch"
  issue_url=$(gh issue create \
    --repo "$repo" \
    --title "$task" \
    --body "$issue_body" \
    $label_args 2>&1) || die "failed to create issue: $issue_url"

  issue_number=$(echo "$issue_url" | grep -oP '/issues/\K[0-9]+')
  info "issue #$issue_number created: $issue_url"

  # ── 2. Add to milestone if convoy specified ──
  if [[ -n "$convoy" ]]; then
    local owner_repo="${repo#https://github.com/}"
    local ms_number
    ms_number=$(gh api "repos/$owner_repo/milestones" --jq ".[] | select(.title==\"$convoy\") | .number" 2>/dev/null || true)
    if [[ -z "$ms_number" ]]; then
      ms_number=$(gh api "repos/$owner_repo/milestones" \
        -f title="$convoy" -f state=open \
        --jq '.number' 2>/dev/null) || warn "couldn't create milestone"
    fi
    if [[ -n "$ms_number" ]]; then
      gh issue edit "$issue_number" --repo "$repo" --milestone "$convoy" 2>/dev/null || true
      info "added to convoy (milestone): $convoy"
    fi
  fi

  # ── 3. Create branch + worktree ──
  info "setting up branch $branch..."
  git -C "$rpath" fetch origin 2>/dev/null || true
  local default_branch
  default_branch=$(git -C "$rpath" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's|refs/remotes/origin/||' || echo "main")

  local worktree="$SGT_ROOT/polecats/$pname"
  mkdir -p "$SGT_ROOT/polecats"
  git -C "$rpath" worktree add -b "$branch" "$worktree" "origin/$default_branch" 2>/dev/null \
    || git -C "$rpath" worktree add -b "$branch" "$worktree" "$default_branch"

  if [[ -f "$rpath/CLAUDE.md" ]]; then
    cp "$rpath/CLAUDE.md" "$worktree/CLAUDE.md"
  fi
  _write_polecat_claude_md "$worktree" "$issue_number" "$task" "$repo" "$pname" "$branch" "$default_branch" "$auto_merge"

  # ── 4. Save polecat state ──
  cat > "$SGT_POLECATS/$pname" <<PSTATE
RIG=$rig
REPO=$repo
ISSUE=$issue_number
ISSUE_URL=$issue_url
BRANCH=$branch
WORKTREE=$worktree
SESSION=$session_name
DEFAULT_BRANCH=$default_branch
AUTO_MERGE=$auto_merge
BACKEND=$backend
CREATED=$(date -Iseconds)
STATUS=running
PSTATE

  # ── 5. Spawn AI agent in tmux ──
  info "spawning polecat $pname in tmux session $session_name..."
  tmux new-session -d -s "$session_name" -c "$worktree" \
    "$( _ai_cmd "$backend" "Read the CLAUDE.md in this directory. Your task is described in GitHub issue #${issue_number}. The issue title is: ${task}. Work on branch ${branch}. When done, commit your changes, push the branch, and open a PR that closes #${issue_number}." ); echo '[SGT] polecat exited'; sgt _wake-refinery '${rig}' 'polecat-done:${pname}:#${issue_number}' 2>/dev/null"

  log_event "SLING $pname rig=$rig issue=#$issue_number branch=$branch"
  _wake_refinery "$rig" "sling:$pname:#$issue_number"

  info ""
  info "polecat $pname dispatched"
  info "  issue:   $issue_url"
  info "  branch:  $branch"
  info "  session: $session_name"
  info "  peek:    sgt peek $pname"
}

# ─── Status ───────────────────────────────────────────────────────────

cmd_status() {
  ensure_init
  local status_term_cols status_pr_title_cols
  status_term_cols="$(_term_cols)"
  [[ "$status_term_cols" =~ ^[0-9]+$ ]] || status_term_cols=80
  status_pr_title_cols="$(_status_pr_title_cols)"

  _section "Agents"

  local daemon_alive="off" daemon_pid=""
  if [[ -f "$SGT_DAEMON_PID" ]] && kill -0 "$(cat "$SGT_DAEMON_PID")" 2>/dev/null; then
    daemon_alive="on"
    daemon_pid="$(cat "$SGT_DAEMON_PID")"
  fi
  if [[ -n "$daemon_pid" ]]; then
    printf "  %-16s %s  %s(pid %s)%s\n" "daemon" "$(_status_badge "$daemon_alive")" "$(_fg_gray)" "$daemon_pid" "$(_reset)"
  else
    printf "  %-16s %s\n" "daemon" "$(_status_badge "$daemon_alive")"
  fi

  local deacon_alive="off"
  tmux has-session -t "sgt-deacon" 2>/dev/null && deacon_alive="on"
  local hb_age hb_ts hb_state hb_stale_secs hb_health deacon_badge
  hb_stale_secs="$(_deacon_heartbeat_stale_secs)"
  IFS='|' read -r hb_age hb_ts hb_state <<< "$(_deacon_heartbeat_snapshot)"
  hb_health="$(_deacon_heartbeat_health "$hb_age" "$hb_stale_secs")"
  deacon_badge="$deacon_alive"
  if [[ "$deacon_alive" == "on" && "$hb_health" != "healthy" ]]; then
    deacon_badge="degraded"
  fi
  printf "  %-16s %s\n" "deacon" "$(_status_badge "$deacon_badge")"
  if [[ "$hb_state" == "ok" ]]; then
    printf "  %-16s %s%s%s\n" "" "$(_dim)" "last heartbeat: $hb_ts (${hb_age}s ago, ${hb_health}, stale>${hb_stale_secs}s)" "$(_reset)"
  elif [[ "$hb_state" == "missing" ]]; then
    printf "  %-16s %s%s%s\n" "" "$(_dim)" "last heartbeat: missing (health unknown, stale>${hb_stale_secs}s)" "$(_reset)"
  else
    printf "  %-16s %s%s%s\n" "" "$(_dim)" "last heartbeat: ${hb_ts:-invalid} (health unknown, stale>${hb_stale_secs}s)" "$(_reset)"
  fi

  for rig_file in "$SGT_RIGS"/*; do
    [[ -f "$rig_file" ]] || continue
    local rig_name
    rig_name="$(basename "$rig_file")"
    local w_alive="off" r_alive="off"
    tmux has-session -t "sgt-witness-${rig_name}" 2>/dev/null && w_alive="on"
    tmux has-session -t "sgt-refinery-${rig_name}" 2>/dev/null && r_alive="on"
    printf "  %-16s %s\n" "witness/$rig_name"  "$(_status_badge "$w_alive")"
    printf "  %-16s %s\n" "refinery/$rig_name" "$(_status_badge "$r_alive")"
  done

  local mayor_alive="off"
  tmux has-session -t "sgt-mayor" 2>/dev/null && mayor_alive="on"
  printf "  %-16s %s\n" "mayor" "$(_status_badge "$mayor_alive")"
  local mayor_lock_state mayor_lock_owner mayor_lock_started mayor_lock_until
  IFS='|' read -r mayor_lock_state mayor_lock_owner mayor_lock_started mayor_lock_until <<< "$(_mayor_lock_snapshot)"
  if [[ "$mayor_lock_state" == "none" ]]; then
    printf "  %-16s %s%s%s\n" "" "$(_dim)" "lock: none" "$(_reset)"
  else
    printf "  %-16s %s%s%s\n" "" "$(_dim)" "lock: state=$mayor_lock_state ownerPid=$mayor_lock_owner startedAt=$mayor_lock_started leaseUntil=$mayor_lock_until" "$(_reset)"
  fi
  local log_fail_ts log_fail_context log_fail_workspace log_fail_error log_fail_age
  IFS='|' read -r log_fail_ts log_fail_context log_fail_workspace log_fail_error <<< "$(_mayor_decision_log_failure_state_read)"
  if [[ "$log_fail_ts" =~ ^[0-9]+$ ]]; then
    log_fail_age=$(( $(date +%s) - log_fail_ts ))
    if [[ "$log_fail_age" -lt 0 ]]; then
      log_fail_age=0
    fi
    printf "  %-16s %s%s%s\n" "" "$(_fg_yellow)" "decision-log warning: ${log_fail_age}s ago context=$log_fail_context error=$log_fail_error" "$(_reset)"
  fi
  local review_watch_count review_watch_oldest review_watch_threshold
  IFS='|' read -r review_watch_count review_watch_oldest review_watch_threshold <<< "$(_mayor_review_watchdog_status_snapshot)"
  if [[ "$review_watch_count" =~ ^[0-9]+$ && "$review_watch_count" -gt 0 ]]; then
    printf "  %-16s %s%s%s\n" "" "$(_fg_yellow)" "review watchdog: ${review_watch_count} stalled REVIEW_UNCLEAR (oldest=${review_watch_oldest}s threshold>=${review_watch_threshold}s)" "$(_reset)"
  else
    printf "  %-16s %s%s%s\n" "" "$(_dim)" "review watchdog: clear (threshold>=${review_watch_threshold}s)" "$(_reset)"
  fi
  local ci_watch_count ci_watch_oldest ci_watch_threshold ci_watch_dedupe
  IFS='|' read -r ci_watch_count ci_watch_oldest ci_watch_threshold <<< "$(_mayor_ci_watchdog_status_snapshot)"
  ci_watch_dedupe="$(_mayor_ci_watchdog_dedupe_window_secs)"
  if [[ "$ci_watch_count" =~ ^[0-9]+$ && "$ci_watch_count" -gt 0 ]]; then
    printf "  %-16s %s%s%s\n" "" "$(_fg_yellow)" "ci watchdog: ${ci_watch_count} stalled required checks (oldest=${ci_watch_oldest}s threshold>=${ci_watch_threshold}s dedupe=${ci_watch_dedupe}s)" "$(_reset)"
  else
    printf "  %-16s %s%s%s\n" "" "$(_dim)" "ci watchdog: clear (threshold>=${ci_watch_threshold}s dedupe=${ci_watch_dedupe}s)" "$(_reset)"
  fi

  _section "Dogs"
  local dog_count=0
  if [[ -d "$SGT_CONFIG/dogs" ]]; then
    for df in "$SGT_CONFIG/dogs"/*; do
      [[ -f "$df" ]] || continue
      dog_count=$((dog_count + 1))
      local dname
      dname="$(basename "$df")"
      (
        source "$df"
        local alive="dead"
        tmux has-session -t "$SESSION" 2>/dev/null && alive="alive"
        printf "  %-16s %s  %s#%s%s\n" "$dname" "$(_status_badge "$alive")" "$(_fg_gray)" "$ISSUE" "$(_reset)"
      )
    done
  fi
  [[ "$dog_count" -eq 0 ]] && printf "  %s%s%s\n" "$(_dim)" "none" "$(_reset)"

  _section "Crew"
  local crew_count=0
  if [[ -d "$SGT_CONFIG/crew" ]]; then
    for cf in "$SGT_CONFIG/crew"/*; do
      [[ -f "$cf" ]] || continue
      crew_count=$((crew_count + 1))
      local cname
      cname="$(basename "$cf")"
      (
        source "$cf"
        local alive="asleep"
        tmux has-session -t "$SESSION" 2>/dev/null && alive="awake"
        printf "  %-16s %s  %s(%s/%s)%s\n" "$cname" "$(_status_badge "$alive")" "$(_fg_gray)" "$ROLE" "$RIG" "$(_reset)"
      )
    done
  fi
  [[ "$crew_count" -eq 0 ]] && printf "  %s%s%s\n" "$(_dim)" "none" "$(_reset)"

  _section "Merge Queue"
  local mq_count=0
  if [[ -d "$SGT_CONFIG/merge-queue" ]]; then
    for mqf in "$SGT_CONFIG/merge-queue"/*; do
      [[ -f "$mqf" ]] || continue
      mq_count=$((mq_count + 1))
      (
        source "$mqf"
        printf "  %-16s %sPR#%s%s  %s%s%s\n" "$(basename "$mqf")" "$(_fg_gray)" "${PR:-?}" "$(_reset)" "$(_dim)" "${RIG:-?}" "$(_reset)"
      )
    done
  fi
  [[ "$mq_count" -eq 0 ]] && printf "  %s%s%s\n" "$(_dim)" "empty" "$(_reset)"

  _section "Polecats"
  local count=0
  for f in "$SGT_POLECATS"/*; do
    [[ -f "$f" ]] || continue
    count=$((count + 1))

    local pname
    pname="$(basename "$f")"
    (
      local session repo branch issue missing_fields
      local pr_number pr_state pr_title pr_chunk pr_meta pr_title_cols
      if ! source "$f" 2>/dev/null; then
        printf "  %s%-14s%s %s\n" "$(_bold)" "$pname" "$(_reset)" "$(_status_badge "unknown")"
        printf "  %s%s%s\n" "$(_fg_yellow)" "      ↳ metadata unreadable (possibly mid-write race); retry 'sgt status'." "$(_reset)"
        return 0
      fi
      session="${SESSION:-}"
      repo="${REPO:-}"
      branch="${BRANCH:-}"
      issue="${ISSUE:-?}"
      missing_fields=""
      [[ -z "$session" ]] && missing_fields="${missing_fields} SESSION"
      [[ -z "$repo" ]] && missing_fields="${missing_fields} REPO"
      [[ -z "$branch" ]] && missing_fields="${missing_fields} BRANCH"
      if [[ -n "$missing_fields" ]]; then
        printf "  %s%-14s%s %s  %s#%s%s\n" \
          "$(_bold)" "$pname" "$(_reset)" \
          "$(_status_badge "unknown")" \
          "$(_fg_gray)" "$issue" "$(_reset)"
        printf "  %s%s%s\n" "$(_fg_yellow)" "      ↳ metadata missing:${missing_fields} (possible race); retry 'sgt status' or run 'sgt nuke $pname' if stale." "$(_reset)"
        return 0
      fi
      local alive="dead"
      tmux has-session -t "$session" 2>/dev/null && alive="alive"

      pr_number=""
      pr_state=""
      pr_title=""
      pr_meta="$(gh pr list --repo "$repo" --head "$branch" --json number,state,title --jq 'if length == 0 then "" else "\(.[0].number)\t\(.[0].state // "")\t\(.[0].title // "")" end' 2>/dev/null || true)"
      if [[ -n "$pr_meta" ]]; then
        IFS=$'\t' read -r pr_number pr_state pr_title <<< "$pr_meta"
      fi

      pr_chunk=""
      if [[ -n "$pr_number" ]]; then
        pr_chunk="  PR#${pr_number} ${pr_state}"
      fi

      printf "  %s%-14s%s %s  %s#%s%s  %s%s%s\n" \
        "$(_bold)" "$pname" "$(_reset)" \
        "$(_status_badge "$alive")" \
        "$(_fg_gray)" "$issue" "$(_reset)" \
        "$(_dim)" "$branch$pr_chunk" "$(_reset)"

      if [[ "$alive" == "dead" && -z "$pr_number" ]]; then
        printf "  %s%s%s\n" "$(_fg_yellow)" "      ↳ PR metadata unavailable (possible race); retry 'sgt status' or run 'sgt nuke $pname' if stale." "$(_reset)"
      fi

      # Optional: show PR title as a second dense line (only if present)
      if [[ -n "$pr_title" ]]; then
        pr_title_cols="${status_pr_title_cols:-$(_status_pr_title_cols)}"
        [[ "$pr_title_cols" =~ ^[0-9]+$ ]] || pr_title_cols="$(_status_pr_title_cols)"
        printf "  %s%s%s\n" "$(_fg_gray)" "      ↳ ${pr_title:0:pr_title_cols}" "$(_reset)"
      fi
    )
  done

  if [[ "$count" -eq 0 ]]; then
    printf "  %s%s%s\n" "$(_dim)" "none" "$(_reset)"
  else
    printf "\n%s%s%s\n" "$(_fg_gray)" "$count polecat(s) tracked" "$(_reset)"
  fi
  return 0
}


# ─── Peek ─────────────────────────────────────────────────────────────

cmd_peek() {
  local target="${1:-}"
  [[ -n "$target" ]] || die "usage: sgt peek <polecat|witness/<rig>|refinery/<rig>|deacon>"
  ensure_init

  local session=""

  # Allow peeking at agents too
  case "$target" in
    deacon)       session="sgt-deacon" ;;
    witness/*)    session="sgt-witness-${target#witness/}" ;;
    refinery/*)   session="sgt-refinery-${target#refinery/}" ;;
    mayor)        session="sgt-mayor" ;;
    dog/*)        session="sgt-${target#dog/}" ;;
    crew/*)       session="sgt-crew-${target#crew/}" ;;
    *)            session="" ;;
  esac

  if [[ -n "$session" ]]; then
    if tmux has-session -t "$session" 2>/dev/null; then
      _section "peek: $target"
      tmux capture-pane -t "$session" -p -S -200
    else
      warn "$target session is dead"
    fi
    return
  fi

  # Polecat peek
  local pfile="$SGT_POLECATS/$target"
  [[ -f "$pfile" ]] || die "polecat '$target' not found"

  (
    source "$pfile"
    _section "peek: polecat/$target (#$ISSUE)"

    if tmux has-session -t "$SESSION" 2>/dev/null; then
      tmux capture-pane -t "$SESSION" -p -S -200
      return
    fi

    warn "session $SESSION is dead"
    if [[ -d "$WORKTREE" ]]; then
      printf "%s%s%s\n" "$(_dim)" "last commits on $BRANCH:" "$(_reset)"
      git -C "$WORKTREE" log --oneline -5 2>/dev/null || true
    fi

    local pr
    pr=$(gh pr list --repo "$REPO" --head "$BRANCH" --json number,state,url --jq '.[0] | "#\(.number) [\(.state)] \(.url)"' 2>/dev/null || true)
    if [[ -n "$pr" ]]; then
      printf "%s%sPR:%s %s\n" "$(_bold)" "$(_fg_mag)" "$(_reset)" "$pr"
    fi
  )
}


# ─── Nuke ─────────────────────────────────────────────────────────────

cmd_nuke() {
  local pname="${1:-}"
  [[ -n "$pname" ]] || die "usage: sgt nuke <polecat>"
  ensure_init

  local pfile="$SGT_POLECATS/$pname"
  [[ -f "$pfile" ]] || die "polecat '$pname' not found"

  (
    source "$pfile"
    if tmux has-session -t "$SESSION" 2>/dev/null; then
      tmux kill-session -t "$SESSION"
      info "killed session $SESSION"
    fi
    if [[ -d "$WORKTREE" ]]; then
      local rpath
      rpath="$(rig_path "$RIG")"
      git -C "$rpath" worktree remove --force "$WORKTREE" 2>/dev/null || rm -rf "$WORKTREE"
      info "removed worktree $WORKTREE"
    fi
    git -C "$(rig_path "$RIG")" push origin --delete "$BRANCH" 2>/dev/null && info "deleted remote branch $BRANCH" || true
  )

  rm -f "$pfile"
  log_event "NUKE $pname"
  info "polecat $pname nuked"
}

# ─── Sweep ────────────────────────────────────────────────────────────

_sweep_probe_polecat() {
  local pfile="${1:-}"
  (
    source "$pfile"

    if [[ -z "${SESSION:-}" ]]; then
      echo "ERROR|missing SESSION in polecat state"
      exit 2
    fi

    if tmux has-session -t "$SESSION" 2>/dev/null; then
      echo "SKIP|alive"
      exit 0
    fi

    if [[ -z "${REPO:-}" || -z "${BRANCH:-}" ]]; then
      echo "ERROR|missing REPO/BRANCH in polecat state"
      exit 3
    fi

    local pr_state
    pr_state=$(gh pr list --repo "$REPO" --head "$BRANCH" --json state --jq '.[0].state' 2>/dev/null || true)

    if [[ "$pr_state" == "OPEN" || "$pr_state" == "MERGED" ]]; then
      printf "CLEAN|%s|%s|%s\n" "$pr_state" "${RIG:-}" "${WORKTREE:-}"
    else
      if [[ -z "$pr_state" ]]; then
        echo "SKIP|dead-no-pr"
      else
        echo "SKIP|dead-pr-${pr_state}"
      fi
    fi
  )
}

cmd_sweep() {
  ensure_init
  local cleaned=0
  for f in "$SGT_POLECATS"/*; do
    [[ -f "$f" ]] || continue
    local pname
    pname="$(basename "$f")"
    local probe_output probe_rc
    set +e
    probe_output="$(_sweep_probe_polecat "$f")"
    probe_rc=$?
    set -e

    if [[ "$probe_rc" -eq 141 ]]; then
      info "polecat $pname had a benign closed stream — skipping"
      continue
    fi
    if [[ "$probe_rc" -ne 0 ]]; then
      if [[ -z "$probe_output" ]]; then
        die "sweep failed for polecat '$pname': no action emitted (exit $probe_rc). Use 'sgt nuke $pname' if stale."
      fi
      die "sweep failed for polecat '$pname': $probe_output. Use 'sgt nuke $pname' if stale."
    fi
    if [[ -z "$probe_output" ]]; then
      info "polecat $pname emitted no sweep action — skipping"
      continue
    fi

    local action
    action="${probe_output%%|*}"
    case "$action" in
      CLEAN)
        local _ pr_state rig_name worktree rpath
        IFS='|' read -r _ pr_state rig_name worktree <<< "$probe_output"

        info "polecat $pname completed (PR $pr_state) — cleaning up"
        if [[ -n "$worktree" && -d "$worktree" ]]; then
          rpath=""
          if [[ -n "$rig_name" ]]; then
            rpath="$(rig_path "$rig_name" 2>/dev/null || true)"
          fi

          if [[ -n "$rpath" ]]; then
            if ! git -C "$rpath" worktree remove --force "$worktree" 2>/dev/null; then
              if ! rm -rf "$worktree" 2>/dev/null; then
                die "failed to remove worktree '$worktree' for polecat '$pname'. Use 'sgt nuke $pname'."
              fi
            fi
          else
            if ! rm -rf "$worktree" 2>/dev/null; then
              die "failed to remove worktree '$worktree' for polecat '$pname'. Use 'sgt nuke $pname'."
            fi
          fi
        fi

        if ! rm -f "$f"; then
          die "failed to remove polecat state '$f' for '$pname'. Use 'sgt nuke $pname'."
        fi
        cleaned=$((cleaned + 1))
        log_event "SWEEP $pname"
        ;;
      SKIP)
        local reason
        reason="${probe_output#*|}"
        if [[ "$reason" == "dead-no-pr" ]]; then
          warn "polecat $pname is dead but no PR found — use 'sgt nuke $pname' to clean up"
        fi
        ;;
      ERROR)
        die "sweep failed for polecat '$pname': ${probe_output#*|}. Use 'sgt nuke $pname' if stale."
        ;;
      *)
        die "sweep failed for polecat '$pname': unexpected probe output '$probe_output'."
        ;;
    esac
  done

  if [[ "$cleaned" -eq 0 ]]; then
    info "nothing to sweep"
  else
    info "swept $cleaned completed polecat(s)"
  fi
}

# ─── Convoy (Milestones) ──────────────────────────────────────────────

cmd_convoy_create() {
  local name="${1:-}" repo="${2:-}"
  [[ -n "$name" ]] || die "usage: sgt convoy create <name> <repo>"
  [[ -n "$repo" ]] || die "usage: sgt convoy create <name> <repo>"
  ensure_init

  if [[ "$repo" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9._-]+$ ]]; then
    repo="https://github.com/$repo"
  fi

  local owner_repo="${repo#https://github.com/}"
  local ms_number
  ms_number=$(gh api "repos/$owner_repo/milestones" \
    -f title="$name" -f state=open \
    --jq '.number') || die "failed to create milestone"

  log_event "CONVOY_CREATE $name $owner_repo milestone=#$ms_number"
  info "convoy '$name' created (milestone #$ms_number)"
}

cmd_convoy_status() {
  local repo="${1:-}"
  [[ -n "$repo" ]] || die "usage: sgt convoy status <repo>"
  ensure_init

  if [[ "$repo" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9._-]+$ ]]; then
    repo="https://github.com/$repo"
  fi
  local owner_repo="${repo#https://github.com/}"

  gh api "repos/$owner_repo/milestones" --jq '.[] | "  \(.title): \(.open_issues) open / \(.closed_issues) closed [\(.state)]"' 2>/dev/null || info "no milestones"
}

# ─── Nudge (Send message to tmux session) ─────────────────────────────

cmd_nudge() {
  local target="${1:-}" message="${2:-}"
  [[ -n "$target" ]] || die "usage: sgt nudge <target> <message>"
  [[ -n "$message" ]] || die "usage: sgt nudge <target> <message>"
  ensure_init

  local session=""
  case "$target" in
    deacon)        session="sgt-deacon" ;;
    witness/*)     session="sgt-witness-${target#witness/}" ;;
    refinery/*)    session="sgt-refinery-${target#refinery/}" ;;
    *)             session="sgt-${target}" ;;
  esac

  if ! tmux has-session -t "$session" 2>/dev/null; then
    die "session $session is not running"
  fi

  # Send message in literal mode, then Enter
  tmux send-keys -t "$session" -l "$message"
  sleep 0.5
  tmux send-keys -t "$session" Enter

  log_event "NUDGE $target: $message"
  info "nudged $target"
}

# ─── Mail (GitHub Issue Comments as async messages) ────────────────────

cmd_mail_send() {
  local repo="${1:-}" issue="${2:-}" message="${3:-}"
  [[ -n "$repo" && -n "$issue" && -n "$message" ]] || die "usage: sgt mail send <repo> <issue#> <message>"

  if [[ "$repo" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9._-]+$ ]]; then
    repo="https://github.com/$repo"
  fi

  gh issue comment "$issue" --repo "$repo" --body "$message" 2>/dev/null \
    || die "failed to comment on issue #$issue"

  log_event "MAIL issue=#$issue: $message"
  info "mail sent to issue #$issue"
}

cmd_mail_check() {
  local repo="${1:-}"
  [[ -n "$repo" ]] || die "usage: sgt mail check <repo>"

  if [[ "$repo" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9._-]+$ ]]; then
    repo="https://github.com/$repo"
  fi
  local owner_repo="${repo#https://github.com/}"

  # Show recent issue comments (last 10)
  gh api "repos/$owner_repo/issues/comments?sort=created&direction=desc&per_page=10" \
    --jq '.[] | "  #\(.issue_url | split("/") | last) [\(.created_at | split("T")[0])]: \(.body | split("\n")[0] | .[0:80])"' 2>/dev/null \
    || info "no recent messages"
}

# ═══════════════════════════════════════════════════════════════════════
# AGENT LAYER — Witness, Refinery, Deacon, Boot, Daemon
# ═══════════════════════════════════════════════════════════════════════

# ─── Witness (per-rig polecat lifecycle manager) ──────────────────────
#
# The Witness monitors polecats for a single rig:
# - Detects stalled/zombie polecats (session dead, no PR)
# - Detects completed polecats (session dead, PR open)
# - Auto-sweeps completed polecats
# - Signals Refinery when PRs are ready for merge
# - Respawns stalled polecats (re-slings the issue)
# - Runs as a bash loop in tmux, no AI needed

_witness_loop() {
  local rig="$1"
  local repo
  repo="$(rig_repo "$rig")"
  local owner_repo="${repo#https://github.com/}"

  log_event "WITNESS_START rig=$rig"
  echo "[witness/$rig] started — monitoring polecats"

  while true; do
    local now
    now=$(date +%s)

    for f in "$SGT_POLECATS"/${rig}-*; do
      [[ -f "$f" ]] || continue
      local pname
      pname="$(basename "$f")"

      # Source in subshell to avoid polluting
      local p_session p_branch p_issue p_worktree p_created p_repo p_auto_merge
      eval "$(grep -E '^(SESSION|BRANCH|ISSUE|WORKTREE|CREATED|REPO|AUTO_MERGE|BACKEND)=' "$f")"
      p_session="$SESSION"
      p_branch="$BRANCH"
      p_issue="$ISSUE"
      p_worktree="$WORKTREE"
      p_created="$CREATED"
      p_repo="$REPO"
      p_auto_merge="${AUTO_MERGE:-false}"

      local alive=false
      tmux has-session -t "$p_session" 2>/dev/null && alive=true

      if $alive; then
        # Check if Claude Code is idle (finished but tmux still alive)
        local pane_output
        pane_output=$(tmux capture-pane -t "$p_session" -p 2>/dev/null || true)
        # Detect: [SGT] exit marker OR Claude Code idle at ❯ with no recent activity
        local is_idle=false
        if echo "$pane_output" | grep -qE '^\[SGT\] polecat exited'; then
          is_idle=true
        elif echo "$pane_output" | grep -qP '\x{276f}'; then
          # Check if a PR was already opened (work is done)
          local has_pr
          has_pr=$(gh pr list --repo "$p_repo" --head "$p_branch" --json number --jq '.[0].number' 2>/dev/null || true)
          if [[ -n "$has_pr" ]]; then
            is_idle=true
          fi
        fi
        if $is_idle; then
          echo "[witness/$rig] $pname Claude Code finished (idle/exited) — treating as complete"
          log_event "WITNESS_IDLE_DETECTED $pname"
          # Kill the tmux session so the dead-session handler below picks it up
          tmux kill-session -t "$p_session" 2>/dev/null || true
          alive=false
        fi

        if $alive; then
          # Polecat is running — check if it's been running too long (>30 min)
          local created_ts
          created_ts=$(date -d "$p_created" +%s 2>/dev/null || echo "0")
          local age=$(( now - created_ts ))
          if [[ "$age" -gt 1800 ]]; then
            echo "[witness/$rig] $pname has been running for $((age/60))m — still alive"
            log_event "WITNESS_LONG_RUNNING $pname age=${age}s"
          fi
        fi
      fi

      if ! $alive; then
        # Polecat session is dead — check what happened
        local pr_state pr_number
        pr_state=$(gh pr list --repo "$p_repo" --head "$p_branch" --json state,number --jq '.[0].state' 2>/dev/null || true)
        pr_number=$(gh pr list --repo "$p_repo" --head "$p_branch" --json number --jq '.[0].number' 2>/dev/null || true)

        if [[ "$pr_state" == "OPEN" ]]; then
          # PR is open — send to merge queue for refinery (refinery reviews + merges)
          echo "[witness/$rig] $pname completed — PR #$pr_number OPEN, queuing for refinery"
          log_event "WITNESS_PR_READY $pname pr=#$pr_number"

          local pr_head_sha
          pr_head_sha="$(_pr_head_sha "$p_repo" "$pr_number")"
          if _merge_queue_enqueue_polecat "$rig" "$p_repo" "$p_branch" "$p_issue" "$pr_number" "$pr_head_sha" "$p_auto_merge" "${BACKEND:-$(_ai_backend_default)}" "$pname" "witness-pr-ready"; then
            _wake_refinery "$rig" "pr-ready:$pname:#$pr_number"
          fi

          # Clean up polecat worktree + state
          if [[ -d "$p_worktree" ]]; then
            local rpath
            rpath="$(rig_path "$rig")"
            git -C "$rpath" worktree remove --force "$p_worktree" 2>/dev/null || rm -rf "$p_worktree"
          fi
          rm -f "$f"

        elif [[ "$pr_state" == "MERGED" ]]; then
          # Already merged — just clean up
          echo "[witness/$rig] $pname already merged — cleaning up"
          log_event "WITNESS_MERGED $pname"
          if [[ -d "$p_worktree" ]]; then
            local rpath
            rpath="$(rig_path "$rig")"
            git -C "$rpath" worktree remove --force "$p_worktree" 2>/dev/null || rm -rf "$p_worktree"
          fi
          git -C "$(rig_path "$rig")" push origin --delete "$p_branch" 2>/dev/null || true
          rm -f "$f"

        else
          # Dead with no PR — stalled/zombie
          echo "[witness/$rig] $pname is STALLED (dead, no PR)"
          log_event "WITNESS_STALLED $pname issue=#$p_issue"
          _wake_refinery "$rig" "stalled:$pname:#$p_issue"

          # Comment on the issue about the stall
          gh issue comment "$p_issue" --repo "$p_repo" \
            --body "[sgt-witness] Polecat \`$pname\` stalled — session died without opening a PR. Cleaning up and re-slinging." 2>/dev/null || true

          # Clean up the dead polecat
          if [[ -d "$p_worktree" ]]; then
            local rpath
            rpath="$(rig_path "$rig")"
            git -C "$rpath" worktree remove --force "$p_worktree" 2>/dev/null || rm -rf "$p_worktree"
          fi
          git -C "$(rig_path "$rig")" push origin --delete "$p_branch" 2>/dev/null || true
          rm -f "$f"

          # Re-sling: get the issue title and re-dispatch
          local issue_title
          issue_title=$(gh issue view "$p_issue" --repo "$p_repo" --json title --jq '.title' 2>/dev/null || true)
          if [[ -n "$issue_title" ]]; then
            echo "[witness/$rig] re-slinging issue #$p_issue: $issue_title"
            log_event "WITNESS_RESLING $pname issue=#$p_issue"

            # Re-sling with a new polecat (reuse existing issue — don't create a new one)
            _resling_existing_issue "$rig" "$p_issue" "$issue_title" "$p_repo" "$(_ai_backend_default)" "" "witness-stalled" "witness-stalled:$pname:#$p_issue"
          fi
        fi
      fi
    done

    # ── Orphaned PR scan ──
    # Catch PRs on sgt/* branches that have no polecat state file
    # (e.g., polecat completed and was swept before witness could queue it)
    local orphan_prs
    orphan_prs=$(gh pr list --repo "$repo" --json number,headRefName,state \
      --jq '.[] | select(.headRefName | startswith("sgt/")) | "\(.number) \(.headRefName)"' 2>/dev/null || true)

    if [[ -n "$orphan_prs" ]]; then
      while IFS=' ' read -r pr_num pr_branch; do
        [[ -n "$pr_num" ]] || continue

        # Check if any polecat state file references this branch
        local tracked=false
        for pf in "$SGT_POLECATS"/${rig}-*; do
          [[ -f "$pf" ]] || continue
          if grep -q "BRANCH=$pr_branch" "$pf" 2>/dev/null; then
            tracked=true
            break
          fi
        done

        # Check if already in merge queue
        if [[ "$tracked" == "false" ]]; then
          for mqf in "$SGT_CONFIG/merge-queue"/${rig}-*; do
            [[ -f "$mqf" ]] || continue
            if grep -q "BRANCH=$pr_branch" "$mqf" 2>/dev/null; then
              tracked=true
              break
            fi
          done
        fi

        if [[ "$tracked" == "false" ]]; then
          local orphan_pname="${pr_branch#sgt/}"
          local orphan_issue
          orphan_issue=$(gh pr view "$pr_num" --repo "$repo" --json body --jq '.body' 2>/dev/null | grep -oP 'Closes #\K[0-9]+' || true)

          # Security gate: only queue if linked issue has sgt-authorized label
          if [[ -z "$orphan_issue" || "$orphan_issue" == "0" ]]; then
            echo "[witness/$rig] orphaned PR #$pr_num has no linked issue — skipping (unauthorized)"
            log_event "WITNESS_ORPHAN_SKIP_NO_ISSUE pr=#$pr_num branch=$pr_branch"
            continue
          fi

          if ! _has_sgt_authorized "$repo" "$orphan_issue"; then
            echo "[witness/$rig] orphaned PR #$pr_num linked issue #$orphan_issue lacks sgt-authorized label — skipping"
            log_event "WITNESS_ORPHAN_SKIP_UNAUTHORIZED pr=#$pr_num issue=#$orphan_issue"
            continue
          fi

          echo "[witness/$rig] orphaned PR #$pr_num on branch $pr_branch — queuing for refinery"
          log_event "WITNESS_ORPHAN_PR pr=#$pr_num branch=$pr_branch"

          local orphan_head_sha
          orphan_head_sha="$(_pr_head_sha "$repo" "$pr_num")"
          if _merge_queue_enqueue_polecat "$rig" "$repo" "$pr_branch" "${orphan_issue:-0}" "$pr_num" "$orphan_head_sha" "true" "$(_ai_backend_default)" "$orphan_pname" "witness-orphan-pr"; then
            _wake_refinery "$rig" "orphan-pr:$orphan_pname:#$pr_num"
          fi
        fi
      done <<< "$orphan_prs"
    fi

    sleep 30
  done
}

# Re-sling an existing issue (don't create a new one)
_resling_existing_issue() {
  local rig="$1" issue_number="$2" task="$3" repo="$4"
  local backend="${5:-$(_ai_backend_default)}"
  local source_pr="${6:-}"
  local source_event="${7:-unknown}"
  local source_event_key="${8:-$source_event}"
  source_event_key="$(_wake_trigger_key "$source_event_key")"
  [[ -n "$source_event_key" ]] || source_event_key="${source_event:-unknown}"

  local stale_reason=""
  if ! stale_reason=$(_resling_pre_dispatch_revalidate "$repo" "$issue_number" "$source_pr"); then
    echo "[resling] stale event ($source_event) for issue #$issue_number — skipping: $stale_reason"
    log_event "RESLING_SKIP_STALE issue=#$issue_number rig=$rig source_event=$source_event source_event_key=\"$(_escape_quotes "$source_event_key")\" source_pr=${source_pr:-none} skip_reason=\"$(_escape_quotes "$stale_reason")\""
    return 1
  fi

  # Security gate: verify issue has sgt-authorized label
  if ! _has_sgt_authorized "$repo" "$issue_number"; then
    echo "[resling] issue #$issue_number lacks sgt-authorized label — skipping"
    log_event "RESLING_SKIP_UNAUTHORIZED issue=#$issue_number rig=$rig source_event=$source_event source_event_key=\"$(_escape_quotes "$source_event_key")\" skip_reason=\"issue lacks sgt-authorized\""
    return 1
  fi

  local rpath pname branch session_name
  rpath="$(rig_path "$rig")"
  pname="$(polecat_name "$rig")"
  branch="sgt/${pname}"
  session_name="sgt-${pname}"

  git -C "$rpath" fetch origin 2>/dev/null || true
  local default_branch
  default_branch=$(git -C "$rpath" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's|refs/remotes/origin/||' || echo "main")

  local worktree="$SGT_ROOT/polecats/$pname"
  mkdir -p "$SGT_ROOT/polecats"
  git -C "$rpath" worktree add -b "$branch" "$worktree" "origin/$default_branch" 2>/dev/null \
    || git -C "$rpath" worktree add -b "$branch" "$worktree" "$default_branch"

  if [[ -f "$rpath/CLAUDE.md" ]]; then
    cp "$rpath/CLAUDE.md" "$worktree/CLAUDE.md"
  fi
  _write_polecat_claude_md "$worktree" "$issue_number" "$task" "$repo" "$pname" "$branch" "$default_branch" "false"

  local final_gate_reason=""
  if ! final_gate_reason=$(_resling_pre_dispatch_revalidate "$repo" "$issue_number" "$source_pr"); then
    echo "[resling] dispatch-instant gate ($source_event) for issue #$issue_number — skipping: $final_gate_reason"
    log_event "RESLING_SKIP_FINAL_GATE issue=#$issue_number rig=$rig source_event=$source_event source_event_key=\"$(_escape_quotes "$source_event_key")\" source_pr=${source_pr:-none} skip_reason=\"$(_escape_quotes "$final_gate_reason")\""
    git -C "$rpath" worktree remove --force "$worktree" 2>/dev/null || rm -rf "$worktree"
    git -C "$rpath" branch -D "$branch" 2>/dev/null || true
    return 1
  fi

  cat > "$SGT_POLECATS/$pname" <<PSTATE
RIG=$rig
REPO=$repo
ISSUE=$issue_number
ISSUE_URL=https://github.com/${repo#https://github.com/}/issues/$issue_number
BRANCH=$branch
WORKTREE=$worktree
SESSION=$session_name
DEFAULT_BRANCH=$default_branch
AUTO_MERGE=false
BACKEND=$backend
CREATED=$(date -Iseconds)
STATUS=running
PSTATE

  tmux new-session -d -s "$session_name" -c "$worktree" \
    "$( _ai_cmd "$backend" "Read the CLAUDE.md in this directory. Your task is described in GitHub issue #${issue_number}. The issue title is: ${task}. Work on branch ${branch}. When done, commit your changes, push the branch, and open a PR that closes #${issue_number}." ); echo '[SGT] polecat exited'; sgt _wake-refinery '${rig}' 'polecat-done:${pname}:#${issue_number}' 2>/dev/null"

  log_event "RESLING $pname rig=$rig issue=#$issue_number branch=$branch"
}

cmd_witness_start() {
  local rig="${1:-}"
  [[ -n "$rig" ]] || die "usage: sgt witness start <rig>"
  ensure_init
  ensure_rig "$rig"

  local session="sgt-witness-${rig}"
  if tmux has-session -t "$session" 2>/dev/null; then
    info "witness/$rig already running"
    return
  fi

  tmux new-session -d -s "$session" \
    "SGT_ROOT='$SGT_ROOT' sgt _witness '$rig'"

  log_event "WITNESS_SPAWN rig=$rig"
  info "witness/$rig started (session: $session)"
}

cmd_witness_stop() {
  local rig="${1:-}"
  [[ -n "$rig" ]] || die "usage: sgt witness stop <rig>"

  local session="sgt-witness-${rig}"
  if tmux has-session -t "$session" 2>/dev/null; then
    tmux kill-session -t "$session"
    log_event "WITNESS_STOP rig=$rig"
    info "witness/$rig stopped"
  else
    info "witness/$rig not running"
  fi
}

# ─── Refinery (per-rig review + merge processor) ─────────────────────
#
# The Refinery is the quality gate for all worker output:
# - Workers (polecats/dogs) notify the refinery when done
# - Refinery reviews PR diffs (polecats) or issue comments (dogs) via AI
# - On PASS: merges PR / closes issue, notifies mayor
# - On REJECT: closes PR / reopens issue, dispatches second iteration with feedback
# - No mayor involvement on rejections — refinery handles rework autonomously

# AI review: check PR diff against issue spec
_refinery_review_pr() {
  local repo="$1" pr="$2" issue="$3" rig="$4" backend="$5"
  local owner_repo pr_url issue_url
  owner_repo="$(_repo_owner_repo "$repo")"
  pr_url="$(_repo_pr_url "$repo" "$pr")"
  issue_url="$(_repo_issue_url "$repo" "$issue")"

  echo "[refinery/$rig] reviewing PR #$pr..."

  local diff
  diff=$(gh pr diff "$pr" --repo "$repo" 2>/dev/null || true)
  if [[ -z "$diff" ]]; then
    echo "[refinery/$rig] PR #$pr — no diff, skipping review"
    return 0  # treat as pass (merged/closed already)
  fi

  local issue_title="" issue_body=""
  if [[ "$issue" != "0" && -n "$issue" ]]; then
    issue_title=$(gh issue view "$issue" --repo "$repo" --json title --jq '.title' 2>/dev/null || true)
    issue_body=$(gh issue view "$issue" --repo "$repo" --json body --jq '.body' 2>/dev/null || true)
  fi

  local pr_title pr_body pr_title_field
  pr_title=$(gh pr view "$pr" --repo "$repo" --json title --jq '.title' 2>/dev/null || true)
  pr_body=$(gh pr view "$pr" --repo "$repo" --json body --jq '.body' 2>/dev/null || true)
  pr_title_field="$(_escape_quotes "$pr_title")"

  # Truncate diff if too large
  local diff_truncated="$diff"
  local diff_lines
  diff_lines=$(echo "$diff" | wc -l)
  if [[ "$diff_lines" -gt 500 ]]; then
    diff_truncated="$(echo "$diff" | head -500)"
    diff_truncated+=$'\n\n[... truncated, '"$diff_lines"' total lines ...]'
  fi

  local review_dir="$SGT_CONFIG/refinery-review"
  mkdir -p "$review_dir"

  cat > "$review_dir/review-prompt.md" <<REVIEWMD
# PR Review

Review this PR for completeness. Does it implement what the issue requested?

## Issue #$issue
**Title:** $issue_title
**Description:** $issue_body

## PR #$pr
**Title:** $pr_title
**Body:** $pr_body

## Diff
\`\`\`diff
$diff_truncated
\`\`\`

## Verdict

End with exactly one of:
- VERDICT: APPROVE — if complete and functional
- VERDICT: REJECT — if incomplete, stub, or doesn't match spec

If rejecting, explain what's missing in 2-3 sentences before the verdict.
REVIEWMD

  local review_output
  review_output=$(timeout 180 bash -c "_ai_promptfile '$backend' '$review_dir' '$review_dir/review-prompt.md'" 2>/dev/null || true)

  if echo "$review_output" | grep -q "VERDICT: APPROVE"; then
    echo "[refinery/$rig] PR #$pr APPROVED"
    log_event "REFINERY_REVIEW_APPROVED pr=#$pr"
    _notify_openclaw "[SGT Refinery] review approved rig=$rig repo=$owner_repo pr=#$pr title=\"$pr_title_field\" issue=#$issue pr_url=$pr_url issue_url=$issue_url"
    gh pr comment "$pr" --repo "$repo" \
      --body "[sgt-refinery] **APPROVED** — reviewed and cleared for merge." 2>/dev/null || true
    return 0
  elif echo "$review_output" | grep -q "VERDICT: REJECT"; then
    local reject_reason
    reject_reason=$(echo "$review_output" | grep -B5 "VERDICT: REJECT" | grep -v "VERDICT:" | tail -3)
    echo "[refinery/$rig] PR #$pr REJECTED: $reject_reason"
    log_event "REFINERY_REVIEW_REJECTED pr=#$pr reason=$reject_reason"
    local reject_summary
    reject_summary=$(echo "$reject_reason" | tr '\n' ' ' | sed -E 's/[[:space:]]+/ /g' | cut -c1-160)
    _notify_openclaw "[SGT Refinery] review rejected rig=$rig pr=#$pr issue=#$issue reason=$reject_summary"

    gh pr comment "$pr" --repo "$repo" \
      --body "[sgt-refinery] **REJECTED** — Implementation incomplete.

**Feedback:** $reject_reason

Closing PR and dispatching rework." 2>/dev/null || true
    # Return 1 = rejected, caller handles rework
    REFINERY_REJECT_REASON="$reject_reason"
    return 1
  else
    echo "[refinery/$rig] PR #$pr — review inconclusive, marking REVIEW_UNCLEAR"
    log_event "REFINERY_REVIEW_UNCLEAR pr=#$pr"
    return 2
  fi
}

# AI review: check dog output quality against issue spec
_refinery_review_dog() {
  local repo="$1" issue="$2" rig="$3" dname="$4" backend="$5"

  echo "[refinery/$rig] reviewing dog $dname output on issue #$issue..."

  local issue_title issue_body
  issue_title=$(gh issue view "$issue" --repo "$repo" --json title --jq '.title' 2>/dev/null || true)
  issue_body=$(gh issue view "$issue" --repo "$repo" --json body --jq '.body' 2>/dev/null || true)

  # Get the dog's posted comments
  local comments
  comments=$(gh issue view "$issue" --repo "$repo" --json comments \
    --jq '[.comments[] | select(.author.login != "github-actions[bot]")] | .[-3:] | .[].body' 2>/dev/null || true)

  if [[ -z "$comments" ]]; then
    echo "[refinery/$rig] dog $dname — no comments posted, treating as incomplete"
    REFINERY_REJECT_REASON="Dog posted no findings to the issue."
    return 1
  fi

  # Truncate if too large
  local comments_truncated="$comments"
  local comment_lines
  comment_lines=$(echo "$comments" | wc -l)
  if [[ "$comment_lines" -gt 300 ]]; then
    comments_truncated="$(echo "$comments" | head -300)"
    comments_truncated+=$'\n\n[... truncated ...]'
  fi

  local review_dir="$SGT_CONFIG/refinery-review"
  mkdir -p "$review_dir"

  cat > "$review_dir/dog-review-prompt.md" <<REVIEWMD
# Dog Output Review

Review whether this research/analysis task was completed thoroughly.

## Task (Issue #$issue)
**Title:** $issue_title
**Description:** $issue_body

## Dog Output (issue comments)
$comments_truncated

## Verdict

End with exactly one of:
- VERDICT: APPROVE — if research is thorough and addresses the task
- VERDICT: REJECT — if output is thin, off-topic, or missing key deliverables

If rejecting, explain what's missing in 2-3 sentences before the verdict.
REVIEWMD

  local review_output
  review_output=$(timeout 180 bash -c "_ai_promptfile '$backend' '$review_dir' '$review_dir/dog-review-prompt.md'" 2>/dev/null || true)

  if echo "$review_output" | grep -q "VERDICT: APPROVE"; then
    echo "[refinery/$rig] dog $dname APPROVED"
    log_event "REFINERY_DOG_APPROVED dog=$dname issue=#$issue"
    gh issue comment "$issue" --repo "$repo" \
      --body "[sgt-refinery] **APPROVED** — research output reviewed and accepted." 2>/dev/null || true
    return 0
  elif echo "$review_output" | grep -q "VERDICT: REJECT"; then
    local reject_reason
    reject_reason=$(echo "$review_output" | grep -B5 "VERDICT: REJECT" | grep -v "VERDICT:" | tail -3)
    echo "[refinery/$rig] dog $dname REJECTED: $reject_reason"
    log_event "REFINERY_DOG_REJECTED dog=$dname issue=#$issue reason=$reject_reason"
    gh issue comment "$issue" --repo "$repo" \
      --body "[sgt-refinery] **REJECTED** — Research output insufficient.

**Feedback:** $reject_reason

Dispatching second iteration." 2>/dev/null || true
    REFINERY_REJECT_REASON="$reject_reason"
    return 1
  else
    echo "[refinery/$rig] dog $dname — review inconclusive, treating as APPROVE"
    log_event "REFINERY_DOG_REVIEW_UNCLEAR dog=$dname issue=#$issue"
    return 0
  fi
}

_refinery_loop() {
  local rig="$1"
  local repo
  repo="$(rig_repo "$rig")"

  log_event "REFINERY_START rig=$rig"

  # Set up FIFO for event-driven wake
  local fifo="$SGT_CONFIG/refinery-${rig}.fifo"
  [[ -p "$fifo" ]] || mkfifo "$fifo"
  exec 4<>"$fifo"
  echo "[refinery/$rig] started — event-driven (fallback every 30s)"

  while true; do
    # Block on FIFO with timeout — wakes on event OR periodic scan
    local wake_reason=""
    read -t 30 -u 4 wake_reason 2>/dev/null || true
    if [[ -n "$wake_reason" ]]; then
      echo "[refinery/$rig] woken: $wake_reason"
      # Drain queued events
      local extra=""
      while read -t 0.1 -u 4 extra 2>/dev/null; do :; done
    fi

    local merge_dir="$SGT_CONFIG/merge-queue"
    mkdir -p "$merge_dir"

    # ── Process PR queue (polecats) ──
    for f in "$merge_dir"/${rig}-*; do
      [[ -f "$f" ]] || continue
      local mqname
      mqname="$(basename "$f")"

      local mq_pr="" mq_repo="" mq_branch="" mq_issue="" mq_polecat="" mq_auto_merge="" mq_type="" mq_backend="" mq_head_sha=""
      local mq_review_state="" mq_review_updated_at="" mq_review_unclear_since=""
      eval "$(grep -E '^(PR|REPO|BRANCH|ISSUE|POLECAT|AUTO_MERGE|TYPE|BACKEND|HEAD_SHA|REVIEW_STATE|REVIEW_UPDATED_AT|REVIEW_UNCLEAR_SINCE)=' "$f")"
      mq_pr="${PR:-}"
      mq_repo="${REPO:-$repo}"
      mq_branch="${BRANCH:-}"
      mq_issue="${ISSUE:-0}"
      mq_polecat="${POLECAT:-$mqname}"
      mq_auto_merge="${AUTO_MERGE:-false}"
      mq_type="${TYPE:-polecat}"
      mq_backend="${BACKEND:-$(_ai_backend_default)}"
      mq_head_sha="${HEAD_SHA:-}"
      mq_review_state="${REVIEW_STATE:-REVIEW_PENDING}"
      mq_review_updated_at="${REVIEW_UPDATED_AT:-}"
      mq_review_unclear_since="${REVIEW_UNCLEAR_SINCE:-}"

      echo "[refinery/$rig] processing $mq_type: PR #$mq_pr ($mq_branch)"
      local mq_owner_repo mq_pr_title mq_pr_title_field mq_pr_url mq_issue_url mq_wake_title
      mq_owner_repo="$(_repo_owner_repo "$mq_repo")"
      mq_pr_title=$(gh pr view "$mq_pr" --repo "$mq_repo" --json title --jq '.title' 2>/dev/null || true)
      mq_pr_title_field="$(_escape_quotes "$mq_pr_title")"
      mq_pr_url="$(_repo_pr_url "$mq_repo" "$mq_pr")"
      mq_issue_url="$(_repo_issue_url "$mq_repo" "$mq_issue")"
      mq_wake_title="$(_escape_wake_value "$mq_pr_title")"

      # Security gate: verify linked issue has sgt-authorized label
      if [[ -n "$mq_issue" && "$mq_issue" != "0" ]]; then
        if ! _has_sgt_authorized "$mq_repo" "$mq_issue"; then
          echo "[refinery/$rig] PR #$mq_pr linked issue #$mq_issue lacks sgt-authorized — skipping"
          log_event "REFINERY_SKIP_UNAUTHORIZED pr=#$mq_pr issue=#$mq_issue"
          rm -f "$f"
          continue
        fi
      else
        echo "[refinery/$rig] PR #$mq_pr has no linked issue — skipping (unauthorized)"
        log_event "REFINERY_SKIP_NO_ISSUE pr=#$mq_pr"
        rm -f "$f"
        continue
      fi

      # Check PR state
      local pr_state
      pr_state=$(gh pr view "$mq_pr" --repo "$mq_repo" --json state --jq '.state' 2>/dev/null || true)

      if [[ "$pr_state" == "MERGED" ]]; then
        echo "[refinery/$rig] PR #$mq_pr already merged — cleaning up"
        git -C "$(rig_path "$rig")" push origin --delete "$mq_branch" 2>/dev/null || true
        rm -f "$f"
        log_event "REFINERY_ALREADY_MERGED pr=#$mq_pr"
        continue
      fi

      if [[ "$pr_state" == "CLOSED" ]]; then
        echo "[refinery/$rig] PR #$mq_pr was closed — removing from queue"
        rm -f "$f"
        log_event "REFINERY_CLOSED pr=#$mq_pr"
        continue
      fi

      if [[ "$pr_state" != "OPEN" ]]; then
        echo "[refinery/$rig] PR #$mq_pr state unknown: $pr_state — skipping"
        continue
      fi

      # Check CI
      local check_status
      check_status=$(gh pr checks "$mq_pr" --repo "$mq_repo" 2>&1 || true)
      if echo "$check_status" | grep -qiE "fail|error"; then
        echo "[refinery/$rig] PR #$mq_pr — CI failing, waiting..."
        continue
      fi

      if [[ -z "$mq_head_sha" ]]; then
        mq_head_sha="$(_pr_head_sha "$mq_repo" "$mq_pr")"
        if [[ -n "$mq_head_sha" ]]; then
          _merge_queue_set_head_sha "$f" "$mq_head_sha" || true
        fi
      fi

      local claimed_attempt_file=""
      if ! _refinery_merge_attempt_claim "$mq_repo" "$mq_pr" "$mq_head_sha" "$mqname"; then
        local duplicate_key duplicate_reason duplicate_reason_code
        duplicate_key="${_REFINERY_MERGE_ATTEMPT_KEY:-unknown}"
        duplicate_reason_code="duplicate-merge-attempt-key"
        duplicate_reason="duplicate merge-attempt key (repo+pr+head) already processed"
        echo "[refinery/$rig] PR #$mq_pr duplicate merge skipped — reason_code=$duplicate_reason_code reason=\"$duplicate_reason\" key=$duplicate_key"
        log_event "REFINERY_DUPLICATE_SKIP pr=#$mq_pr issue=#$mq_issue reason_code=$duplicate_reason_code reason=\"$(_escape_quotes "$duplicate_reason")\" key=\"$(_escape_quotes "$duplicate_key")\" queue=$mqname"
        rm -f "$f"
        continue
      fi
      claimed_attempt_file="${_REFINERY_MERGE_ATTEMPT_FILE:-}"

      # Check mergeability
      local pr_mergeable
      pr_mergeable=$(gh pr view "$mq_pr" --repo "$mq_repo" --json mergeable --jq '.mergeable' 2>/dev/null || true)
      if [[ "$pr_mergeable" == "CONFLICTING" ]]; then
        echo "[refinery/$rig] PR #$mq_pr has merge conflicts — requesting rework"
        log_event "REFINERY_CONFLICT pr=#$mq_pr"
        gh pr comment "$mq_pr" --repo "$mq_repo" \
          --body "[sgt-refinery] Merge conflict detected. Closing and re-dispatching." 2>/dev/null || true
        gh pr close "$mq_pr" --repo "$mq_repo" 2>/dev/null || true
        rm -f "$f"
        # Re-sling
        if [[ "$mq_issue" != "0" && -n "$mq_issue" ]]; then
          gh issue reopen "$mq_issue" --repo "$mq_repo" 2>/dev/null || true
          gh issue comment "$mq_issue" --repo "$mq_repo" \
            --body "[sgt-refinery] Merge conflict on PR #$mq_pr. Re-dispatching." 2>/dev/null || true
          local issue_title_resling
          issue_title_resling=$(gh issue view "$mq_issue" --repo "$mq_repo" --json title --jq '.title' 2>/dev/null || true)
          [[ -n "$issue_title_resling" ]] && _resling_existing_issue "$rig" "$mq_issue" "$issue_title_resling" "$mq_repo" "$mq_backend" "$mq_pr" "refinery-conflict" "refinery-conflict:$mqname:#$mq_pr"
        fi
        continue
      fi

      # === AI REVIEW ===
      REFINERY_REJECT_REASON=""
      local review_rc
      set +e
      _refinery_review_pr "$mq_repo" "$mq_pr" "$mq_issue" "$rig" "$mq_backend"
      review_rc=$?
      set -e
      if [[ "$review_rc" -eq 0 ]]; then
        _merge_queue_mark_review_state "$f" "REVIEW_APPROVED" || true
        # Revalidate immediately before merge to prevent stale queue merges.
        local live_head_sha premerge_reason=""
        if ! live_head_sha=$(_refinery_revalidate_pr_open_head "$mq_repo" "$mq_pr" "$mq_head_sha" "$f"); then
          premerge_reason="$live_head_sha"
        fi
        if [[ -n "$premerge_reason" ]]; then
          echo "[refinery/$rig] PR #$mq_pr pre-merge revalidation drift — skipping ($premerge_reason)"
          log_event "REFINERY_PREMERGE_SKIP pr=#$mq_pr reason=\"$(_escape_quotes "$premerge_reason")\""
          _refinery_merge_attempt_release "$claimed_attempt_file"
          continue
        fi

        # APPROVED — merge (bounded retry for transient errors).
        local merge_attempt max_attempts merge_result merge_error_class merge_success=false
        local merge_error_transient=false merge_skip_reason="" merge_expected_head_sha
        local merge_auto_retry_attempted=false merge_auto_retry_reason=""
        max_attempts="$(_refinery_merge_retry_max_attempts)"
        merge_expected_head_sha="$live_head_sha"
        merge_attempt=1
        merge_error_class="non-transient"
        echo "[refinery/$rig] merging PR #$mq_pr (max attempts=$max_attempts)..."
        while (( merge_attempt <= max_attempts )); do
          if merge_result=$(gh pr merge "$mq_pr" --repo "$mq_repo" --squash --delete-branch 2>&1); then
            merge_success=true
            break
          fi

          if [[ "$merge_auto_retry_attempted" != "true" ]] && merge_auto_retry_reason="$(_refinery_merge_error_requires_auto_retry_reason "$merge_result")"; then
            local auto_retry_live_head
            merge_auto_retry_attempted=true
            if ! auto_retry_live_head=$(_refinery_revalidate_pr_open_head "$mq_repo" "$mq_pr" "$merge_expected_head_sha" "$f"); then
              merge_skip_reason="$auto_retry_live_head"
              echo "[refinery/$rig] PR #$mq_pr auto-merge retry skipped — $merge_skip_reason"
              log_event "REFINERY_MERGE_RETRY_AUTO repo=$mq_owner_repo pr=#$mq_pr reason=$merge_auto_retry_reason outcome=skipped final_reason=\"$(_escape_quotes "$merge_skip_reason")\""
              break
            fi
            merge_expected_head_sha="$auto_retry_live_head"

            echo "[refinery/$rig] PR #$mq_pr merge failed due to branch policy requiring auto-merge — retrying once with --auto"
            if merge_result=$(gh pr merge "$mq_pr" --repo "$mq_repo" --squash --delete-branch --auto 2>&1); then
              merge_success=true
              log_event "REFINERY_MERGE_RETRY_AUTO repo=$mq_owner_repo pr=#$mq_pr reason=$merge_auto_retry_reason outcome=success"
              break
            fi

            merge_error_class="$(_refinery_merge_error_class "$merge_result")"
            if _refinery_merge_error_is_transient "$merge_error_class"; then
              merge_error_transient=true
            else
              merge_error_transient=false
            fi
            log_event "REFINERY_MERGE_RETRY_AUTO repo=$mq_owner_repo pr=#$mq_pr reason=$merge_auto_retry_reason outcome=failed final_class=$merge_error_class final_error=\"$(_escape_quotes "$merge_result")\""
            break
          fi

          merge_error_class="$(_refinery_merge_error_class "$merge_result")"
          if _refinery_merge_error_is_transient "$merge_error_class"; then
            merge_error_transient=true
          else
            merge_error_transient=false
          fi
          if [[ "$merge_error_transient" != "true" || "$merge_attempt" -ge "$max_attempts" ]]; then
            break
          fi

          local retry_delay_s retry_live_head
          if ! retry_live_head=$(_refinery_revalidate_pr_open_head "$mq_repo" "$mq_pr" "$merge_expected_head_sha" "$f"); then
            merge_skip_reason="$retry_live_head"
            echo "[refinery/$rig] PR #$mq_pr merge retry skipped — $merge_skip_reason"
            log_event "REFINERY_MERGE_RETRY_SKIP pr=#$mq_pr attempt=$merge_attempt/$max_attempts reason=\"$(_escape_quotes "$merge_skip_reason")\""
            break
          fi
          merge_expected_head_sha="$retry_live_head"

          retry_delay_s="$(_refinery_merge_retry_delay_secs "$merge_attempt")"
          echo "[refinery/$rig] PR #$mq_pr merge transient failure class=$merge_error_class attempt=$merge_attempt/$max_attempts — retrying in ${retry_delay_s}s"
          log_event "REFINERY_MERGE_RETRY pr=#$mq_pr attempt=$merge_attempt/$max_attempts class=$merge_error_class delay_s=$retry_delay_s"
          sleep "$retry_delay_s"
          merge_attempt=$((merge_attempt + 1))
        done

        if [[ "$merge_skip_reason" != "" ]]; then
          continue
        fi

        if [[ "$merge_success" == "true" ]]; then
          echo "[refinery/$rig] PR #$mq_pr merged successfully"
          log_event "REFINERY_MERGED pr=#$mq_pr issue=#$mq_issue"
          _notify_openclaw "[SGT Refinery] merged rig=$rig repo=$mq_owner_repo pr=#$mq_pr title=\"$mq_pr_title_field\" issue=#$mq_issue pr_url=$mq_pr_url issue_url=$mq_issue_url"
          _wake_mayor "merged:pr#$mq_pr:#$mq_issue:$rig|repo=$mq_owner_repo|title=$mq_wake_title|pr_url=$mq_pr_url|issue_url=$mq_issue_url|merged_head=$(_escape_wake_value "$merge_expected_head_sha")"
          rm -f "$f"
        else
          echo "[refinery/$rig] merge failed: $merge_result"
          log_event "REFINERY_MERGE_FAILED pr=#$mq_pr attempt=$merge_attempt/$max_attempts class=$merge_error_class transient=$merge_error_transient error=\"$(_escape_quotes "$merge_result")\""
          _notify_openclaw "[SGT Refinery] merge failed rig=$rig repo=$mq_owner_repo pr=#$mq_pr issue=#$mq_issue attempts=$merge_attempt/$max_attempts error_class=$merge_error_class transient=$merge_error_transient pr_url=$mq_pr_url issue_url=$mq_issue_url"
          gh pr comment "$mq_pr" --repo "$mq_repo" \
            --body "[sgt-refinery] Auto-merge failed after ${merge_attempt}/${max_attempts} attempt(s) (class=${merge_error_class}, transient=${merge_error_transient}): \`$merge_result\`" 2>/dev/null || true
        fi
      elif [[ "$review_rc" -eq 2 ]]; then
        local unclear_since unclear_age now_epoch
        _merge_queue_mark_review_state "$f" "REVIEW_UNCLEAR" || true
        unclear_since=$(grep -E '^REVIEW_UNCLEAR_SINCE=' "$f" 2>/dev/null | tail -1 | cut -d= -f2- || true)
        now_epoch="$(date +%s)"
        unclear_age=0
        if [[ "$unclear_since" =~ ^[0-9]+$ ]]; then
          unclear_age=$((now_epoch - unclear_since))
          if [[ "$unclear_age" -lt 0 ]]; then
            unclear_age=0
          fi
        fi
        echo "[refinery/$rig] PR #$mq_pr held in REVIEW_UNCLEAR (age=${unclear_age}s)"
        log_event "REFINERY_REVIEW_UNCLEAR_PENDING pr=#$mq_pr issue=#$mq_issue age=${unclear_age}s"
        _refinery_merge_attempt_release "$claimed_attempt_file"
        continue
      else
        _merge_queue_mark_review_state "$f" "REVIEW_REJECTED" || true
        # REJECTED — close PR, re-dispatch with feedback
        echo "[refinery/$rig] PR #$mq_pr rejected — dispatching rework"
        gh pr close "$mq_pr" --repo "$mq_repo" 2>/dev/null || true
        rm -f "$f"

        if [[ "$mq_issue" != "0" && -n "$mq_issue" ]]; then
          gh issue reopen "$mq_issue" --repo "$mq_repo" 2>/dev/null || true
          gh issue comment "$mq_issue" --repo "$mq_repo" \
            --body "[sgt-refinery] Previous attempt rejected. Feedback:

$REFINERY_REJECT_REASON

Please address the feedback in the next iteration." 2>/dev/null || true
          local issue_title_resling
          issue_title_resling=$(gh issue view "$mq_issue" --repo "$mq_repo" --json title --jq '.title' 2>/dev/null || true)
          if [[ -n "$issue_title_resling" ]]; then
            echo "[refinery/$rig] re-slinging issue #$mq_issue"
            _resling_existing_issue "$rig" "$mq_issue" "$issue_title_resling" "$mq_repo" "$mq_backend" "$mq_pr" "refinery-reject" "refinery-reject:$mqname:#$mq_pr"
          fi
        fi
      fi
    done

    # ── Process dog queue (check for completed dogs) ──
    if [[ -d "$SGT_CONFIG/dogs" ]]; then
      for df in "$SGT_CONFIG/dogs"/*; do
        [[ -f "$df" ]] || continue
        local dname
        dname="$(basename "$df")"

        local d_session="" d_repo="" d_issue="" d_rig=""
        eval "$(grep -E '^(SESSION|REPO|ISSUE|RIG|BACKEND)=' "$df")"
        d_session="${SESSION:-}"
        d_repo="${REPO:-$repo}"
        d_issue="${ISSUE:-0}"
        d_rig="${RIG:-$rig}"
        local d_backend="${BACKEND:-$(_ai_backend_default)}"
        local d_owner_repo d_issue_title d_issue_url d_wake_title
        d_owner_repo="$(_repo_owner_repo "$d_repo")"
        d_issue_title=$(gh issue view "$d_issue" --repo "$d_repo" --json title --jq '.title' 2>/dev/null || true)
        d_issue_url="$(_repo_issue_url "$d_repo" "$d_issue")"
        d_wake_title="$(_escape_wake_value "$d_issue_title")"

        # Only process dogs for this rig
        [[ "$d_rig" == "$rig" ]] || continue

        # Check if dog is still alive
        if tmux has-session -t "$d_session" 2>/dev/null; then
          continue  # Still running
        fi

        echo "[refinery/$rig] dog $dname finished — reviewing output"

        # Security gate: verify dog's issue has sgt-authorized label
        if ! _has_sgt_authorized "$d_repo" "$d_issue"; then
          echo "[refinery/$rig] dog $dname issue #$d_issue lacks sgt-authorized — skipping"
          log_event "REFINERY_DOG_SKIP_UNAUTHORIZED dog=$dname issue=#$d_issue"
          rm -f "$df"
          continue
        fi

        REFINERY_REJECT_REASON=""
        if _refinery_review_dog "$d_repo" "$d_issue" "$rig" "$dname" "$d_backend"; then
          # APPROVED — close issue, notify mayor
          gh issue close "$d_issue" --repo "$d_repo" 2>/dev/null || true
          echo "[refinery/$rig] dog $dname approved and issue #$d_issue closed"
          log_event "REFINERY_DOG_COMPLETE dog=$dname issue=#$d_issue"
          _wake_mayor "dog-approved:$dname:#$d_issue:$rig|repo=$d_owner_repo|title=$d_wake_title|issue_url=$d_issue_url"
          # Clean up dog state + workspace
          local d_ws=""
          d_ws=$(grep '^WORKSPACE=' "$df" 2>/dev/null | cut -d= -f2)
          [[ -d "$d_ws" ]] && rm -rf "$d_ws"
          rm -f "$df"
        else
          # REJECTED — re-dispatch dog with feedback
          echo "[refinery/$rig] dog $dname rejected — dispatching second iteration"
          log_event "REFINERY_DOG_REWORK dog=$dname issue=#$d_issue"

          # Clean up old dog
          local d_ws=""
          d_ws=$(grep '^WORKSPACE=' "$df" 2>/dev/null | cut -d= -f2)
          [[ -d "$d_ws" ]] && rm -rf "$d_ws"
          rm -f "$df"

          # Re-dispatch dog on same issue
          local issue_title_dog
          issue_title_dog=$(gh issue view "$d_issue" --repo "$d_repo" --json title --jq '.title' 2>/dev/null || true)
          issue_title_dog="${issue_title_dog#\[Dog\] }"
          if [[ -n "$issue_title_dog" ]]; then
            local new_dname="dog-$(head -c4 /dev/urandom | xxd -p)"
            local new_session="sgt-${new_dname}"
            local dog_workspace="$SGT_ROOT/dogs/$new_dname"
            mkdir -p "$dog_workspace"

            cat > "$dog_workspace/CLAUDE.md" <<DOGMD
# Dog Task — $new_dname (REWORK)

You are a research/analysis agent. A previous attempt was insufficient.

## Task
$issue_title_dog

## Previous Feedback
$REFINERY_REJECT_REASON

## Instructions
1. Read the previous comments on issue #$d_issue for context
2. Address the feedback above
3. Post improved findings as a comment on issue #$d_issue:
   \`gh issue comment $d_issue --repo $d_repo --body "<your findings>"\`
4. Do NOT close the issue — the refinery will review again
5. Exit
DOGMD

            mkdir -p "$SGT_CONFIG/dogs"
            cat > "$SGT_CONFIG/dogs/$new_dname" <<DSTATE
RIG=$rig
REPO=$d_repo
ISSUE=$d_issue
SESSION=$new_session
WORKSPACE=$dog_workspace
CREATED=$(date -Iseconds)
STATUS=running
REWORK=true
DSTATE

            tmux new-session -d -s "$new_session" -c "$dog_workspace" \
              "$( _ai_cmd "$(_ai_backend_default)" "Read CLAUDE.md. This is a REWORK — previous attempt was rejected. Address the feedback and post improved findings." ); echo '[SGT] dog exited'; sgt _wake-refinery '${rig}' 'dog-done:${new_dname}:#${d_issue}' 2>/dev/null"

            echo "[refinery/$rig] re-dispatched dog $new_dname for issue #$d_issue"
            log_event "REFINERY_DOG_REWORK_DISPATCHED dog=$new_dname issue=#$d_issue"
          fi
        fi
      done
    fi
  done
}

cmd_refinery_start() {
  local rig="${1:-}"
  [[ -n "$rig" ]] || die "usage: sgt refinery start <rig>"
  ensure_init
  ensure_rig "$rig"

  local session="sgt-refinery-${rig}"
  if tmux has-session -t "$session" 2>/dev/null; then
    info "refinery/$rig already running"
    return
  fi

  mkdir -p "$SGT_CONFIG/merge-queue"
  local fifo="$SGT_CONFIG/refinery-${rig}.fifo"
  [[ -p "$fifo" ]] || mkfifo "$fifo"

  tmux new-session -d -s "$session" \
    "SGT_ROOT='$SGT_ROOT' sgt _refinery '$rig'"

  log_event "REFINERY_SPAWN rig=$rig"
  info "refinery/$rig started (session: $session)"
}

cmd_refinery_stop() {
  local rig="${1:-}"
  [[ -n "$rig" ]] || die "usage: sgt refinery stop <rig>"

  local session="sgt-refinery-${rig}"
  if tmux has-session -t "$session" 2>/dev/null; then
    tmux kill-session -t "$session"
    log_event "REFINERY_STOP rig=$rig"
    info "refinery/$rig stopped"
  else
    info "refinery/$rig not running"
  fi
}

# ─── Deacon (health monitor) ──────────────────────────────────────────
#
# The Deacon patrols the entire sgt system:
# - Checks that Witnesses are running for each rig
# - Checks that Refineries are running for each rig
# - Restarts dead agents
# - Writes heartbeat for Boot to check
# - Runs as a bash loop (no AI needed)

_deacon_loop() {
  log_event "DEACON_START"
  echo "[deacon] started — patrolling sgt system"
  local cycle=0

  while true; do
    cycle=$((cycle + 1))
    local now
    now=$(date -Iseconds)
    local actions=0

    # Write heartbeat
    cat > "$SGT_DEACON_HEARTBEAT" <<HEARTBEAT
{
  "timestamp": "$now",
  "cycle": $cycle,
  "pid": $$
}
HEARTBEAT

    echo "[deacon] patrol cycle $cycle at $now"

    # Ensure witnesses for all rigs
    for rig_file in "$SGT_RIGS"/*; do
      [[ -f "$rig_file" ]] || continue
      local rig_name
      rig_name="$(basename "$rig_file")"

      # Check witness
      if ! tmux has-session -t "sgt-witness-${rig_name}" 2>/dev/null; then
        echo "[deacon] witness/$rig_name is down — restarting"
        log_event "DEACON_RESTART_WITNESS rig=$rig_name"
        cmd_witness_start "$rig_name"
        actions=$((actions + 1))
      fi

      # Check refinery
      if ! tmux has-session -t "sgt-refinery-${rig_name}" 2>/dev/null; then
        echo "[deacon] refinery/$rig_name is down — restarting"
        log_event "DEACON_RESTART_REFINERY rig=$rig_name"
        cmd_refinery_start "$rig_name"
        actions=$((actions + 1))
      fi
    done

    # Check for orphaned polecats (no matching rig)
    for f in "$SGT_POLECATS"/*; do
      [[ -f "$f" ]] || continue
      local pname
      pname="$(basename "$f")"
      local p_rig
      p_rig=$(grep '^RIG=' "$f" | cut -d= -f2)
      if [[ ! -f "$SGT_RIGS/$p_rig" ]]; then
        echo "[deacon] orphaned polecat $pname (rig '$p_rig' no longer exists)"
        log_event "DEACON_ORPHAN $pname rig=$p_rig"
      fi
    done

    if [[ "$actions" -eq 0 ]]; then
      echo "[deacon] all agents healthy"
    else
      echo "[deacon] restarted $actions agent(s)"
    fi

    sleep 60
  done
}

cmd_deacon_start() {
  ensure_init

  local session="sgt-deacon"
  if tmux has-session -t "$session" 2>/dev/null; then
    info "deacon already running"
    return
  fi

  tmux new-session -d -s "$session" \
    "SGT_ROOT='$SGT_ROOT' sgt _deacon"

  log_event "DEACON_SPAWN"
  info "deacon started (session: $session)"
}

cmd_deacon_stop() {
  local session="sgt-deacon"
  if tmux has-session -t "$session" 2>/dev/null; then
    tmux kill-session -t "$session"
    log_event "DEACON_STOP"
    info "deacon stopped"
  else
    info "deacon not running"
  fi
}

# ─── Boot (ephemeral deacon triage) ──────────────────────────────────
#
# Boot is a quick check: is the Deacon alive?
# If deacon heartbeat is stale (>5 min), restart it.
# Runs once and exits — called by the Daemon every tick.

_boot_check() {
  local stale_threshold
  stale_threshold="$(_deacon_heartbeat_stale_secs)"

  if ! tmux has-session -t "sgt-deacon" 2>/dev/null; then
    echo "[boot] deacon session missing — restarting"
    log_event "BOOT_RESTART_DEACON reason=session_missing"
    cmd_deacon_start
    return
  fi

  local hb_age hb_ts hb_state
  IFS='|' read -r hb_age hb_ts hb_state <<< "$(_deacon_heartbeat_snapshot)"

  if [[ "$hb_state" == "missing" ]]; then
    echo "[boot] no deacon heartbeat file — restarting"
    log_event "BOOT_RESTART_DEACON reason=no_heartbeat"
    tmux kill-session -t "sgt-deacon" 2>/dev/null || true
    cmd_deacon_start
    return
  fi

  if [[ "$hb_state" != "ok" || ! "$hb_age" =~ ^[0-9]+$ ]]; then
    echo "[boot] invalid deacon heartbeat data — restarting"
    log_event "BOOT_RESTART_DEACON reason=invalid_heartbeat timestamp=$(_escape_quotes "$hb_ts")"
    tmux kill-session -t "sgt-deacon" 2>/dev/null || true
    cmd_deacon_start
    return
  fi

  if [[ "$hb_age" -gt "$stale_threshold" ]]; then
    echo "[boot] deacon heartbeat stale (${hb_age}s > ${stale_threshold}s) — restarting"
    log_event "BOOT_RESTART_DEACON reason=stale_heartbeat age=${hb_age}s threshold=${stale_threshold}s"
    tmux kill-session -t "sgt-deacon" 2>/dev/null || true
    cmd_deacon_start
  else
    echo "[boot] deacon healthy (heartbeat ${hb_age}s ago, threshold ${stale_threshold}s)"
  fi
}

# ─── Daemon (mechanical watchdog) ─────────────────────────────────────
#
# The Daemon is the outermost loop — pure bash, no AI:
# - Runs every SGT_DAEMON_INTERVAL seconds (default 3 min)
# - Calls Boot to check Deacon
# - Writes its own PID for management
# - Can be stopped with: sgt daemon stop

_daemon_loop() {
  local pid=$$
  echo "$pid" > "$SGT_DAEMON_PID"
  log_event "DAEMON_START pid=$pid interval=${SGT_DAEMON_INTERVAL}s"
  echo "[daemon] started (pid $pid, interval ${SGT_DAEMON_INTERVAL}s)"

  # Acquire lock
  exec 200>"$SGT_DAEMON_LOCK"
  if ! flock -n 200; then
    die "another daemon is already running"
  fi

  trap '_daemon_cleanup' EXIT INT TERM

  while true; do
    echo "[daemon] tick at $(date -Iseconds)"

    # Run Boot check
    _boot_check

    sleep "$SGT_DAEMON_INTERVAL"
  done
}

_daemon_cleanup() {
  rm -f "$SGT_DAEMON_PID"
  log_event "DAEMON_STOP"
  echo "[daemon] stopped"
}

cmd_daemon_start() {
  ensure_init

  if [[ -f "$SGT_DAEMON_PID" ]] && kill -0 "$(cat "$SGT_DAEMON_PID")" 2>/dev/null; then
    info "daemon already running (pid $(cat "$SGT_DAEMON_PID"))"
    return
  fi

  # Start in background tmux session
  tmux new-session -d -s "sgt-daemon" \
    "SGT_ROOT='$SGT_ROOT' SGT_DAEMON_INTERVAL='$SGT_DAEMON_INTERVAL' sgt _daemon"

  info "daemon started in tmux session sgt-daemon"
}

cmd_daemon_stop() {
  if [[ -f "$SGT_DAEMON_PID" ]]; then
    local pid
    pid=$(cat "$SGT_DAEMON_PID")
    if kill -0 "$pid" 2>/dev/null; then
      # Kill the tmux session which will trigger cleanup
      tmux kill-session -t "sgt-daemon" 2>/dev/null || kill "$pid" 2>/dev/null || true
      rm -f "$SGT_DAEMON_PID"
      info "daemon stopped"
    else
      rm -f "$SGT_DAEMON_PID"
      info "daemon was not running (stale pid)"
    fi
  else
    # Try killing tmux session directly
    if tmux has-session -t "sgt-daemon" 2>/dev/null; then
      tmux kill-session -t "sgt-daemon"
      info "daemon stopped"
    else
      info "daemon not running"
    fi
  fi
}

cmd_daemon_status() {
  if [[ -f "$SGT_DAEMON_PID" ]] && kill -0 "$(cat "$SGT_DAEMON_PID")" 2>/dev/null; then
    info "daemon running (pid $(cat "$SGT_DAEMON_PID"))"
  else
    info "daemon not running"
  fi
}

# ═══════════════════════════════════════════════════════════════════════
# MAYOR — AI-powered global coordinator
# ═══════════════════════════════════════════════════════════════════════
#
# The Mayor is the brain of SGT. Unlike other agents (pure bash loops),
# the Mayor runs Claude Code periodically to make strategic decisions:
# - Cross-rig coordination (dependencies between issues)
# - Re-prioritize stalled work
# - Dispatch new tasks from a backlog
# - Escalation decisions
# - System health analysis
#
# Runs in tmux, wakes every SGT_MAYOR_INTERVAL seconds.

_mayor_build_briefing() {
  local briefing="$SGT_CONFIG/mayor-briefing.md"

  cat > "$briefing" <<'HEADER'
# SGT System Briefing

You are the Mayor — the global coordinator for SGT (Simple GitHub Gastown).
Review this briefing and take action.

HEADER

  # System status
  echo "## System Status" >> "$briefing"
  echo '```' >> "$briefing"
  cmd_status 2>&1 >> "$briefing"
  echo '```' >> "$briefing"
  echo "" >> "$briefing"

  # Recent log
  echo "## Recent Activity (last 30 events)" >> "$briefing"
  echo '```' >> "$briefing"
  tail -30 "$SGT_LOG" 2>/dev/null >> "$briefing" || echo "no log" >> "$briefing"
  echo '```' >> "$briefing"
  echo "" >> "$briefing"

  # Merge queue (refinery handles review + merge)
  echo "## Merge Queue (pending refinery review + merge)" >> "$briefing"
  local mq_count=0
  if [[ -d "$SGT_CONFIG/merge-queue" ]]; then
    for mqf in "$SGT_CONFIG/merge-queue"/*; do
      [[ -f "$mqf" ]] || continue
      mq_count=$((mq_count + 1))
      echo "- $(basename "$mqf"): $(grep '^PR=' "$mqf" | cut -d= -f2)" >> "$briefing"
    done
  fi
  [[ "$mq_count" -eq 0 ]] && echo "Empty" >> "$briefing"
  echo "" >> "$briefing"

  # Open issues across all rigs (sgt-authorized only)
  echo "## Open Issues (all rigs, sgt-authorized)" >> "$briefing"
  for rig_file in "$SGT_RIGS"/*; do
    [[ -f "$rig_file" ]] || continue
    local rname repo
    rname="$(basename "$rig_file")"
    repo="$(cat "$rig_file")"
    echo "### $rname ($repo)" >> "$briefing"
    gh issue list --repo "$repo" --state open --label "sgt-authorized" --json number,title,labels,milestone \
      --jq '.[] | "- #\(.number): \(.title) [\(.labels | map(.name) | join(","))] \(if .milestone then "(" + .milestone.title + ")" else "" end)"' \
      2>/dev/null >> "$briefing" || echo "  (couldn't fetch)" >> "$briefing"
    echo "" >> "$briefing"
  done

  # Open PRs across all rigs
  echo "## Open PRs (all rigs)" >> "$briefing"
  for rig_file in "$SGT_RIGS"/*; do
    [[ -f "$rig_file" ]] || continue
    local rname repo
    rname="$(basename "$rig_file")"
    repo="$(cat "$rig_file")"
    echo "### $rname" >> "$briefing"
    gh pr list --repo "$repo" --state open --json number,title,headRefName,mergeable \
      --jq '.[] | "- PR #\(.number): \(.title) [\(.headRefName)] mergeable=\(.mergeable)"' \
      2>/dev/null >> "$briefing" || echo "  (couldn't fetch)" >> "$briefing"
    echo "" >> "$briefing"
  done

  # Escalation config
  if [[ -f "$SGT_ESCALATION" ]]; then
    echo "## Escalation Rules" >> "$briefing"
    echo '```json' >> "$briefing"
    cat "$SGT_ESCALATION" >> "$briefing"
    echo '```' >> "$briefing"
    echo "" >> "$briefing"
  fi

  # Mayor history (last decisions)
  if [[ -f "$SGT_CONFIG/mayor-decisions.log" ]]; then
    echo "## Recent Mayor Decisions" >> "$briefing"
    echo '```' >> "$briefing"
    tail -20 "$SGT_CONFIG/mayor-decisions.log" >> "$briefing"
    echo '```' >> "$briefing"
    echo "" >> "$briefing"
  fi

  echo "$briefing"
}

_mayor_wake_summary() {
  local reason="$1"
  local summary=""

  if [[ -z "$reason" || "$reason" == "periodic" ]]; then
    echo ""
    return 0
  fi

  if [[ "$reason" =~ ^merged:pr#([0-9]+):#([0-9]+):([^|]+)\| ]]; then
    local pr issue rig repo title pr_url issue_url
    pr="${BASH_REMATCH[1]}"
    issue="${BASH_REMATCH[2]}"
    rig="${BASH_REMATCH[3]}"
    repo="$(_wake_field "$reason" "repo")"
    title="$(_escape_quotes "$(_wake_field "$reason" "title")")"
    pr_url="$(_wake_field "$reason" "pr_url")"
    issue_url="$(_wake_field "$reason" "issue_url")"
    summary="merged PR #$pr (issue #$issue, rig $rig) | rig=$rig repo=${repo:-unknown} pr=#$pr title=\"${title:-unknown}\" issue=#$issue pr_url=${pr_url:-unknown} issue_url=${issue_url:-unknown}"
  elif [[ "$reason" =~ ^merged:pr#([0-9]+):#([0-9]+):(.+)$ ]]; then
    summary="merged PR #${BASH_REMATCH[1]} (issue #${BASH_REMATCH[2]}, rig ${BASH_REMATCH[3]})"
  elif [[ "$reason" =~ ^merged:pr#([0-9]+):#([0-9]+)\| ]]; then
    local pr issue rig repo title pr_url issue_url
    pr="${BASH_REMATCH[1]}"
    issue="${BASH_REMATCH[2]}"
    rig="$(_wake_field "$reason" "rig")"
    repo="$(_wake_field "$reason" "repo")"
    title="$(_escape_quotes "$(_wake_field "$reason" "title")")"
    pr_url="$(_wake_field "$reason" "pr_url")"
    issue_url="$(_wake_field "$reason" "issue_url")"
    summary="merged PR #$pr (issue #$issue, rig ${rig:-unknown}) | rig=${rig:-unknown} repo=${repo:-unknown} pr=#$pr title=\"${title:-unknown}\" issue=#$issue pr_url=${pr_url:-unknown} issue_url=${issue_url:-unknown}"
  elif [[ "$reason" =~ ^merged:pr#([0-9]+):#([0-9]+)$ ]]; then
    summary="merged PR #${BASH_REMATCH[1]} (issue #${BASH_REMATCH[2]})"
  elif [[ "$reason" =~ ^dog-approved:([^:]+):#([0-9]+):([^|]+)\| ]]; then
    local dname issue rig repo title issue_url
    dname="${BASH_REMATCH[1]}"
    issue="${BASH_REMATCH[2]}"
    rig="${BASH_REMATCH[3]}"
    repo="$(_wake_field "$reason" "repo")"
    title="$(_escape_quotes "$(_wake_field "$reason" "title")")"
    issue_url="$(_wake_field "$reason" "issue_url")"
    summary="dog approved $dname (issue #$issue, rig $rig) | rig=$rig repo=${repo:-unknown} title=\"${title:-unknown}\" issue=#$issue issue_url=${issue_url:-unknown}"
  elif [[ "$reason" =~ ^dog-approved:([^:]+):#([0-9]+):(.+)$ ]]; then
    summary="dog approved ${BASH_REMATCH[1]} (issue #${BASH_REMATCH[2]}, rig ${BASH_REMATCH[3]})"
  elif [[ "$reason" =~ ^dog-approved:([^:]+):#([0-9]+)$ ]]; then
    summary="dog approved ${BASH_REMATCH[1]} (issue #${BASH_REMATCH[2]})"
  elif [[ "$reason" =~ ^orphan-pr:#([0-9]+):(.+)$ ]]; then
    summary="orphan PR #${BASH_REMATCH[1]} queued (rig ${BASH_REMATCH[2]})"
  elif [[ "$reason" =~ ^orphan-pr:#([0-9]+)$ ]]; then
    summary="orphan PR #${BASH_REMATCH[1]} queued"
  else
    summary="wake: $reason"
  fi

  echo "$summary"
}

_mayor_loop() {
  set +e  # Mayor loop must never exit on errors
  log_event "MAYOR_START"
  local lock_claim lock_rc lock_decision lock_owner lock_started lock_until lock_reason
  lock_claim="$(_mayor_lock_claim)"
  lock_rc=$?
  IFS='|' read -r lock_decision lock_owner lock_started lock_until lock_reason <<< "$lock_claim"
  if [[ "$lock_rc" -ne 0 ]]; then
    echo "[mayor] lock decision: ${lock_decision} (ownerPid=${lock_owner:-unknown} startedAt=${lock_started:-unknown} leaseUntil=${lock_until:-unknown} reason=${lock_reason:-unknown})"
    log_event "MAYOR_LOCK_DECISION decision=${lock_decision} ownerPid=${lock_owner:-unknown} startedAt=${lock_started:-unknown} leaseUntil=${lock_until:-unknown} reason=${lock_reason:-unknown}"
    return 0
  fi
  echo "[mayor] lock decision: ${lock_decision} (ownerPid=${lock_owner} startedAt=${lock_started} leaseUntil=${lock_until} reason=${lock_reason})"
  log_event "MAYOR_LOCK_DECISION decision=${lock_decision} ownerPid=${lock_owner} startedAt=${lock_started} leaseUntil=${lock_until} reason=${lock_reason}"
  trap '_mayor_lock_release "$$"' EXIT INT TERM

  local wake_dedupe_ttl
  wake_dedupe_ttl="$(_mayor_wake_dedupe_ttl_secs)"
  local -A wake_seen_at=()

  # Set up FIFO for event-driven wake
  [[ -p "$SGT_MAYOR_FIFO" ]] || mkfifo "$SGT_MAYOR_FIFO"
  # Open FIFO read-write on fd 3 to prevent blocking on open()
  exec 3<>"$SGT_MAYOR_FIFO"
  echo "[mayor] started — event-driven (fallback every ${SGT_MAYOR_INTERVAL}s)"

  while true; do
    lock_claim="$(_mayor_lock_claim)"
    lock_rc=$?
    IFS='|' read -r lock_decision lock_owner lock_started lock_until lock_reason <<< "$lock_claim"
    if [[ "$lock_rc" -ne 0 ]]; then
      echo "[mayor] lock decision: ${lock_decision} (ownerPid=${lock_owner:-unknown} startedAt=${lock_started:-unknown} leaseUntil=${lock_until:-unknown} reason=${lock_reason:-unknown})"
      log_event "MAYOR_LOCK_DECISION decision=${lock_decision} ownerPid=${lock_owner:-unknown} startedAt=${lock_started:-unknown} leaseUntil=${lock_until:-unknown} reason=${lock_reason:-unknown}"
      break
    fi
    if [[ "$lock_decision" == "reused" || "$lock_decision" == "stolen" || "$lock_decision" == "acquired" ]]; then
      echo "[mayor] lock decision: ${lock_decision} (ownerPid=${lock_owner} startedAt=${lock_started} leaseUntil=${lock_until} reason=${lock_reason})"
      log_event "MAYOR_LOCK_DECISION decision=${lock_decision} ownerPid=${lock_owner} startedAt=${lock_started} leaseUntil=${lock_until} reason=${lock_reason}"
    fi

    # Block on fd 3 with timeout — wakes on event OR periodic check
    local wake_reason=""
    local wake_events=()
    local cycle_events=()
    read -t "$SGT_MAYOR_INTERVAL" -u 3 wake_reason 2>/dev/null || true
    if [[ -n "$wake_reason" ]]; then
      echo "[mayor] woken by event: $wake_reason"
      wake_events+=("$wake_reason")
      # Drain any queued events (coalesce rapid-fire wakes)
      local extra=""
      while read -t 0.1 -u 3 extra 2>/dev/null; do
        echo "[mayor] coalescing event: $extra"
        wake_events+=("$extra")
      done
      local deduped_event=""
      while IFS= read -r deduped_event; do
        [[ -n "$deduped_event" ]] || continue
        cycle_events+=("$deduped_event")
      done < <(_dedupe_wake_reasons "${wake_events[@]+"${wake_events[@]}"}")
      wake_reason="${cycle_events[0]}"
    else
      echo "[mayor] periodic check at $(date -Iseconds)"
      wake_reason="periodic"
    fi

    local needs_ai=false
    local issues_found=""
    local actions_taken=""
    local notify_rigger=""
    local snapshot_freshness=""
    local review_watchdog_notes=""
    local ci_watchdog_notes=""

    if [[ "$wake_reason" != "periodic" ]]; then
      local event_reason wake_summary event_key now_ts last_seen age skip_reason claim_rc duplicate_key
      for event_reason in "${cycle_events[@]+"${cycle_events[@]}"}"; do
        event_key="$(_wake_trigger_key "$event_reason")"
        now_ts="$(date +%s)"
        if [[ -n "$event_key" ]]; then
          last_seen="${wake_seen_at[$event_key]:-}"
        else
          last_seen=""
        fi
        if [[ -n "$event_key" && "$wake_dedupe_ttl" -gt 0 ]] && _wake_trigger_should_suppress "$last_seen" "$now_ts" "$wake_dedupe_ttl"; then
          age=$((now_ts - last_seen))
          skip_reason="duplicate wake trigger suppressed (key=$event_key age=${age}s ttl=${wake_dedupe_ttl}s)"
          echo "[mayor] wake skipped - $skip_reason"
          _mayor_notify_rigger "mayor skip: $skip_reason"
          _mayor_record_decision "MAYOR WAKE SKIP (duplicate-trigger) $skip_reason" "wake-dedupe-skip" "$SGT_ROOT" || true
          continue
        fi
        if [[ -n "$event_key" ]]; then
          wake_seen_at["$event_key"]="$now_ts"
        fi
        wake_summary=$(_mayor_wake_summary "$event_reason")
        if [[ -n "$wake_summary" ]]; then
          _mayor_notify_rigger "$wake_summary"
        fi
        # Trigger at most one AI dispatch decision per cycle, even if
        # merged/dog-approved wake events are replayed within that cycle.
        if _wake_requires_dispatch_decision "$event_reason"; then
          if [[ "$event_reason" == merged:* ]]; then
            if _mayor_dispatch_trigger_claim "$event_reason"; then
              needs_ai=true
            else
              claim_rc=$?
              if [[ "$claim_rc" -eq 1 ]]; then
                duplicate_key="${_MAYOR_DISPATCH_TRIGGER_KEY:-unknown}"
                echo "[mayor] dispatch skipped duplicate merged trigger key=$duplicate_key"
                log_event "MAYOR_DISPATCH_SKIPPED_DUPLICATE key=\"$(_escape_quotes "$duplicate_key")\" wake=\"$(_escape_quotes "$event_reason")\""
              else
                needs_ai=true
              fi
            fi
          else
            needs_ai=true
          fi
        fi
      done
    fi

    # === 1. Check agent health ===
    local deacon_restarted="false"
    for agent in daemon deacon; do
      if ! tmux has-session -t "sgt-$agent" 2>/dev/null; then
        issues_found+="  - $agent is DOWN\n"
        echo "[mayor] restarting $agent..."
        sgt "$agent" start 2>/dev/null
        actions_taken+="  - restarted $agent\n"
        if [[ "$agent" == "deacon" ]]; then
          deacon_restarted="true"
        fi
      fi
    done

    if [[ "$deacon_restarted" != "true" ]]; then
      local hb_age hb_ts hb_state hb_stale_secs
      hb_stale_secs="$(_deacon_heartbeat_stale_secs)"
      IFS='|' read -r hb_age hb_ts hb_state <<< "$(_deacon_heartbeat_snapshot)"
      if [[ "$hb_state" == "missing" ]]; then
        issues_found+="  - deacon heartbeat missing\n"
        echo "[mayor] deacon heartbeat missing — restarting deacon..."
        sgt deacon stop 2>/dev/null || true
        sgt deacon start 2>/dev/null
        actions_taken+="  - restarted deacon (missing heartbeat)\n"
      elif [[ "$hb_state" != "ok" || ! "$hb_age" =~ ^[0-9]+$ ]]; then
        issues_found+="  - deacon heartbeat invalid\n"
        echo "[mayor] deacon heartbeat invalid — restarting deacon..."
        sgt deacon stop 2>/dev/null || true
        sgt deacon start 2>/dev/null
        actions_taken+="  - restarted deacon (invalid heartbeat)\n"
      elif [[ "$hb_age" -gt "$hb_stale_secs" ]]; then
        issues_found+="  - deacon heartbeat stale (${hb_age}s > ${hb_stale_secs}s)\n"
        echo "[mayor] deacon heartbeat stale (${hb_age}s > ${hb_stale_secs}s) — restarting deacon..."
        sgt deacon stop 2>/dev/null || true
        sgt deacon start 2>/dev/null
        actions_taken+="  - restarted deacon (stale heartbeat ${hb_age}s)\n"
      fi
    fi

    # Check witnesses and refineries
    for rig_file in "$SGT_RIGS"/*; do
      [[ -f "$rig_file" ]] || continue
      local rname
      rname="$(basename "$rig_file")"
      if ! tmux has-session -t "sgt-witness-$rname" 2>/dev/null; then
        issues_found+="  - witness/$rname is DOWN\n"
        sgt witness start "$rname" 2>/dev/null
        actions_taken+="  - restarted witness/$rname\n"
      fi
      if ! tmux has-session -t "sgt-refinery-$rname" 2>/dev/null; then
        issues_found+="  - refinery/$rname is DOWN\n"
        sgt refinery start "$rname" 2>/dev/null
        actions_taken+="  - restarted refinery/$rname\n"
      fi
    done

    # === 2. Check merge queue (refinery handles review + merge) ===
    local mq_snapshot_count mq_live_count mq_count mq_source mq_status mq_resolution mq_guard_line
    mq_snapshot_count="$(_mayor_merge_queue_count)"
    mq_resolution="$(_mayor_merge_queue_revalidate_once "$mq_snapshot_count")"
    IFS='|' read -r mq_snapshot_count mq_live_count mq_count mq_source mq_status <<< "$mq_resolution"
    mq_guard_line="merge_queue_count snapshot=$mq_snapshot_count live=$mq_live_count chosen=$mq_count source=$mq_source status=$mq_status"
    echo "[mayor] snapshot guard $mq_guard_line"
    log_event "MAYOR_SNAPSHOT_GUARD $mq_guard_line"
    if [[ "$mq_status" == "stale-snapshot" ]]; then
      snapshot_freshness+="  - stale snapshot: $mq_guard_line\n"
    fi
    if [[ "$mq_count" =~ ^[0-9]+$ && "$mq_count" -gt 0 ]]; then
      issues_found+="  - merge queue has $mq_count item(s)\n"
    fi

    # === 2b. Watchdog: stalled REVIEW_UNCLEAR refinery queue items ===
    local review_watch_line
    while IFS= read -r review_watch_line; do
      [[ -n "$review_watch_line" ]] || continue
      local rw_queue rw_rig rw_pr rw_repo rw_issue rw_state rw_since rw_age rw_head rw_threshold
      IFS='|' read -r rw_queue rw_rig rw_pr rw_repo rw_issue rw_state rw_since rw_age rw_head rw_threshold <<< "$review_watch_line"
      local rw_owner_repo rw_pr_url rw_issue_url
      rw_owner_repo="$(_repo_owner_repo "$rw_repo")"
      rw_pr_url="$(_repo_pr_url "$rw_repo" "$rw_pr")"
      rw_issue_url="$(_repo_issue_url "$rw_repo" "$rw_issue")"
      issues_found+="  - refinery review unclear PR #$rw_pr on ${rw_owner_repo} (rig=${rw_rig} age=${rw_age}s threshold>=${rw_threshold}s queue=${rw_queue})\n"
      review_watchdog_notes+="  - queue=${rw_queue} rig=${rw_rig} pr=#${rw_pr} state=${rw_state} age=${rw_age}s threshold>=${rw_threshold}s since=${rw_since}\n"
      needs_ai=true
      if _mayor_should_notify_review_watchdog "$rw_rig" "$rw_repo" "$rw_pr" "$rw_state" "$rw_since" "$rw_head"; then
        _mayor_notify_rigger "mayor escalated: refinery review stalled rig=$rw_rig repo=$rw_owner_repo pr=#$rw_pr issue=#$rw_issue state=$rw_state age=${rw_age}s threshold=${rw_threshold}s pr_url=$rw_pr_url issue_url=$rw_issue_url"
        actions_taken+="  - escalated stalled refinery review for PR #$rw_pr ($rw_owner_repo, age=${rw_age}s)\n"
        log_event "MAYOR_REVIEW_WATCHDOG_NOTIFY rig=$rw_rig repo=$rw_owner_repo pr=#$rw_pr issue=#$rw_issue state=$rw_state age=${rw_age}s threshold=${rw_threshold}s"
      else
        log_event "MAYOR_REVIEW_WATCHDOG_SUPPRESS rig=$rw_rig repo=$rw_owner_repo pr=#$rw_pr issue=#$rw_issue state=$rw_state age=${rw_age}s"
      fi
    done < <(_mayor_review_watchdog_collect_stale)

    # === 2c. Watchdog: stale required CI checks on open PRs ===
    local ci_watch_line
    local ci_watch_lines=()
    mapfile -t ci_watch_lines < <(_mayor_ci_watchdog_collect_stale)
    _mayor_ci_watchdog_reconcile_state "${ci_watch_lines[@]+"${ci_watch_lines[@]}"}"
    for ci_watch_line in "${ci_watch_lines[@]+"${ci_watch_lines[@]}"}"; do
      [[ -n "$ci_watch_line" ]] || continue
      local cw_rig cw_repo cw_pr cw_issue cw_check cw_state cw_since cw_age cw_threshold cw_check_url cw_pr_url cw_issue_url
      IFS='|' read -r cw_rig cw_repo cw_pr cw_issue cw_check cw_state cw_since cw_age cw_threshold cw_check_url cw_pr_url cw_issue_url <<< "$ci_watch_line"
      issues_found+="  - required CI check stale: ${cw_repo} PR #${cw_pr} check=\"${cw_check}\" state=${cw_state} elapsed=${cw_age}s threshold>=${cw_threshold}s check_url=${cw_check_url}\n"
      ci_watchdog_notes+="  - rig=${cw_rig} repo=${cw_repo} pr=#${cw_pr} check=\"$(_escape_quotes "$cw_check")\" state=${cw_state} elapsed=${cw_age}s threshold>=${cw_threshold}s check_url=${cw_check_url}\n"
      needs_ai=true
      if _mayor_should_notify_ci_watchdog "$cw_rig" "$cw_repo" "$cw_pr" "$cw_check" "$cw_state" "$cw_since" "$cw_check_url"; then
        _mayor_notify_rigger "mayor escalated: stale required check rig=$cw_rig repo=$cw_repo pr=#$cw_pr check=\"$(_escape_quotes "$cw_check")\" state=$cw_state elapsed=${cw_age}s threshold=${cw_threshold}s check_url=${cw_check_url} pr_url=${cw_pr_url}"
        actions_taken+="  - escalated stale required check for PR #$cw_pr ($cw_repo check=\"$cw_check\" elapsed=${cw_age}s)\n"
        log_event "MAYOR_CI_WATCHDOG_NOTIFY rig=$cw_rig repo=$cw_repo pr=#$cw_pr check=\"$(_escape_quotes "$cw_check")\" state=$cw_state elapsed=${cw_age}s threshold=${cw_threshold}s check_url=$cw_check_url"
      else
        log_event "MAYOR_CI_WATCHDOG_SUPPRESS rig=$cw_rig repo=$cw_repo pr=#$cw_pr check=\"$(_escape_quotes "$cw_check")\" state=$cw_state elapsed=${cw_age}s check_url=$cw_check_url"
      fi
    done

    # === 3. Check for stale polecats (running > 30min) ===
    for pf in "$SGT_CONFIG/polecats"/*; do
      [[ -f "$pf" ]] || continue
      local pname started_at now_epoch started_epoch age_min
      pname="$(basename "$pf")"
      started_at="$(grep '^STARTED=' "$pf" 2>/dev/null | cut -d= -f2)"
      if [[ -n "$started_at" ]]; then
        now_epoch=$(date +%s)
        started_epoch=$(date -d "$started_at" +%s 2>/dev/null || echo 0)
        if [[ "$started_epoch" -gt 0 ]]; then
          age_min=$(( (now_epoch - started_epoch) / 60 ))
          if [[ "$age_min" -gt 30 ]]; then
            issues_found+="  - polecat $pname running for ${age_min}m (stale?)\n"
            needs_ai=true
          fi
        fi
      fi
    done

    # === 4. Check for open issues with critical/high labels ===
    for rig_file in "$SGT_RIGS"/*; do
      [[ -f "$rig_file" ]] || continue
      local rname repo critical_issues
      rname="$(basename "$rig_file")"
      repo="$(cat "$rig_file")"
      critical_issues=$(
        {
          gh issue list --repo "$repo" --state open --label "sgt-authorized,critical" \
            --json number,title --jq '.[] | "#\(.number) \(.title)"' 2>/dev/null
          gh issue list --repo "$repo" --state open --label "sgt-authorized,high" \
            --json number,title --jq '.[] | "#\(.number) \(.title)"' 2>/dev/null
        } | sort -u | head -5
      )
      if [[ -n "$critical_issues" ]]; then
        issues_found+="  - critical/high issues on $rname:\n"
        while IFS= read -r line; do
          issues_found+="    - $line\n"
        done <<< "$critical_issues"
        if _mayor_should_notify_critical_alert "$rname" "$repo" "$critical_issues"; then
          local critical_alert
          critical_alert="$(_mayor_critical_alert_message "$rname" "$repo" "$critical_issues")"
          _mayor_notify_rigger "$critical_alert"
        else
          local critical_cooldown
          critical_cooldown="$(_critical_alert_cooldown_secs)"
          echo "[mayor] critical alert suppressed by cooldown (${critical_cooldown}s) for $rname"
          log_event "MAYOR_CRITICAL_NOTIFY_SUPPRESS rig=$rname cooldown=${critical_cooldown}s"
        fi
        needs_ai=true
      fi
    done

    # === 5. Check for orphaned PRs (open PRs on sgt/* branches with no polecat) ===
    for rig_file in "$SGT_RIGS"/*; do
      [[ -f "$rig_file" ]] || continue
      local rname repo
      rname="$(basename "$rig_file")"
      repo="$(cat "$rig_file")"
      local orphan_prs
      orphan_prs=$(gh pr list --repo "$repo" --state open \
        --json number,headRefName --jq '.[] | select(.headRefName | startswith("sgt/")) | "#\(.number) [\(.headRefName)]"' 2>/dev/null)
      if [[ -n "$orphan_prs" ]]; then
        while IFS= read -r pr_info; do
          local pr_branch
          pr_branch=$(echo "$pr_info" | grep -oP '\[.*?\]' | tr -d '[]')
          local has_polecat=false
          for pf in "$SGT_CONFIG/polecats"/*; do
            [[ -f "$pf" ]] || continue
            if grep -q "BRANCH=$pr_branch" "$pf" 2>/dev/null; then
              has_polecat=true
              break
            fi
          done
          if [[ "$has_polecat" == "false" ]]; then
            local pr_num
            pr_num=$(echo "$pr_info" | grep -oP '#\d+' | tr -d '#')

            # Live-revalidate state before queueing so stale list snapshots
            # (e.g., PR merged after list) cannot enqueue orphan work.
            local live_pr_state
            live_pr_state=$(gh pr view "$pr_num" --repo "$repo" --json state --jq '.state' 2>/dev/null || true)
            if [[ -z "$live_pr_state" ]]; then
              echo "[mayor] orphaned PR #$pr_num state revalidation failed — skipping"
              log_event "MAYOR_ORPHAN_SKIP_REVALIDATE pr=#$pr_num rig=$rname branch=$pr_branch snapshot_state=OPEN reason=\"unable to query live PR state\""
              continue
            fi
            if [[ "$live_pr_state" != "OPEN" ]]; then
              echo "[mayor] orphaned PR #$pr_num stale snapshot (listed open, live state=$live_pr_state) — skipping"
              log_event "MAYOR_ORPHAN_SKIP_STALE pr=#$pr_num rig=$rname branch=$pr_branch snapshot_state=OPEN live_state=$live_pr_state reason=\"live PR state no longer open\""
              continue
            fi

            # Security gate: check linked issue has sgt-authorized label
            local linked_issue
            linked_issue=$(gh pr view "$pr_num" --repo "$repo" --json body --jq '.body' 2>/dev/null | grep -oP 'Closes #\K[0-9]+' || true)
            if [[ -z "$linked_issue" || "$linked_issue" == "0" ]]; then
              echo "[mayor] orphaned PR #$pr_num has no linked issue — skipping (unauthorized)"
              log_event "MAYOR_ORPHAN_SKIP_NO_ISSUE pr=#$pr_num"
              continue
            fi
            if ! _has_sgt_authorized "$repo" "$linked_issue"; then
              echo "[mayor] orphaned PR #$pr_num linked issue #$linked_issue lacks sgt-authorized — skipping"
              log_event "MAYOR_ORPHAN_SKIP_UNAUTHORIZED pr=#$pr_num issue=#$linked_issue"
              continue
            fi

            local mergeable
            mergeable=$(gh pr view "$pr_num" --repo "$repo" --json mergeable --jq '.mergeable' 2>/dev/null)
            if [[ "$mergeable" == "MERGEABLE" ]]; then
              local orphan_head_sha orphan_polecat
              orphan_head_sha="$(_pr_head_sha "$repo" "$pr_num")"
              orphan_polecat="${pr_branch#sgt/}"
              if _merge_queue_enqueue_polecat "$rname" "$repo" "$pr_branch" "${linked_issue}" "$pr_num" "$orphan_head_sha" "true" "$(_ai_backend_default)" "$orphan_polecat" "mayor-orphan-pr"; then
                actions_taken+="  - queued orphaned PR #$pr_num ($rname) for refinery\n"
                _wake_refinery "$rname" "orphan-pr:#$pr_num"
              fi
            fi
          fi
        done <<< "$orphan_prs"
      fi
    done

    # === Decision & Log ===
    if [[ -z "$issues_found" && -z "$actions_taken" ]]; then
      # Only log periodic all-clears, not event-triggered ones
      if [[ "$wake_reason" == "periodic" ]]; then
        _mayor_record_decision "all clear" "periodic-all-clear" "$SGT_ROOT" || true
      fi
      echo "[mayor] all clear"
    else
      local cycle_entry
      cycle_entry="$(printf 'MAYOR CYCLE (trigger: %s)\n' "$wake_reason")"
      if [[ -n "$issues_found" ]]; then
        cycle_entry+="$(printf '  Issues:\n%b' "$issues_found")"
      fi
      if [[ -n "$actions_taken" ]]; then
        cycle_entry+="$(printf '  Actions:\n%b' "$actions_taken")"
      fi
      if [[ -n "$snapshot_freshness" ]]; then
        cycle_entry+="$(printf '  Snapshot Freshness:\n%b' "$snapshot_freshness")"
      fi
      if [[ -n "$review_watchdog_notes" ]]; then
        cycle_entry+="$(printf '  Review Watchdog:\n%b' "$review_watchdog_notes")"
      fi
      if [[ -n "$ci_watchdog_notes" ]]; then
        cycle_entry+="$(printf '  CI Watchdog:\n%b' "$ci_watchdog_notes")"
      fi
      if _mayor_record_decision "$cycle_entry" "cycle-summary" "$SGT_ROOT"; then
        echo "[mayor] logged issues/actions"
      fi

      # Notify Rigger of significant actions via OpenClaw
      if [[ -n "$notify_rigger" ]]; then
        _mayor_notify_rigger "$notify_rigger"
      fi
    fi

    # === AI escalation (only when needed) ===
    if [[ "$needs_ai" == "true" ]]; then
      echo "[mayor] complex issues detected — invoking AI decision..."
      local mayor_workspace="$SGT_CONFIG/mayor-workspace"
      mkdir -p "$mayor_workspace"

      local briefing
      briefing=$(_mayor_build_briefing)

      cat > "$mayor_workspace/CLAUDE.md" <<MAYORMD
# Mayor — Emergency Decision

Issues requiring your judgment:
$(echo -e "$issues_found")

Recent actions already taken:
$(echo -e "$actions_taken")

Snapshot freshness notes:
$(echo -e "${snapshot_freshness:-  - none}")

## System State
$(cat "$briefing")

## Commands
- \`sgt sling <rig> "<task>"\` — Dispatch work
- \`sgt nuke <polecat>\` — Kill stuck worker
- \`sgt sweep\` — Clean finished workers
- \`gh pr merge <pr#> --repo <repo> --squash --delete-branch\` — Merge PR

Runbook action mapping:
- notify: stale required CI checks (`QUEUED`/`IN_PROGRESS`) past threshold; include elapsed seconds + `check_url`
- retry: transient merge/check races after live revalidation
- nuke: only for irrecoverably stale/dead polecat runtime state

Decide what to do. Log decisions to $SGT_CONFIG/mayor-decisions.log. Be fast.

If an issue/PR just merged, you should proactively:
- queue the next 1–3 highest-leverage issues (write crisp acceptance criteria)
- prefer keeping each issue small enough for an overnight polecat

After deciding, report your actions: sgt mayor notify "<summary of what you did>"
MAYORMD

      local backend="$(_ai_backend_default)"

      if timeout 300 bash -c "SGT_MAYOR_DISPATCH_REVALIDATE=1 _ai_prompt '$backend' '$mayor_workspace' 'Read CLAUDE.md. Handle the issues described. Be decisive and fast. Log your actions.'" 
        </dev/null 2>&1 | tail -5; then
        log_event "MAYOR_AI_CYCLE completed"
        echo "[mayor] AI decision cycle complete"
      else
        echo "[mayor] AI cycle timed out — will retry next loop"
        log_event "MAYOR_AI_CYCLE timeout"
      fi
    fi

    log_event "MAYOR_CYCLE completed (trigger: $wake_reason)"
  done
}

# Notify Rigger agent via OpenClaw messaging (fire-and-forget)
_mayor_notify_rigger() {
  local message="$1"
  if command -v openclaw &>/dev/null && [[ -f "$SGT_NOTIFY" ]]; then
    _notify_openclaw "[SGT Mayor] $message"
    echo "[mayor] notified Rigger: $message"
    log_event "MAYOR_NOTIFY_RIGGER $message"
    return 0
  fi
  return 1
}

# Public command: sgt mayor notify "<message>" — lets AI mayor report to Rigger
cmd_mayor_notify() {
  local message="${1:?usage: sgt mayor notify \"<message>\"}"
  _mayor_notify_rigger "$message"
}

cmd_mayor_start() {
  ensure_init

  local session="sgt-mayor"
  if tmux has-session -t "$session" 2>/dev/null; then
    info "mayor already running"
    return
  fi

  # Create FIFO for event-driven wake
  [[ -p "$SGT_MAYOR_FIFO" ]] || mkfifo "$SGT_MAYOR_FIFO"

  tmux new-session -d -s "$session" \
    "SGT_ROOT='$SGT_ROOT' SGT_MAYOR_INTERVAL='$SGT_MAYOR_INTERVAL' sgt _mayor"

  log_event "MAYOR_SPAWN"
  info "mayor started (session: $session, event-driven + fallback every ${SGT_MAYOR_INTERVAL}s)"
}

cmd_mayor_stop() {
  local session="sgt-mayor"
  if tmux has-session -t "$session" 2>/dev/null; then
    tmux kill-session -t "$session"
    log_event "MAYOR_STOP"
    info "mayor stopped"
  else
    info "mayor not running"
  fi
  # Clean up FIFO
  [[ -p "$SGT_MAYOR_FIFO" ]] && rm -f "$SGT_MAYOR_FIFO"
}

# Public command: wake the mayor on demand
cmd_wake_mayor() {
  local reason="${1:-manual}"
  if ! tmux has-session -t "sgt-mayor" 2>/dev/null; then
    warn "mayor is not running — starting it"
    cmd_mayor_start
    return
  fi
  _wake_mayor "$reason"
  info "mayor woken: $reason"
}

# ═══════════════════════════════════════════════════════════════════════
# DOGS — Lightweight helper pool for non-coding tasks
# ═══════════════════════════════════════════════════════════════════════
#
# Dogs are ephemeral agents like polecats, but for non-coding tasks:
# - Research, analysis, web scraping
# - Document generation, summarization
# - Data collection and formatting
#
# Key difference from polecats:
# - No branch/worktree — they work in a temp directory
# - No PR — they post results as issue comments
# - Lighter weight, faster to spawn

cmd_dog() {
  local rig="${1:-}"
  [[ -n "$rig" ]] || die "usage: sgt dog <rig> <task description>"
  shift

  local task=""
  local backend="$(_ai_backend_default)"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --backend) backend="$2"; shift 2 ;;
      *) task="${task:+$task }$1"; shift ;;
    esac
  done

  [[ -n "$task" ]] || die "no task description provided"
  ensure_init
  ensure_rig "$rig"

  case "$backend" in claude|codex) ;; *) die "invalid backend $backend (expected claude|codex)" ;; esac

  local repo rpath dname session_name
  repo="$(rig_repo "$rig")"
  rpath="$(rig_path "$rig")"
  dname="dog-$(head -c4 /dev/urandom | xxd -p)"
  session_name="sgt-${dname}"

  # Create issue for tracking
  info "creating issue for dog task..."
  _ensure_sgt_authorized_label "$repo"
  local issue_url issue_number
  local issue_body
  printf -v issue_body '## Research/Analysis Task

%s

---

*Created by sgt — dog: `%s`*
*Type: non-coding (results posted as comments)*' "$task" "$dname"
  issue_url=$(gh issue create \
    --repo "$repo" \
    --title "[Dog] $task" \
    --body "$issue_body" \
    --label "dog" --label "sgt-authorized" 2>&1) || {
    # Label might not exist, try without dog label
    issue_url=$(gh issue create \
      --repo "$repo" \
      --title "[Dog] $task" \
      --body "$issue_body" \
    --label "sgt-authorized" 2>&1) || die "failed to create issue: $issue_url"
  }

  issue_number=$(echo "$issue_url" | grep -oP '/issues/\K[0-9]+')
  info "issue #$issue_number created: $issue_url"

  # Create temp workspace
  local dog_workspace="$SGT_ROOT/dogs/$dname"
  mkdir -p "$dog_workspace"

  # Write instructions
  cat > "$dog_workspace/CLAUDE.md" <<DOGMD
# Dog Task — $dname

You are a research/analysis agent. Your job is NOT to write code.
Instead, research the topic and post your findings.

## Task

$task

## Instructions

1. Research the topic thoroughly using available tools
2. Compile your findings into a clear, well-structured report
3. Post your findings as a comment on issue #$issue_number:
   \`gh issue comment $issue_number --repo $repo --body "<your findings>"\`
4. Do NOT close the issue — the refinery will review your work first
5. Exit

## Rules

- Focus on research and analysis, not code
- Be thorough but concise
- Include sources when possible
- If you can't find good information, say so honestly
DOGMD

  # Save dog state
  mkdir -p "$SGT_CONFIG/dogs"
  cat > "$SGT_CONFIG/dogs/$dname" <<DSTATE
RIG=$rig
REPO=$repo
ISSUE=$issue_number
ISSUE_URL=$issue_url
SESSION=$session_name
WORKSPACE=$dog_workspace
CREATED=$(date -Iseconds)
BACKEND=$backend
STATUS=running
DSTATE

  # Spawn in tmux
  info "spawning dog $dname..."
  tmux new-session -d -s "$session_name" -c "$dog_workspace" \
    "$( _ai_cmd "$backend" "Read CLAUDE.md. Complete the research task described there. Post findings to the GitHub issue. Do NOT close the issue." ); echo '[SGT] dog exited'; sgt _wake-refinery '${rig}' 'dog-done:${dname}:#${issue_number}' 2>/dev/null"

  log_event "DOG_SPAWN $dname rig=$rig issue=#$issue_number"
  _wake_refinery "$rig" "dog:$dname:#$issue_number"

  info ""
  info "dog $dname dispatched"
  info "  issue:   $issue_url"
  info "  session: $session_name"
  info "  peek:    sgt peek dog/$dname"
}

cmd_dog_list() {
  ensure_init
  mkdir -p "$SGT_CONFIG/dogs"
  local count=0
  for f in "$SGT_CONFIG/dogs"/*; do
    [[ -f "$f" ]] || continue
    count=$((count + 1))
    local dname
    dname="$(basename "$f")"
    (
      source "$f"
      local alive="dead"
      tmux has-session -t "$SESSION" 2>/dev/null && alive="alive"
      echo "  $dname [$alive]"
      echo "    rig:   $RIG"
      echo "    issue: #$ISSUE ($ISSUE_URL)"
    )
  done
  if [[ "$count" -eq 0 ]]; then
    info "no dogs"
  else
    info "$count dog(s)"
  fi
}

cmd_dog_sweep() {
  ensure_init
  mkdir -p "$SGT_CONFIG/dogs"
  local cleaned=0
  for f in "$SGT_CONFIG/dogs"/*; do
    [[ -f "$f" ]] || continue
    local dname
    dname="$(basename "$f")"
    (
      source "$f"
      if ! tmux has-session -t "$SESSION" 2>/dev/null; then
        echo "CLEAN"
      else
        echo "SKIP"
      fi
    ) | {
      read -r action
      if [[ "$action" == "CLEAN" ]]; then
        # Clean up workspace
        local ws
        ws=$(grep '^WORKSPACE=' "$f" | cut -d= -f2)
        [[ -d "$ws" ]] && rm -rf "$ws"
        rm -f "$f"
        cleaned=$((cleaned + 1))
        log_event "DOG_SWEEP $dname"
        info "swept dog $dname"
      fi
    }
  done
  [[ "$cleaned" -eq 0 ]] && info "no dogs to sweep"
}

# ═══════════════════════════════════════════════════════════════════════
# CREW — Persistent workspace agents
# ═══════════════════════════════════════════════════════════════════════
#
# Crew members are long-running agents that hold project context.
# Unlike ephemeral polecats (spawn, work, die), crew members persist
# across multiple tasks. They're good for:
# - Ongoing maintenance of a codebase
# - Code review (watches for new PRs)
# - Project management (tracks issues, updates docs)
#
# Each crew member has a persistent workspace and identity.

cmd_crew_add() {
  local name="${1:-}" rig="${2:-}" role="${3:-general}"
  [[ -n "$name" ]] || die "usage: sgt crew add <name> <rig> [role]"
  [[ -n "$rig" ]] || die "usage: sgt crew add <name> <rig> [role]"
  ensure_init
  ensure_rig "$rig"

  local repo
  repo="$(rig_repo "$rig")"
  local crew_dir="$SGT_ROOT/crew/$name"
  local session_name="sgt-crew-${name}"

  if [[ -f "$SGT_CONFIG/crew/$name" ]]; then
    die "crew member '$name' already exists"
  fi

  # Clone rig into crew workspace
  mkdir -p "$crew_dir"
  git clone "$repo" "$crew_dir/repo" 2>/dev/null || {
    if [[ -d "$crew_dir/repo" ]]; then
      git -C "$crew_dir/repo" pull --ff-only 2>/dev/null || true
    else
      die "failed to clone $repo"
    fi
  }

  # Write crew member identity
  cat > "$crew_dir/CLAUDE.md" <<CREWMD
# Crew Member: $name

You are a persistent crew member for the $rig project.

## Role: $role

## Your Workspace

Your working directory is $crew_dir/repo — a full clone of the project.
You have your own notes directory at $crew_dir/notes/ — use it to persist context.

## Responsibilities

Based on your role ($role), you should:

### If role = "reviewer"
- Watch for new PRs: \`gh pr list --repo $repo --state open\`
- Review code changes and leave comments
- Approve good PRs, request changes on problematic ones

### If role = "maintainer"
- Keep the repo healthy (dependencies updated, docs current)
- Triage new issues
- Fix small bugs directly (create branch, commit, PR)

### If role = "general"
- Be a knowledgeable project resource
- Answer questions about the codebase
- Help debug issues
- Maintain project documentation

## Persistence

Your notes/ directory persists between sessions. Save important context there:
- \`notes/context.md\` — Current project state, recent changes
- \`notes/decisions.md\` — Architecture decisions, trade-offs
- \`notes/todos.md\` — Things to follow up on

## Commands

- Check PRs: \`gh pr list --repo $repo\`
- Check issues: \`gh issue list --repo $repo\`
- Create PR: \`gh pr create --repo $repo --title "..." --body "..."\`
- Comment: \`gh issue comment <#> --repo $repo --body "..."\`

When you have nothing to do, update your notes and exit. You'll be woken up again.
CREWMD

  mkdir -p "$crew_dir/notes" "$SGT_CONFIG/crew"

  # Save crew state
  cat > "$SGT_CONFIG/crew/$name" <<CSTATE
NAME=$name
RIG=$rig
REPO=$repo
ROLE=$role
WORKSPACE=$crew_dir
SESSION=$session_name
CREATED=$(date -Iseconds)
CSTATE

  log_event "CREW_ADD $name rig=$rig role=$role"
  info "crew member '$name' added (role: $role, rig: $rig)"
}

cmd_crew_wake() {
  local name="${1:-}" task="${2:-Check for new work. Review any open PRs or issues. Update your notes.}"
  [[ -n "$name" ]] || die "usage: sgt crew wake <name> [task]"
  ensure_init

  local cfile="$SGT_CONFIG/crew/$name"
  [[ -f "$cfile" ]] || die "crew member '$name' not found"

  local c_session c_workspace
  eval "$(grep -E '^(SESSION|WORKSPACE)=' "$cfile")"
  c_session="$SESSION"
  c_workspace="$WORKSPACE"

  if tmux has-session -t "$c_session" 2>/dev/null; then
    info "crew member '$name' is already awake"
    return
  fi

  tmux new-session -d -s "$c_session" -c "$c_workspace/repo" \
    "$( _ai_cmd "$(_ai_backend_default)" "Read $c_workspace/CLAUDE.md. Read your notes in $c_workspace/notes/ if they exist. Your task: $task. When done, update your notes." ); echo '[SGT] crew exited'"

  log_event "CREW_WAKE $name task=\"$task\""
  info "crew member '$name' is awake (session: $c_session)"
}

cmd_crew_list() {
  ensure_init
  mkdir -p "$SGT_CONFIG/crew"
  local count=0
  for f in "$SGT_CONFIG/crew"/*; do
    [[ -f "$f" ]] || continue
    count=$((count + 1))
    local cname
    cname="$(basename "$f")"
    (
      source "$f"
      local alive="asleep"
      tmux has-session -t "$SESSION" 2>/dev/null && alive="awake"
      echo "  $cname [$alive]"
      echo "    rig:  $RIG"
      echo "    role: $ROLE"
    )
  done
  if [[ "$count" -eq 0 ]]; then
    info "no crew members"
  else
    info "$count crew member(s)"
  fi
}

cmd_crew_remove() {
  local name="${1:-}"
  [[ -n "$name" ]] || die "usage: sgt crew remove <name>"
  ensure_init

  local cfile="$SGT_CONFIG/crew/$name"
  [[ -f "$cfile" ]] || die "crew member '$name' not found"

  local c_session c_workspace
  eval "$(grep -E '^(SESSION|WORKSPACE)=' "$cfile")"
  c_session="$SESSION"
  c_workspace="$WORKSPACE"

  # Kill session if running
  tmux has-session -t "$c_session" 2>/dev/null && tmux kill-session -t "$c_session"

  rm -f "$cfile"
  log_event "CREW_REMOVE $name"
  info "crew member '$name' removed (workspace kept at $c_workspace)"
}

# ═══════════════════════════════════════════════════════════════════════
# MOLECULES / FORMULAS — Multi-step workflow templates
# ═══════════════════════════════════════════════════════════════════════
#
# A molecule is a YAML file defining a sequence of tasks (a formula).
# When executed, each step becomes a sling with dependency tracking.
#
# Example molecule (saved as molecules/feature.yml):
#   name: feature
#   description: Full feature implementation
#   steps:
#     - task: "Write technical spec for: {description}"
#       type: dog
#     - task: "Implement: {description}"
#       type: polecat
#       depends_on: [0]
#     - task: "Write tests for: {description}"
#       type: polecat
#       depends_on: [1]
#     - task: "Write documentation for: {description}"
#       type: dog
#       depends_on: [1]

cmd_molecule_init() {
  ensure_init
  mkdir -p "$SGT_MOLECULES"

  # Write example molecules
  cat > "$SGT_MOLECULES/feature.yml" <<'MOLML'
name: feature
description: Full feature implementation with spec, code, tests, and docs
steps:
  - task: "Write technical spec for: {description}"
    type: dog
    label: spec
  - task: "Implement: {description}"
    type: polecat
    depends_on: [0]
    label: implementation
  - task: "Write tests for: {description}"
    type: polecat
    depends_on: [1]
    label: tests
  - task: "Write documentation for: {description}"
    type: dog
    depends_on: [1]
    label: docs
MOLML

  cat > "$SGT_MOLECULES/bugfix.yml" <<'MOLML'
name: bugfix
description: Bug investigation and fix with regression tests
steps:
  - task: "Investigate and diagnose: {description}"
    type: dog
    label: investigation
  - task: "Fix bug: {description}"
    type: polecat
    depends_on: [0]
    label: fix
  - task: "Write regression tests for: {description}"
    type: polecat
    depends_on: [1]
    label: regression-test
MOLML

  cat > "$SGT_MOLECULES/research.yml" <<'MOLML'
name: research
description: Multi-angle research with synthesis
steps:
  - task: "Research competitive landscape for: {description}"
    type: dog
    label: competitive
  - task: "Research technical approaches for: {description}"
    type: dog
    label: technical
  - task: "Synthesize findings and write recommendation for: {description}"
    type: dog
    depends_on: [0, 1]
    label: synthesis
MOLML

  log_event "MOLECULE_INIT"
  info "molecules initialized at $SGT_MOLECULES"
  info "available: feature, bugfix, research"
}

cmd_molecule_list() {
  ensure_init
  if [[ ! -d "$SGT_MOLECULES" ]]; then
    info "no molecules — run: sgt molecule init"
    return
  fi

  for f in "$SGT_MOLECULES"/*.yml; do
    [[ -f "$f" ]] || continue
    local name desc
    name=$(grep '^name:' "$f" | head -1 | sed 's/name: *//')
    desc=$(grep '^description:' "$f" | head -1 | sed 's/description: *//')
    local step_count
    step_count=$(grep -c '^ *- task:' "$f" || echo 0)
    echo "  $name ($step_count steps) — $desc"
  done
}

cmd_molecule_run() {
  local molecule="${1:-}" rig="${2:-}"
  [[ -n "$molecule" ]] || die "usage: sgt molecule run <molecule> <rig> <description>"
  [[ -n "$rig" ]] || die "usage: sgt molecule run <molecule> <rig> <description>"
  shift 2

  local description="$*"
  [[ -n "$description" ]] || die "no description provided"
  ensure_init
  ensure_rig "$rig"

  local mol_file="$SGT_MOLECULES/${molecule}.yml"
  [[ -f "$mol_file" ]] || die "molecule '$molecule' not found at $mol_file"

  local repo
  repo="$(rig_repo "$rig")"

  # Create a convoy (milestone) for this molecule run
  local convoy_name="mol-${molecule}-$(date +%s)"
  info "creating convoy for molecule run: $convoy_name"
  cmd_convoy_create "$convoy_name" "$repo" 2>/dev/null || true

  # Ensure sgt-authorized label exists
  _ensure_sgt_authorized_label "$repo"

  # Parse steps and dispatch non-dependent ones immediately
  # For simplicity, dispatch all steps as issues with dependency notes
  # The Mayor will coordinate execution order
  local step_idx=0
  local step_issues=()

  while IFS= read -r line; do
    if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*task:[[:space:]]*(.*) ]]; then
      local raw_task="${BASH_REMATCH[1]}"
      # Remove quotes
      raw_task="${raw_task#\"}"
      raw_task="${raw_task%\"}"
      raw_task="${raw_task#\'}"
      raw_task="${raw_task%\'}"
      # Substitute {description}
      local task="${raw_task//\{description\}/$description}"

      # Get type (next line might have it)
      local step_type="polecat"
      local step_label=""
      local step_deps=""

      # Read ahead for type, depends_on, label (simplified YAML parsing)
      step_idx=$((step_idx + 1))

      # Create issue with dependency info in body
      local issue_url issue_number
      local issue_body
      printf -v issue_body '## Molecule: %s (step %s)

%s

**Convoy:** %s

---
*Part of molecule run. Dispatched by sgt.*' "$molecule" "$step_idx" "$task" "$convoy_name"
      issue_url=$(gh issue create \
        --repo "$repo" \
        --title "[${molecule}/${step_idx}] $task" \
        --body "$issue_body" \
        --label "sgt-authorized" 2>&1) || warn "failed to create issue for step $step_idx"

      if [[ -n "$issue_url" ]]; then
        issue_number=$(echo "$issue_url" | grep -oP '/issues/\K[0-9]+')
        step_issues+=("$issue_number")
        info "step $step_idx: issue #$issue_number — $task"

        # Add to convoy
        gh issue edit "$issue_number" --repo "$repo" --milestone "$convoy_name" 2>/dev/null || true
      fi
    fi
  done < "$mol_file"

  info ""
  info "molecule '$molecule' dispatched with ${#step_issues[@]} steps"
  info "convoy: $convoy_name"
  info "the Mayor will coordinate execution order"

  log_event "MOLECULE_RUN molecule=$molecule rig=$rig steps=${#step_issues[@]} convoy=$convoy_name"
}

# ═══════════════════════════════════════════════════════════════════════
# ESCALATION — Severity-based routing
# ═══════════════════════════════════════════════════════════════════════
#
# Issues can be labeled with severity levels:
# - critical: Immediate dispatch, Mayor notified, timeout 15min
# - high: Priority dispatch, 30min timeout
# - normal: Standard dispatch (default)
# - low: Queued, dispatched when capacity available
#
# Escalation config is stored in $SGT_ESCALATION

cmd_label_init() {
  local rig="${1:-}"
  if [[ -n "$rig" ]]; then
    ensure_init
    ensure_rig "$rig"
    local repo
    repo="$(rig_repo "$rig")"
    _ensure_sgt_authorized_label "$repo"
    info "created sgt-authorized label on $rig"
  else
    # Apply to all rigs
    ensure_init
    for rig_file in "$SGT_RIGS"/*; do
      [[ -f "$rig_file" ]] || continue
      local repo rname
      rname="$(basename "$rig_file")"
      repo="$(cat "$rig_file")"
      _ensure_sgt_authorized_label "$repo"
      info "created sgt-authorized label on $rname"
    done
  fi
}

cmd_escalation_init() {
  ensure_init

  cat > "$SGT_ESCALATION" <<'ESCJSON'
{
  "levels": {
    "critical": {
      "timeout_minutes": 15,
      "max_retries": 3,
      "notify": true,
      "auto_dispatch": true
    },
    "high": {
      "timeout_minutes": 30,
      "max_retries": 2,
      "notify": true,
      "auto_dispatch": true
    },
    "normal": {
      "timeout_minutes": 60,
      "max_retries": 1,
      "notify": false,
      "auto_dispatch": false
    },
    "low": {
      "timeout_minutes": 120,
      "max_retries": 0,
      "notify": false,
      "auto_dispatch": false
    }
  }
}
ESCJSON

  # Create labels on all rigs
  for rig_file in "$SGT_RIGS"/*; do
    [[ -f "$rig_file" ]] || continue
    local repo
    repo="$(cat "$rig_file")"
    for level in critical high normal low dog; do
      gh label create "$level" --repo "$repo" --force 2>/dev/null || true
    done
    _ensure_sgt_authorized_label "$repo"
    info "created escalation + sgt-authorized labels on $(basename "$rig_file")"
  done

  log_event "ESCALATION_INIT"
  info "escalation initialized at $SGT_ESCALATION"
}

cmd_escalation_show() {
  ensure_init
  if [[ ! -f "$SGT_ESCALATION" ]]; then
    info "escalation not configured — run: sgt escalation init"
    return
  fi
  cat "$SGT_ESCALATION"
}

# ─── Up / Down (start/stop everything) ───────────────────────────────

cmd_up() {
  ensure_init
  info "starting sgt system..."

  # Start workers first (bottom-up: witnesses + refineries, then deacon, then daemon)
  for rig_file in "$SGT_RIGS"/*; do
    [[ -f "$rig_file" ]] || continue
    local rig_name
    rig_name="$(basename "$rig_file")"
    cmd_witness_start "$rig_name"
    cmd_refinery_start "$rig_name"
  done

  # Start deacon (monitors witnesses + refineries)
  cmd_deacon_start

  # Give deacon a moment to write its first heartbeat
  sleep 2

  # Start daemon last (monitors deacon via boot)
  cmd_daemon_start

  # Start mayor (AI coordinator)
  cmd_mayor_start

  log_event "SYSTEM_UP"
  info "sgt system is up"
}

cmd_down() {
  ensure_init
  info "stopping sgt system..."

  # Stop all witnesses and refineries
  for rig_file in "$SGT_RIGS"/*; do
    [[ -f "$rig_file" ]] || continue
    local rig_name
    rig_name="$(basename "$rig_file")"
    cmd_witness_stop "$rig_name" 2>/dev/null || true
    cmd_refinery_stop "$rig_name" 2>/dev/null || true
  done

  # Stop mayor
  cmd_mayor_stop 2>/dev/null || true

  # Stop deacon
  cmd_deacon_stop 2>/dev/null || true

  # Stop daemon
  cmd_daemon_stop 2>/dev/null || true

  log_event "SYSTEM_DOWN"
  info "sgt system is down"
  info "(polecats left running — use 'sgt nuke' to kill individual workers)"
}

# ─── Log ──────────────────────────────────────────────────────────────

cmd_log() {
  local lines="${1:-50}"
  tail -n "$lines" "$SGT_LOG" 2>/dev/null || info "no log entries"
}

# ─── Trail (recent activity feed) ─────────────────────────────────────

cmd_trail() {
  local lines="${1:-20}"
  ensure_init
  echo "=== Recent Activity ==="
  tail -n "$lines" "$SGT_LOG" 2>/dev/null || info "no activity"
}

# ─── CLAUDE.md Templates ─────────────────────────────────────────────

_write_claude_md() {
  local rpath="$1"
  [[ -f "$rpath/CLAUDE.md" ]] && return 0

  cat > "$rpath/CLAUDE.md" <<'CLMD'
# Project Context

This repository is managed by sgt (Simple GitHub Gastown).
Workers (polecats) operate on feature branches and submit PRs.

## Workflow

1. Read your assigned GitHub issue for the task description
2. Work on your feature branch
3. Commit frequently with clear messages
4. Push your branch
5. Open a PR that references the issue (use "Closes #N")
6. Exit when done
CLMD
}

_write_polecat_claude_md() {
  local worktree="$1" issue="$2" task="$3" repo="$4" pname="$5" branch="$6" default_branch="$7" auto_merge="$8"

  cat >> "$worktree/CLAUDE.md" <<CLMD

# SGT Polecat Instructions

You are polecat \`$pname\`, an ephemeral coding agent.

## Your Assignment

- **Issue**: #$issue
- **Task**: $task
- **Branch**: \`$branch\`
- **Target**: \`$default_branch\`

## Protocol

1. Read the issue description for full context
2. Implement the requested changes
3. Write tests if appropriate
4. Commit your work with clear commit messages referencing #$issue
5. Push your branch: \`git push -u origin $branch\`
6. Open a PR: \`gh pr create --title "<concise title>" --body "Closes #$issue" --base $default_branch\`
7. Exit the session

## Rules

- Stay focused on the issue — don't scope-creep
- If blocked, comment on the issue explaining the blocker, then exit
- Never force-push or modify the default branch directly
- Keep commits atomic and well-described
CLMD
}

# ─── Main Dispatch ────────────────────────────────────────────────────

cmd_help() {
  cat <<EOF
sgt $SGT_VERSION — Simple GitHub Gastown

Usage: sgt <command> [args]

Core Commands:
  init                          Initialize sgt workspace
  rig add <name> <repo>         Add a repository as a rig
  rig list                      List registered rigs
  rig remove <name>             Remove a rig
  sling <rig> <task> [opts]     Dispatch coding work (issue + branch + polecat)
    --convoy <name>               Add to milestone
    --label <label>               Add label (repeatable)
    --auto-merge                  Auto-merge PR on CI pass
    --backend <claude|codex>      Select AI backend for this polecat (default: SGT_AI_BACKEND)
  status                        Show all agents, polecats, dogs, crew
  peek <target>                 View output (polecat, witness/<rig>, refinery/<rig>,
                                deacon, mayor, dog/<name>, crew/<name>)
  nuke <polecat>                Kill polecat and clean up
  sweep                         Clean up completed polecats

Agent Commands:
  up                            Start full system (daemon + deacon + witnesses + refineries + mayor)
  down                          Stop all agents (polecats keep running)
  daemon start|stop|status      Control the watchdog daemon
  deacon start|stop             Control the health monitor
  witness start|stop <rig>      Control per-rig polecat monitor
  refinery start|stop <rig>     Control per-rig merge queue
  mayor start|stop|notify       Control the AI coordinator
  wake-mayor [reason]           Wake the mayor on demand (event-driven)
  nudge <target> <message>      Send message to agent's tmux session

Dogs (non-coding helpers):
  dog <rig> <task> [--backend <claude|codex>]  Dispatch research/analysis task
  dog list                      List active dogs
  dog sweep                     Clean up completed dogs

Crew (persistent agents):
  crew add <name> <rig> [role]  Add a crew member (roles: reviewer, maintainer, general)
  crew wake <name> [task]       Wake up a crew member with optional task
  crew list                     List crew members
  crew remove <name>            Remove a crew member

Molecules (workflow templates):
  molecule init                 Create default molecule templates
  molecule list                 List available molecules
  molecule run <mol> <rig> <desc>  Execute a multi-step workflow

Security:
  label init [rig]              Create sgt-authorized label (on rig or all rigs)

Escalation:
  escalation init               Set up severity labels and config
  escalation show               Show escalation rules

Communication:
  mail send <repo> <#> <msg>    Comment on a GitHub issue
  mail check <repo>             Show recent issue comments
  convoy create <name> <repo>   Create a convoy (milestone)
  convoy status <repo>          Show convoy progress

Diagnostics:
  log [lines]                   Show recent log entries
  trail [lines]                 Show recent activity feed
  version                       Show version
  help                          This help

Agent Hierarchy:
  daemon     Mechanical watchdog (bash loop, every 3 min)
   └─ boot   Ephemeral triage — checks deacon health
       └─ deacon   Health monitor — ensures witnesses + refineries alive
           ├─ witness/<rig>    Polecat lifecycle manager (+ orphan PR scanner)
           └─ refinery/<rig>   Merge queue processor
  mayor      AI coordinator (event-driven, fallback every 10 min)
  dogs       Ephemeral non-coding helpers (research, analysis)
  crew       Persistent project agents (review, maintenance)

Environment:
  SGT_ROOT              Workspace root (default: ~/sgt)
  SGT_DAEMON_INTERVAL   Daemon tick interval in seconds (default: 180)
  SGT_MAYOR_INTERVAL    Mayor cycle interval in seconds (default: 600)
  SGT_MAYOR_DISPATCH_COOLDOWN  Suppress duplicate dispatches for N seconds (default: 21600, set 0 to disable)
  SGT_MAYOR_LOCK_LEASE_SECS    Mayor lock lease length in seconds (default: SGT_MAYOR_INTERVAL + 120, set >0)
  SGT_MAYOR_WAKE_DEDUPE_TTL    Suppress identical wake trigger keys for N seconds (default: 15, set 0 to disable)
  SGT_MAYOR_DECISION_LOG_ALERT_COOLDOWN  Suppress repeated mayor decision-log failure notifications for N seconds (default: 600, set 0 to disable)
  SGT_AI_BACKEND        AI backend: claude|codex (default: claude)
  NO_COLOR              Disable ANSI color output

Examples:
  sgt init
  sgt rig add myapp owner/repo
  sgt up                                        # Start full system
  sgt sling myapp "Add user authentication"
  sgt sling myapp "Fix login bug" --label critical --convoy v1.0
  sgt dog myapp "Research competitor pricing"    # Non-coding task
  sgt crew add alice myapp reviewer             # Add persistent reviewer
  sgt crew wake alice "Review latest PRs"       # Wake up crew member
  sgt molecule init                             # Create templates
  sgt molecule run feature myapp "User dashboard"  # Multi-step workflow
  sgt escalation init                           # Set up severity levels
  sgt status
  sgt peek mayor                                # Check mayor decisions
  sgt peek dog/dog-a1b2c3d4
  sgt down                                      # Stop agents
EOF
}

main() {
  local cmd="${1:-help}"
  shift 2>/dev/null || true

  case "$cmd" in
    # Internal commands for tmux agent sessions (not user-facing)
    _witness)       _witness_loop "$@" ;;
    _refinery)      _refinery_loop "$@" ;;
    _deacon)        _deacon_loop ;;
    _daemon)        _daemon_loop ;;
    _boot)          _boot_check ;;
    _mayor)         _mayor_loop ;;

    init)           cmd_init ;;
    rig)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        add)    cmd_rig_add "$@" ;;
        list|ls) cmd_rig_list ;;
        remove|rm) cmd_rig_remove "$@" ;;
        *)      die "unknown rig command: $sub (try: add, list, remove)" ;;
      esac
      ;;
    sling)          cmd_sling "$@" ;;
    status|st)      cmd_status ;;
    peek)           cmd_peek "$@" ;;
    nuke)           cmd_nuke "$@" ;;
    sweep)          cmd_sweep ;;
    convoy)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        create)  cmd_convoy_create "$@" ;;
        status)  cmd_convoy_status "$@" ;;
        *)       die "unknown convoy command: $sub (try: create, status)" ;;
      esac
      ;;
    up)             cmd_up ;;
    down)           cmd_down ;;
    daemon)
      local sub="${1:-status}"
      shift 2>/dev/null || true
      case "$sub" in
        start)  cmd_daemon_start ;;
        stop)   cmd_daemon_stop ;;
        status) cmd_daemon_status ;;
        *)      die "unknown daemon command: $sub (try: start, stop, status)" ;;
      esac
      ;;
    deacon)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        start)  cmd_deacon_start ;;
        stop)   cmd_deacon_stop ;;
        *)      die "unknown deacon command: $sub (try: start, stop)" ;;
      esac
      ;;
    witness)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        start)  cmd_witness_start "$@" ;;
        stop)   cmd_witness_stop "$@" ;;
        *)      die "unknown witness command: $sub (try: start, stop)" ;;
      esac
      ;;
    refinery)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        start)  cmd_refinery_start "$@" ;;
        stop)   cmd_refinery_stop "$@" ;;
        *)      die "unknown refinery command: $sub (try: start, stop)" ;;
      esac
      ;;
    mayor)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        start)   cmd_mayor_start ;;
        stop)    cmd_mayor_stop ;;
        notify)  cmd_mayor_notify "$@" ;;
        *)       die "unknown mayor command: $sub (try: start, stop, notify)" ;;
      esac
      ;;
    wake-mayor) cmd_wake_mayor "$@" ;;
    _wake-refinery) _wake_refinery "$@" ;;
    dog)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        list|ls)  cmd_dog_list ;;
        sweep)    cmd_dog_sweep ;;
        *)
          # If first arg looks like a rig name, it's a dispatch
          if [[ -f "$SGT_RIGS/$sub" ]]; then
            cmd_dog "$sub" "$@"
          else
            die "unknown dog command: $sub (try: <rig> <task>, list, sweep)"
          fi
          ;;
      esac
      ;;
    crew)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        add)     cmd_crew_add "$@" ;;
        wake)    cmd_crew_wake "$@" ;;
        list|ls) cmd_crew_list ;;
        remove|rm) cmd_crew_remove "$@" ;;
        *)       die "unknown crew command: $sub (try: add, wake, list, remove)" ;;
      esac
      ;;
    molecule|mol)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        init)   cmd_molecule_init ;;
        list|ls) cmd_molecule_list ;;
        run)    cmd_molecule_run "$@" ;;
        *)      die "unknown molecule command: $sub (try: init, list, run)" ;;
      esac
      ;;
    label)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        init)  cmd_label_init "$@" ;;
        *)     die "unknown label command: $sub (try: init)" ;;
      esac
      ;;
    escalation|esc)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        init)  cmd_escalation_init ;;
        show)  cmd_escalation_show ;;
        *)     die "unknown escalation command: $sub (try: init, show)" ;;
      esac
      ;;
    nudge)          cmd_nudge "$@" ;;
    mail)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        send)   cmd_mail_send "$@" ;;
        check)  cmd_mail_check "$@" ;;
        *)      die "unknown mail command: $sub (try: send, check)" ;;
      esac
      ;;
    log)            cmd_log "$@" ;;
    trail)          cmd_trail "$@" ;;
    version|--version|-v) echo "sgt $SGT_VERSION" ;;
    help|--help|-h) cmd_help ;;
    *)              die "unknown command: $cmd (try: sgt help)" ;;
  esac
}

main "$@"
