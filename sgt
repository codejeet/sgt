#!/usr/bin/env bash
set -euo pipefail

# sgt — Simple GitHub Gastown
# Lightweight orchestration: GitHub Issues + Claude Code + tmux
# Feature-compatible with Gas Town, powered by GitHub instead of beads

SGT_VERSION="0.5.0"
SGT_ROOT="${SGT_ROOT:-$HOME/sgt}"
SGT_CONFIG="$SGT_ROOT/.sgt"
SGT_RIGS="$SGT_CONFIG/rigs"
SGT_POLECATS="$SGT_CONFIG/polecats"
SGT_AGENTS="$SGT_CONFIG/agents"
SGT_LOG="$SGT_ROOT/sgt.log"
SGT_DAEMON_PID="$SGT_CONFIG/daemon.pid"
SGT_DAEMON_LOCK="$SGT_CONFIG/daemon.lock"
SGT_DEACON_HEARTBEAT="$SGT_CONFIG/deacon-heartbeat.json"
SGT_DAEMON_INTERVAL="${SGT_DAEMON_INTERVAL:-180}" # 3 minutes
SGT_MAYOR_INTERVAL="${SGT_MAYOR_INTERVAL:-600}" # 10 minutes
SGT_MAYOR_DISPATCH_COOLDOWN="${SGT_MAYOR_DISPATCH_COOLDOWN:-21600}" # 6 hours
SGT_MOLECULES="$SGT_ROOT/molecules"
SGT_ESCALATION="$SGT_CONFIG/escalation.json"
SGT_MAYOR_FIFO="$SGT_CONFIG/mayor.fifo"
SGT_NOTIFY="$SGT_CONFIG/notify.json"
# Review queue removed in v0.5.0 — refinery handles review inline

# AI backend (claude|codex)
# Priority: CLI flags (per-run) > env SGT_AI_BACKEND > $SGT_CONFIG/settings.env > default
SGT_SETTINGS_ENV="$SGT_CONFIG/settings.env"

# ─── Helpers ──────────────────────────────────────────────────────────

die()  { echo "sgt: $*" >&2; exit 1; }
info() { echo "» $*"; }
warn() { echo "⚠ $*" >&2; }

# ─── UI helpers (color + layout) ──────────────────────────────────────

# Disable color via NO_COLOR=1 or when stdout is not a TTY.
_ui_color_enabled() {
  [[ -t 1 ]] && [[ -z "${NO_COLOR:-}" ]]
}

_c() {
  # Usage: _c "1;32"  (SGR code)
  _ui_color_enabled || return 0
  printf "\033[%sm" "$1"
}

_reset() { _c "0"; }
_bold()  { _c "1"; }
_dim()   { _c "2"; }

_fg_gray()   { _c "90"; }
_fg_red()    { _c "31"; }
_fg_green()  { _c "32"; }
_fg_yellow() { _c "33"; }
_fg_blue()   { _c "34"; }
_fg_mag()    { _c "35"; }
_fg_cyan()   { _c "36"; }

_term_cols() {
  local cols="${COLUMNS:-}"
  if [[ -z "$cols" ]]; then
    cols=$(tput cols 2>/dev/null || echo 80)
  fi
  # Guardrails
  [[ "$cols" =~ ^[0-9]+$ ]] || cols=80
  (( cols < 40 )) && cols=40
  echo "$cols"
}

_repeat() {
  local ch="$1" n="$2"
  (( n <= 0 )) && return 0
  local out=""
  local i
  for (( i=0; i<n; i++ )); do
    out+="$ch"
  done
  printf "%s" "$out"
}

_section() {
  # Rounded box header line (single line, compact)
  local title="$1"
  local cols fill
  cols=$(_term_cols)
  # "╭─ " + title + " " + fill + "╮"
  fill=$(( cols - ${#title} - 6 ))
  (( fill < 0 )) && fill=0
  printf "%s%s╭─ %s %s╮%s\n" "$(_bold)" "$(_fg_cyan)" "$title" "$(_repeat "─" "$fill")" "$(_reset)"
}

_status_badge() {
  # Usage: _status_badge on|off|alive|dead|open|merged|closed|unknown
  local s="$1"
  case "$s" in
    on|alive|OPEN|MERGED)
      printf "%s%s%s%s" "$(_bold)" "$(_fg_green)" "$s" "$(_reset)" ;;
    off|dead|CLOSED)
      printf "%s%s%s%s" "$(_bold)" "$(_fg_red)" "$s" "$(_reset)" ;;
    *)
      printf "%s%s%s%s" "$(_bold)" "$(_fg_yellow)" "$s" "$(_reset)" ;;
  esac
}

log_event() {
  echo "[$(date -Iseconds)] $*" >> "$SGT_LOG"
}

_repo_owner_repo() {
  local repo="${1:-}"
  repo="${repo#https://github.com/}"
  repo="${repo#http://github.com/}"
  echo "$repo"
}

_repo_pr_url() {
  local repo="${1:-}" pr="${2:-}"
  local owner_repo
  owner_repo="$(_repo_owner_repo "$repo")"
  if [[ -z "$owner_repo" || -z "$pr" ]]; then
    echo ""
    return 0
  fi
  echo "https://github.com/$owner_repo/pull/$pr"
}

_repo_issue_url() {
  local repo="${1:-}" issue="${2:-}"
  local owner_repo
  owner_repo="$(_repo_owner_repo "$repo")"
  if [[ -z "$owner_repo" || -z "$issue" || "$issue" == "0" ]]; then
    echo ""
    return 0
  fi
  echo "https://github.com/$owner_repo/issues/$issue"
}

_one_line() {
  local value="${1:-}"
  printf '%s' "$value" | tr '\n' ' ' | sed -E 's/[[:space:]]+/ /g; s/^ //; s/ $//'
}

_escape_quotes() {
  local value
  value="$(_one_line "$1")"
  value="${value//\"/\\\"}"
  echo "$value"
}

_escape_wake_value() {
  local value
  value="$(_one_line "$1")"
  value="${value//|//}"
  echo "$value"
}

_wake_field() {
  local reason="${1:-}" key="${2:-}"
  local part
  IFS='|' read -r -a parts <<< "$reason"
  for part in "${parts[@]}"; do
    if [[ "$part" == "$key="* ]]; then
      echo "${part#${key}=}"
      return 0
    fi
  done
  echo ""
}

_dedupe_wake_reasons() {
  local -A seen=()
  local reason
  for reason in "$@"; do
    [[ -n "$reason" ]] || continue
    if [[ -z "${seen[$reason]+x}" ]]; then
      seen["$reason"]=1
      echo "$reason"
    fi
  done
}

_wake_requires_dispatch_decision() {
  local reason="${1:-}"
  [[ "$reason" == merged:* || "$reason" == dog-approved:* ]]
}

_normalize_label() {
  local label="${1:-}"
  label="$(_one_line "$label")"
  label="$(printf '%s' "$label" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/-/g; s/^-+//; s/-+$//')"
  echo "$label"
}

_symptom_signature() {
  local raw="${1:-}"
  raw="$(_one_line "$raw")"
  raw="$(printf '%s' "$raw" | tr '[:upper:]' '[:lower:]' | sed -E 's/[0-9]+/ num /g; s/[^a-z]+/ /g; s/[[:space:]]+/ /g; s/^ //; s/ $//')"
  echo "$raw"
}

_dispatch_cooldown_secs() {
  local raw="${SGT_MAYOR_DISPATCH_COOLDOWN:-21600}"
  if [[ ! "$raw" =~ ^[0-9]+$ ]]; then
    raw="21600"
  fi
  echo "$raw"
}

_mayor_pre_dispatch_revalidate() {
  local repo="${1:-}"
  local owner_repo owner name snapshot open_prs open_authorized
  owner_repo="$(_repo_owner_repo "$repo")"
  owner="${owner_repo%%/*}"
  name="${owner_repo#*/}"

  if [[ -z "$owner" || -z "$name" || "$owner" == "$name" ]]; then
    echo "revalidation failed: invalid repo '$repo'"
    return 1
  fi

  snapshot=$(
    gh api graphql \
      -f query='query($owner:String!, $name:String!) {
        repository(owner:$owner, name:$name) {
          openPullRequests: pullRequests(states: OPEN) { totalCount }
          openAuthorizedIssues: issues(states: OPEN, labels: ["sgt-authorized"]) { totalCount }
        }
      }' \
      -F owner="$owner" \
      -F name="$name" \
      --jq '.data.repository | "\(.openPullRequests.totalCount)|\(.openAuthorizedIssues.totalCount)"' \
      2>/dev/null || true
  )

  if [[ -z "$snapshot" || "$snapshot" != *"|"* ]]; then
    echo "revalidation failed: unable to query live state"
    return 1
  fi

  IFS='|' read -r open_prs open_authorized <<< "$snapshot"
  [[ "$open_prs" =~ ^[0-9]+$ ]] || open_prs=-1
  [[ "$open_authorized" =~ ^[0-9]+$ ]] || open_authorized=-1

  if [[ "$open_prs" -ne 0 || "$open_authorized" -ne 0 ]]; then
    echo "live state dirty: open_prs=$open_prs open_authorized_issues=$open_authorized"
    return 1
  fi

  return 0
}

_pr_head_sha() {
  local repo="${1:-}" pr="${2:-}"
  [[ -n "$repo" && -n "$pr" ]] || return 1
  gh pr view "$pr" --repo "$repo" --json headRefOid --jq '.headRefOid // ""' 2>/dev/null || true
}

_merge_queue_set_head_sha() {
  local queue_file="${1:-}" head_sha="${2:-}"
  [[ -n "$queue_file" && -f "$queue_file" ]] || return 1
  if grep -q '^HEAD_SHA=' "$queue_file"; then
    sed -i -E "s/^HEAD_SHA=.*/HEAD_SHA=${head_sha}/" "$queue_file"
  else
    printf 'HEAD_SHA=%s\n' "$head_sha" >> "$queue_file"
  fi
}

_find_recent_duplicate_issue() {
  local repo="${1:-}" title="${2:-}" cooldown_secs="${3:-0}"
  shift 3 || true
  local labels=("$@")
  [[ -n "$repo" && -n "$title" ]] || return 1
  [[ "$cooldown_secs" =~ ^[0-9]+$ ]] || cooldown_secs=0
  [[ "$cooldown_secs" -gt 0 ]] || return 1

  local target_signature
  target_signature="$(_symptom_signature "$title")"
  [[ -n "$target_signature" ]] || return 1

  local required_labels=() label norm_label
  for label in "${labels[@]+"${labels[@]}"}"; do
    norm_label="$(_normalize_label "$label")"
    [[ -n "$norm_label" ]] && required_labels+=("$norm_label")
  done

  local issues_tsv
  issues_tsv=$(
    gh issue list --repo "$repo" --state all --limit 100 \
      --json number,title,state,url,createdAt,closedAt,labels \
      --jq '.[] | [
        (.number|tostring),
        .url,
        .state,
        (.title | ascii_downcase | gsub("[0-9]+";" num ") | gsub("[^a-z]+";" ") | gsub(" +";" ") | sub("^ ";"") | sub(" $";"")),
        (.labels | map(.name | ascii_downcase) | join(",")),
        .createdAt,
        (.closedAt // "")
      ] | @tsv' 2>/dev/null || true
  )
  [[ -n "$issues_tsv" ]] || return 1

  local now_epoch best_ref=0 best_match=""
  now_epoch=$(date +%s)
  local issue_number issue_url issue_state issue_sig issue_labels created_at closed_at
  while IFS=$'\t' read -r issue_number issue_url issue_state issue_sig issue_labels created_at closed_at; do
    [[ -n "$issue_number" ]] || continue
    [[ "$issue_sig" == "$target_signature" ]] || continue

    local labels_ok=true required
    for required in "${required_labels[@]+"${required_labels[@]}"}"; do
      if [[ ",$issue_labels," != *",$required,"* ]]; then
        labels_ok=false
        break
      fi
    done
    [[ "$labels_ok" == "true" ]] || continue

    local reference_at="$created_at"
    if [[ "${issue_state^^}" == "CLOSED" && -n "$closed_at" ]]; then
      reference_at="$closed_at"
    fi
    local reference_epoch
    reference_epoch=$(date -d "$reference_at" +%s 2>/dev/null || echo 0)
    [[ "$reference_epoch" -gt 0 ]] || continue

    local age=$((now_epoch - reference_epoch))
    [[ "$age" -lt 0 ]] && age=0
    if [[ "$age" -le "$cooldown_secs" && "$reference_epoch" -ge "$best_ref" ]]; then
      best_ref="$reference_epoch"
      best_match="${issue_number}|${issue_url}|${issue_state}|${age}"
    fi
  done <<< "$issues_tsv"

  [[ -n "$best_match" ]] && echo "$best_match"
}

# Notify via OpenClaw (delivered) if configured. No-op if missing.
_notify_openclaw() {
  local message="${1:-}"
  [[ -n "$message" ]] || return 0
  command -v openclaw &>/dev/null || return 0
  [[ -f "$SGT_NOTIFY" ]] || return 0

  local channel="" to="" reply_to=""
  local notify_out=""
  local py_bin=""
  local py_parse_notify='import json, sys
path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
except Exception:
    sys.exit(1)
def get(keys):
    for k in keys:
        v = data.get(k)
        if v is None:
            continue
        v = str(v).strip()
        if v:
            return v
    return ""
print(get(["channel"]))
print(get(["to"]))
print(get(["reply_to", "reply-to", "replyTo"]))'

  # Avoid heredoc inside command substitution to prevent bash parser warnings.
  if command -v python3 &>/dev/null; then
    py_bin="python3"
  elif command -v python &>/dev/null; then
    py_bin="python"
  else
    return 0
  fi

  notify_out="$("$py_bin" -c "$py_parse_notify" "$SGT_NOTIFY" 2>/dev/null)" || return 0

  local fields=()
  while IFS= read -r line; do fields+=("$line"); done <<< "$notify_out"
  channel="${fields[0]:-}"
  to="${fields[1]:-}"
  reply_to="${fields[2]:-}"
  [[ -n "$channel" ]] || channel="last"

  local cmd=(openclaw agent --agent gastown --deliver --message "$message" --channel "$channel")
  [[ -n "$to" ]] && cmd+=(--to "$to")
  [[ -n "$reply_to" ]] && cmd+=(--reply-to "$reply_to")

  "${cmd[@]}" &>/dev/null &
  disown 2>/dev/null
  log_event "OPENCLAW_NOTIFY channel=$channel to=$to reply_to=$reply_to message=$message"
}

# Wake the mayor via FIFO (non-blocking, fire-and-forget)
_wake_mayor() {
  local reason="${1:-unknown}"
  if [[ -p "$SGT_MAYOR_FIFO" ]]; then
    # Non-blocking write — don't hang if nobody's reading
    echo "$reason" > "$SGT_MAYOR_FIFO" &
    disown 2>/dev/null
  fi
}

# Wake a rig's refinery via FIFO (non-blocking)
_wake_refinery() {
  local rig="$1"
  local reason="${2:-unknown}"
  local fifo="$SGT_CONFIG/refinery-${rig}.fifo"
  if [[ -p "$fifo" ]]; then
    echo "$reason" > "$fifo" &
    disown 2>/dev/null
  fi
}

ensure_init() {
  [[ -d "$SGT_CONFIG" ]] || die "not initialized — run: sgt init"
  # Load settings if present
  if [[ -f "$SGT_SETTINGS_ENV" ]]; then
    # shellcheck disable=SC1090
    source "$SGT_SETTINGS_ENV" 2>/dev/null || true
  fi
}

_ai_backend_default() {
  local b="${SGT_AI_BACKEND:-}"
  if [[ -z "$b" && -f "$SGT_SETTINGS_ENV" ]]; then
    b=$(grep -E '^SGT_AI_BACKEND=' "$SGT_SETTINGS_ENV" 2>/dev/null | head -1 | cut -d= -f2 | tr -d '"' || true)
  fi
  b="${b:-claude}"
  case "$b" in
    claude|codex) echo "$b" ;;
    *) die "invalid SGT_AI_BACKEND '$b' (expected claude|codex)" ;;
  esac
}

_ai_cmd() {
  # Print a command that runs the selected backend with a prompt.
  # Usage: _ai_cmd <backend> <prompt>
  local backend="$1" prompt="$2"
  case "$backend" in
    claude)
      printf 'claude %q --dangerously-skip-permissions' "$prompt"
      ;;
    codex)
      # Non-interactive agent run; allow full access like the previous claude invocation.
      # Force Codex CLI to use OpenAI directly (ignore any local proxy env like OPENAI_BASE_URL).
      printf 'OPENAI_BASE_URL= OPENAI_API_BASE= OPENAI_HOST= codex exec --dangerously-bypass-approvals-and-sandbox --skip-git-repo-check --color auto %q' "$prompt"
      ;;
    *)
      die "unknown backend: $backend"
      ;;
  esac
}

_ai_promptfile() {
  # Run a backend using a prompt read from a file; echoes agent output to stdout.
  # Usage: _ai_promptfile <backend> <workdir> <prompt_file>
  local backend="$1" workdir="$2" prompt_file="$3"
  case "$backend" in
    claude)
      ( cd "$workdir" && claude -p "Read $(basename "$prompt_file")." --dangerously-skip-permissions )
      ;;
    codex)
      local out="$workdir/.codex-last-message.txt"
      rm -f "$out" 2>/dev/null || true
      # Feed the file content as stdin prompt (more reliable than shell-escaping huge text)
      ( cd "$workdir" && OPENAI_BASE_URL= OPENAI_API_BASE= OPENAI_HOST= codex exec --dangerously-bypass-approvals-and-sandbox --skip-git-repo-check --color never -o "$out" - < "$prompt_file" >/dev/null 2>&1 ) || true
      cat "$out" 2>/dev/null || true
      ;;
    *)
      die "unknown backend: $backend"
      ;;
  esac
}

_ai_prompt() {
  # Run a backend with a prompt string (non-interactive); echoes agent output to stdout.
  # Usage: _ai_prompt <backend> <workdir> <prompt>
  local backend="$1" workdir="$2" prompt="$3"
  case "$backend" in
    claude)
      ( cd "$workdir" && claude -p "$prompt" --dangerously-skip-permissions )
      ;;
    codex)
      local out="$workdir/.codex-last-message.txt"
      rm -f "$out" 2>/dev/null || true
      ( cd "$workdir" && printf "%s" "$prompt" | OPENAI_BASE_URL= OPENAI_API_BASE= OPENAI_HOST= codex exec --dangerously-bypass-approvals-and-sandbox --skip-git-repo-check --color never -o "$out" - >/dev/null 2>&1 ) || true
      cat "$out" 2>/dev/null || true
      ;;
    *)
      die "unknown backend: $backend"
      ;;
  esac
}

ensure_rig() {
  local name="$1"
  [[ -f "$SGT_RIGS/$name" ]] || die "rig '$name' not found — run: sgt rig list"
}

rig_repo() {
  local name="$1"
  cat "$SGT_RIGS/$name"
}

rig_owner_repo() {
  local name="$1"
  local repo
  repo="$(rig_repo "$name")"
  echo "${repo#https://github.com/}"
}

rig_path() {
  local name="$1"
  echo "$SGT_ROOT/rigs/$name"
}

# Check if an issue has the sgt-authorized label
# Security gate can be disabled by setting: SGT_REQUIRE_AUTH_LABEL=0
_has_sgt_authorized() {
  local repo="$1" issue="$2"
  if [[ "${SGT_REQUIRE_AUTH_LABEL:-1}" == "0" ]]; then
    return 0
  fi
  [[ -n "$issue" && "$issue" != "0" ]] || return 1
  local labels
  labels=$(gh issue view "$issue" --repo "$repo" --json labels --jq '.labels[].name' 2>/dev/null || true)
  echo "$labels" | grep -qx "sgt-authorized"
}

# Ensure the sgt-authorized label exists on a repo (idempotent)
_ensure_sgt_authorized_label() {
  local repo="$1"
  gh label create "sgt-authorized" --repo "$repo" \
    --description "Authorized for sgt processing — do not apply manually" \
    --color "0E8A16" --force 2>/dev/null || true
}

# Generate polecat name: <rig>-<short-id>
polecat_name() {
  local rig="$1"
  echo "${rig}-$(head -c4 /dev/urandom | xxd -p)"
}

# List all rig names
list_rigs() {
  ls -1 "$SGT_RIGS" 2>/dev/null || true
}

# ─── Init ─────────────────────────────────────────────────────────────

cmd_init() {
  mkdir -p "$SGT_CONFIG" "$SGT_RIGS" "$SGT_POLECATS" "$SGT_AGENTS" "$SGT_ROOT/rigs" "$SGT_ROOT/polecats" "$SGT_CONFIG/merge-queue" "$SGT_CONFIG/dogs"
  touch "$SGT_LOG"
  if [[ ! -f "$SGT_SETTINGS_ENV" ]]; then
    cat > "$SGT_SETTINGS_ENV" <<EOF
# sgt settings (sourced by bash)
# Supported: SGT_AI_BACKEND=claude|codex
SGT_AI_BACKEND=claude
EOF
  fi
  log_event "INIT sgt workspace at $SGT_ROOT"
  info "initialized sgt at $SGT_ROOT"
}

# ─── Rig Commands ─────────────────────────────────────────────────────

cmd_rig_add() {
  local name="${1:-}" repo="${2:-}"
  [[ -n "$name" ]] || die "usage: sgt rig add <name> <github-repo>"
  [[ -n "$repo" ]] || die "usage: sgt rig add <name> <github-repo>"
  ensure_init

  if [[ "$repo" =~ ^https?:// ]]; then
    repo="$repo"
  elif [[ "$repo" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9._-]+$ ]]; then
    repo="https://github.com/$repo"
  else
    die "repo must be 'owner/repo' or a full URL"
  fi

  echo "$repo" > "$SGT_RIGS/$name"

  local rpath
  rpath="$(rig_path "$name")"
  if [[ ! -d "$rpath" ]]; then
    info "cloning $repo → $rpath"
    git clone "$repo" "$rpath"
  else
    info "rig directory exists, pulling latest"
    git -C "$rpath" pull --ff-only 2>/dev/null || true
  fi

  _write_claude_md "$rpath"
  _ensure_sgt_authorized_label "$repo"
  log_event "RIG_ADD $name $repo"
  info "rig '$name' added ($repo)"
}

cmd_rig_list() {
  ensure_init
  if [[ -z "$(ls -A "$SGT_RIGS" 2>/dev/null)" ]]; then
    info "no rigs — run: sgt rig add <name> <repo>"
    return
  fi
  for f in "$SGT_RIGS"/*; do
    local name repo
    name="$(basename "$f")"
    repo="$(cat "$f")"
    local active
    active=$(find "$SGT_POLECATS" -name "${name}-*" 2>/dev/null | wc -l)
    local witness_alive="off"
    tmux has-session -t "sgt-witness-${name}" 2>/dev/null && witness_alive="on"
    local refinery_alive="off"
    tmux has-session -t "sgt-refinery-${name}" 2>/dev/null && refinery_alive="on"
    echo "  $name  $repo"
    echo "    polecats: $active  witness: $witness_alive  refinery: $refinery_alive"
  done
}

cmd_rig_remove() {
  local name="${1:-}"
  [[ -n "$name" ]] || die "usage: sgt rig remove <name>"
  ensure_init
  ensure_rig "$name"

  local active
  active=$(find "$SGT_POLECATS" -name "${name}-*" 2>/dev/null | wc -l)
  if [[ "$active" -gt 0 ]]; then
    die "rig '$name' has $active active polecats — nuke them first"
  fi

  rm -f "$SGT_RIGS/$name"
  log_event "RIG_REMOVE $name"
  info "rig '$name' removed (repo directory kept at $(rig_path "$name"))"
}

# ─── Sling (Dispatch Work) ────────────────────────────────────────────

cmd_sling() {
  local rig="${1:-}"
  [[ -n "$rig" ]] || die "usage: sgt sling <rig> <task description> [--convoy <milestone>] [--label <label>]"
  shift

  local task="" convoy="" labels=() branch_prefix="sgt" auto_merge=false
  local backend="$(_ai_backend_default)"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --convoy)  convoy="$2"; shift 2 ;;
      --label)   labels+=("$2"); shift 2 ;;
      --auto-merge) auto_merge=true; shift ;;
      --backend) backend="$2"; shift 2 ;;
      *)         task="${task:+$task }$1"; shift ;;
    esac
  done

  [[ -n "$task" ]] || die "no task description provided"
  ensure_init
  ensure_rig "$rig"

  case "$backend" in claude|codex) ;; *) die "invalid backend $backend (expected claude|codex)" ;; esac

  local repo rpath pname branch session_name
  repo="$(rig_repo "$rig")"
  rpath="$(rig_path "$rig")"
  pname="$(polecat_name "$rig")"
  branch="${branch_prefix}/${pname}"
  session_name="sgt-${pname}"

  # ── 1. Create GitHub Issue ──
  info "creating issue on $(basename "$repo")..."
  _ensure_sgt_authorized_label "$repo"
  labels+=("sgt-authorized")
  local label_args=""
  for l in "${labels[@]+"${labels[@]}"}"; do
    label_args="$label_args --label $l"
  done

  local dispatch_cooldown duplicate_issue
  dispatch_cooldown="$(_dispatch_cooldown_secs)"
  if [[ "$dispatch_cooldown" -gt 0 ]]; then
    duplicate_issue=$(_find_recent_duplicate_issue "$repo" "$task" "$dispatch_cooldown" "${labels[@]+"${labels[@]}"}" || true)
    if [[ -n "$duplicate_issue" ]]; then
      local dup_number dup_url dup_state dup_age
      IFS='|' read -r dup_number dup_url dup_state dup_age <<< "$duplicate_issue"
      warn "suppressing duplicate dispatch: #$dup_number ($dup_state, ${dup_age}s ago) matches symptom signature"
      log_event "SLING_SUPPRESS_DUPLICATE rig=$rig match=#$dup_number cooldown=${dispatch_cooldown}s title=\"$(_escape_quotes "$task")\""
      info "duplicate issue within cooldown: $dup_url"
      return 0
    fi
  fi

  if [[ "${SGT_MAYOR_DISPATCH_REVALIDATE:-0}" == "1" ]]; then
    local revalidation_reason ts
    if ! revalidation_reason=$(_mayor_pre_dispatch_revalidate "$repo"); then
      ts="$(date '+%Y-%m-%d %H:%M:%S')"
      echo "[mayor] dispatch skipped on $rig - $revalidation_reason"
      {
        echo "[$ts] MAYOR DISPATCH SKIP (stale-state)"
        echo "  rig=$rig"
        echo "  reason=$revalidation_reason"
        echo "  task=\"$(_escape_quotes "$task")\""
      } >> "$SGT_CONFIG/mayor-decisions.log"
      log_event "MAYOR_DISPATCH_SKIP_STALE rig=$rig reason=\"$(_escape_quotes "$revalidation_reason")\" title=\"$(_escape_quotes "$task")\""
      return 0
    fi
  fi

  local issue_url issue_number
  local issue_body
  printf -v issue_body '## Task

%s

---

*Created by sgt — polecat: `%s`*
*Branch: `%s`*' "$task" "$pname" "$branch"
  issue_url=$(gh issue create \
    --repo "$repo" \
    --title "$task" \
    --body "$issue_body" \
    $label_args 2>&1) || die "failed to create issue: $issue_url"

  issue_number=$(echo "$issue_url" | grep -oP '/issues/\K[0-9]+')
  info "issue #$issue_number created: $issue_url"

  # ── 2. Add to milestone if convoy specified ──
  if [[ -n "$convoy" ]]; then
    local owner_repo="${repo#https://github.com/}"
    local ms_number
    ms_number=$(gh api "repos/$owner_repo/milestones" --jq ".[] | select(.title==\"$convoy\") | .number" 2>/dev/null || true)
    if [[ -z "$ms_number" ]]; then
      ms_number=$(gh api "repos/$owner_repo/milestones" \
        -f title="$convoy" -f state=open \
        --jq '.number' 2>/dev/null) || warn "couldn't create milestone"
    fi
    if [[ -n "$ms_number" ]]; then
      gh issue edit "$issue_number" --repo "$repo" --milestone "$convoy" 2>/dev/null || true
      info "added to convoy (milestone): $convoy"
    fi
  fi

  # ── 3. Create branch + worktree ──
  info "setting up branch $branch..."
  git -C "$rpath" fetch origin 2>/dev/null || true
  local default_branch
  default_branch=$(git -C "$rpath" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's|refs/remotes/origin/||' || echo "main")

  local worktree="$SGT_ROOT/polecats/$pname"
  mkdir -p "$SGT_ROOT/polecats"
  git -C "$rpath" worktree add -b "$branch" "$worktree" "origin/$default_branch" 2>/dev/null \
    || git -C "$rpath" worktree add -b "$branch" "$worktree" "$default_branch"

  if [[ -f "$rpath/CLAUDE.md" ]]; then
    cp "$rpath/CLAUDE.md" "$worktree/CLAUDE.md"
  fi
  _write_polecat_claude_md "$worktree" "$issue_number" "$task" "$repo" "$pname" "$branch" "$default_branch" "$auto_merge"

  # ── 4. Save polecat state ──
  cat > "$SGT_POLECATS/$pname" <<PSTATE
RIG=$rig
REPO=$repo
ISSUE=$issue_number
ISSUE_URL=$issue_url
BRANCH=$branch
WORKTREE=$worktree
SESSION=$session_name
DEFAULT_BRANCH=$default_branch
AUTO_MERGE=$auto_merge
BACKEND=$backend
CREATED=$(date -Iseconds)
STATUS=running
PSTATE

  # ── 5. Spawn AI agent in tmux ──
  info "spawning polecat $pname in tmux session $session_name..."
  tmux new-session -d -s "$session_name" -c "$worktree" \
    "$( _ai_cmd "$backend" "Read the CLAUDE.md in this directory. Your task is described in GitHub issue #${issue_number}. The issue title is: ${task}. Work on branch ${branch}. When done, commit your changes, push the branch, and open a PR that closes #${issue_number}." ); echo '[SGT] polecat exited'; sgt _wake-refinery '${rig}' 'polecat-done:${pname}:#${issue_number}' 2>/dev/null"

  log_event "SLING $pname rig=$rig issue=#$issue_number branch=$branch"
  _wake_refinery "$rig" "sling:$pname:#$issue_number"

  info ""
  info "polecat $pname dispatched"
  info "  issue:   $issue_url"
  info "  branch:  $branch"
  info "  session: $session_name"
  info "  peek:    sgt peek $pname"
}

# ─── Status ───────────────────────────────────────────────────────────

cmd_status() {
  ensure_init

  _section "Agents"

  local daemon_alive="off" daemon_pid=""
  if [[ -f "$SGT_DAEMON_PID" ]] && kill -0 "$(cat "$SGT_DAEMON_PID")" 2>/dev/null; then
    daemon_alive="on"
    daemon_pid="$(cat "$SGT_DAEMON_PID")"
  fi
  if [[ -n "$daemon_pid" ]]; then
    printf "  %-16s %s  %s(pid %s)%s\n" "daemon" "$(_status_badge "$daemon_alive")" "$(_fg_gray)" "$daemon_pid" "$(_reset)"
  else
    printf "  %-16s %s\n" "daemon" "$(_status_badge "$daemon_alive")"
  fi

  local deacon_alive="off"
  tmux has-session -t "sgt-deacon" 2>/dev/null && deacon_alive="on"
  printf "  %-16s %s\n" "deacon" "$(_status_badge "$deacon_alive")"
  if [[ -f "$SGT_DEACON_HEARTBEAT" ]]; then
    local last_beat
    last_beat=$(python3 -c "import json; d=json.load(open('$SGT_DEACON_HEARTBEAT')); print(d.get('timestamp','?'))" 2>/dev/null || echo "?")
    printf "  %-16s %s%s%s\n" "" "$(_dim)" "last heartbeat: $last_beat" "$(_reset)"
  fi

  for rig_file in "$SGT_RIGS"/*; do
    [[ -f "$rig_file" ]] || continue
    local rig_name
    rig_name="$(basename "$rig_file")"
    local w_alive="off" r_alive="off"
    tmux has-session -t "sgt-witness-${rig_name}" 2>/dev/null && w_alive="on"
    tmux has-session -t "sgt-refinery-${rig_name}" 2>/dev/null && r_alive="on"
    printf "  %-16s %s\n" "witness/$rig_name"  "$(_status_badge "$w_alive")"
    printf "  %-16s %s\n" "refinery/$rig_name" "$(_status_badge "$r_alive")"
  done

  local mayor_alive="off"
  tmux has-session -t "sgt-mayor" 2>/dev/null && mayor_alive="on"
  printf "  %-16s %s\n" "mayor" "$(_status_badge "$mayor_alive")"

  _section "Dogs"
  local dog_count=0
  if [[ -d "$SGT_CONFIG/dogs" ]]; then
    for df in "$SGT_CONFIG/dogs"/*; do
      [[ -f "$df" ]] || continue
      dog_count=$((dog_count + 1))
      local dname
      dname="$(basename "$df")"
      (
        source "$df"
        local alive="dead"
        tmux has-session -t "$SESSION" 2>/dev/null && alive="alive"
        printf "  %-16s %s  %s#%s%s\n" "$dname" "$(_status_badge "$alive")" "$(_fg_gray)" "$ISSUE" "$(_reset)"
      )
    done
  fi
  [[ "$dog_count" -eq 0 ]] && printf "  %s%s%s\n" "$(_dim)" "none" "$(_reset)"

  _section "Crew"
  local crew_count=0
  if [[ -d "$SGT_CONFIG/crew" ]]; then
    for cf in "$SGT_CONFIG/crew"/*; do
      [[ -f "$cf" ]] || continue
      crew_count=$((crew_count + 1))
      local cname
      cname="$(basename "$cf")"
      (
        source "$cf"
        local alive="asleep"
        tmux has-session -t "$SESSION" 2>/dev/null && alive="awake"
        printf "  %-16s %s  %s(%s/%s)%s\n" "$cname" "$(_status_badge "$alive")" "$(_fg_gray)" "$ROLE" "$RIG" "$(_reset)"
      )
    done
  fi
  [[ "$crew_count" -eq 0 ]] && printf "  %s%s%s\n" "$(_dim)" "none" "$(_reset)"

  _section "Merge Queue"
  local mq_count=0
  if [[ -d "$SGT_CONFIG/merge-queue" ]]; then
    for mqf in "$SGT_CONFIG/merge-queue"/*; do
      [[ -f "$mqf" ]] || continue
      mq_count=$((mq_count + 1))
      (
        source "$mqf"
        printf "  %-16s %sPR#%s%s  %s%s%s\n" "$(basename "$mqf")" "$(_fg_gray)" "${PR:-?}" "$(_reset)" "$(_dim)" "${RIG:-?}" "$(_reset)"
      )
    done
  fi
  [[ "$mq_count" -eq 0 ]] && printf "  %s%s%s\n" "$(_dim)" "empty" "$(_reset)"

  _section "Polecats"
  local count=0
  for f in "$SGT_POLECATS"/*; do
    [[ -f "$f" ]] || continue
    count=$((count + 1))

    local pname
    pname="$(basename "$f")"
    (
      source "$f"
      local alive="dead"
      tmux has-session -t "$SESSION" 2>/dev/null && alive="alive"

      local pr_number pr_state pr_title
      pr_number=$(gh pr list --repo "$REPO" --head "$BRANCH" --json number --jq '.[0].number' 2>/dev/null || true)
      pr_state=$(gh pr list --repo "$REPO" --head "$BRANCH" --json state --jq '.[0].state' 2>/dev/null || true)
      pr_title=$(gh pr list --repo "$REPO" --head "$BRANCH" --json title --jq '.[0].title' 2>/dev/null || true)

      local pr_chunk=""
      if [[ -n "$pr_number" ]]; then
        pr_chunk="  PR#${pr_number} ${pr_state}"
      fi

      printf "  %s%-14s%s %s  %s#%s%s  %s%s%s\n" \
        "$(_bold)" "$pname" "$(_reset)" \
        "$(_status_badge "$alive")" \
        "$(_fg_gray)" "$ISSUE" "$(_reset)" \
        "$(_dim)" "$BRANCH$pr_chunk" "$(_reset)"

      # Optional: show PR title as a second dense line (only if present)
      if [[ -n "$pr_title" ]]; then
        printf "  %s%s%s\n" "$(_fg_gray)" "      ↳ ${pr_title:0:$((_term_cols()-10))}" "$(_reset)"
      fi
    )
  done

  if [[ "$count" -eq 0 ]]; then
    printf "  %s%s%s\n" "$(_dim)" "none" "$(_reset)"
  else
    printf "\n%s%s%s\n" "$(_fg_gray)" "$count polecat(s) tracked" "$(_reset)"
  fi
}


# ─── Peek ─────────────────────────────────────────────────────────────

cmd_peek() {
  local target="${1:-}"
  [[ -n "$target" ]] || die "usage: sgt peek <polecat|witness/<rig>|refinery/<rig>|deacon>"
  ensure_init

  local session=""

  # Allow peeking at agents too
  case "$target" in
    deacon)       session="sgt-deacon" ;;
    witness/*)    session="sgt-witness-${target#witness/}" ;;
    refinery/*)   session="sgt-refinery-${target#refinery/}" ;;
    mayor)        session="sgt-mayor" ;;
    dog/*)        session="sgt-${target#dog/}" ;;
    crew/*)       session="sgt-crew-${target#crew/}" ;;
    *)            session="" ;;
  esac

  if [[ -n "$session" ]]; then
    if tmux has-session -t "$session" 2>/dev/null; then
      _section "peek: $target"
      tmux capture-pane -t "$session" -p -S -200
    else
      warn "$target session is dead"
    fi
    return
  fi

  # Polecat peek
  local pfile="$SGT_POLECATS/$target"
  [[ -f "$pfile" ]] || die "polecat '$target' not found"

  (
    source "$pfile"
    _section "peek: polecat/$target (#$ISSUE)"

    if tmux has-session -t "$SESSION" 2>/dev/null; then
      tmux capture-pane -t "$SESSION" -p -S -200
      return
    fi

    warn "session $SESSION is dead"
    if [[ -d "$WORKTREE" ]]; then
      printf "%s%s%s\n" "$(_dim)" "last commits on $BRANCH:" "$(_reset)"
      git -C "$WORKTREE" log --oneline -5 2>/dev/null || true
    fi

    local pr
    pr=$(gh pr list --repo "$REPO" --head "$BRANCH" --json number,state,url --jq '.[0] | "#\(.number) [\(.state)] \(.url)"' 2>/dev/null || true)
    if [[ -n "$pr" ]]; then
      printf "%s%sPR:%s %s\n" "$(_bold)" "$(_fg_mag)" "$(_reset)" "$pr"
    fi
  )
}


# ─── Nuke ─────────────────────────────────────────────────────────────

cmd_nuke() {
  local pname="${1:-}"
  [[ -n "$pname" ]] || die "usage: sgt nuke <polecat>"
  ensure_init

  local pfile="$SGT_POLECATS/$pname"
  [[ -f "$pfile" ]] || die "polecat '$pname' not found"

  (
    source "$pfile"
    if tmux has-session -t "$SESSION" 2>/dev/null; then
      tmux kill-session -t "$SESSION"
      info "killed session $SESSION"
    fi
    if [[ -d "$WORKTREE" ]]; then
      local rpath
      rpath="$(rig_path "$RIG")"
      git -C "$rpath" worktree remove --force "$WORKTREE" 2>/dev/null || rm -rf "$WORKTREE"
      info "removed worktree $WORKTREE"
    fi
    git -C "$(rig_path "$RIG")" push origin --delete "$BRANCH" 2>/dev/null && info "deleted remote branch $BRANCH" || true
  )

  rm -f "$pfile"
  log_event "NUKE $pname"
  info "polecat $pname nuked"
}

# ─── Sweep ────────────────────────────────────────────────────────────

cmd_sweep() {
  ensure_init
  local cleaned=0
  for f in "$SGT_POLECATS"/*; do
    [[ -f "$f" ]] || continue
    local pname
    pname="$(basename "$f")"
    (
      source "$f"
      if ! tmux has-session -t "$SESSION" 2>/dev/null; then
        local pr_state
        pr_state=$(gh pr list --repo "$REPO" --head "$BRANCH" --json state --jq '.[0].state' 2>/dev/null || true)

        if [[ "$pr_state" == "OPEN" || "$pr_state" == "MERGED" ]]; then
          info "polecat $pname completed (PR $pr_state) — cleaning up"
          if [[ -d "$WORKTREE" ]]; then
            local rpath
            rpath="$(rig_path "$RIG")"
            git -C "$rpath" worktree remove --force "$WORKTREE" 2>/dev/null || rm -rf "$WORKTREE"
          fi
          # Signal to parent to clean
          echo "CLEAN"
        else
          warn "polecat $pname is dead but no PR found — use 'sgt nuke $pname' to clean up"
          echo "SKIP"
        fi
      else
        echo "SKIP"
      fi
    ) | {
      read -r action
      if [[ "$action" == "CLEAN" ]]; then
        rm -f "$f"
        cleaned=$((cleaned + 1))
        log_event "SWEEP $pname"
      fi
    }
  done

  if [[ "$cleaned" -eq 0 ]]; then
    info "nothing to sweep"
  else
    info "swept $cleaned completed polecat(s)"
  fi
}

# ─── Convoy (Milestones) ──────────────────────────────────────────────

cmd_convoy_create() {
  local name="${1:-}" repo="${2:-}"
  [[ -n "$name" ]] || die "usage: sgt convoy create <name> <repo>"
  [[ -n "$repo" ]] || die "usage: sgt convoy create <name> <repo>"
  ensure_init

  if [[ "$repo" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9._-]+$ ]]; then
    repo="https://github.com/$repo"
  fi

  local owner_repo="${repo#https://github.com/}"
  local ms_number
  ms_number=$(gh api "repos/$owner_repo/milestones" \
    -f title="$name" -f state=open \
    --jq '.number') || die "failed to create milestone"

  log_event "CONVOY_CREATE $name $owner_repo milestone=#$ms_number"
  info "convoy '$name' created (milestone #$ms_number)"
}

cmd_convoy_status() {
  local repo="${1:-}"
  [[ -n "$repo" ]] || die "usage: sgt convoy status <repo>"
  ensure_init

  if [[ "$repo" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9._-]+$ ]]; then
    repo="https://github.com/$repo"
  fi
  local owner_repo="${repo#https://github.com/}"

  gh api "repos/$owner_repo/milestones" --jq '.[] | "  \(.title): \(.open_issues) open / \(.closed_issues) closed [\(.state)]"' 2>/dev/null || info "no milestones"
}

# ─── Nudge (Send message to tmux session) ─────────────────────────────

cmd_nudge() {
  local target="${1:-}" message="${2:-}"
  [[ -n "$target" ]] || die "usage: sgt nudge <target> <message>"
  [[ -n "$message" ]] || die "usage: sgt nudge <target> <message>"
  ensure_init

  local session=""
  case "$target" in
    deacon)        session="sgt-deacon" ;;
    witness/*)     session="sgt-witness-${target#witness/}" ;;
    refinery/*)    session="sgt-refinery-${target#refinery/}" ;;
    *)             session="sgt-${target}" ;;
  esac

  if ! tmux has-session -t "$session" 2>/dev/null; then
    die "session $session is not running"
  fi

  # Send message in literal mode, then Enter
  tmux send-keys -t "$session" -l "$message"
  sleep 0.5
  tmux send-keys -t "$session" Enter

  log_event "NUDGE $target: $message"
  info "nudged $target"
}

# ─── Mail (GitHub Issue Comments as async messages) ────────────────────

cmd_mail_send() {
  local repo="${1:-}" issue="${2:-}" message="${3:-}"
  [[ -n "$repo" && -n "$issue" && -n "$message" ]] || die "usage: sgt mail send <repo> <issue#> <message>"

  if [[ "$repo" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9._-]+$ ]]; then
    repo="https://github.com/$repo"
  fi

  gh issue comment "$issue" --repo "$repo" --body "$message" 2>/dev/null \
    || die "failed to comment on issue #$issue"

  log_event "MAIL issue=#$issue: $message"
  info "mail sent to issue #$issue"
}

cmd_mail_check() {
  local repo="${1:-}"
  [[ -n "$repo" ]] || die "usage: sgt mail check <repo>"

  if [[ "$repo" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9._-]+$ ]]; then
    repo="https://github.com/$repo"
  fi
  local owner_repo="${repo#https://github.com/}"

  # Show recent issue comments (last 10)
  gh api "repos/$owner_repo/issues/comments?sort=created&direction=desc&per_page=10" \
    --jq '.[] | "  #\(.issue_url | split("/") | last) [\(.created_at | split("T")[0])]: \(.body | split("\n")[0] | .[0:80])"' 2>/dev/null \
    || info "no recent messages"
}

# ═══════════════════════════════════════════════════════════════════════
# AGENT LAYER — Witness, Refinery, Deacon, Boot, Daemon
# ═══════════════════════════════════════════════════════════════════════

# ─── Witness (per-rig polecat lifecycle manager) ──────────────────────
#
# The Witness monitors polecats for a single rig:
# - Detects stalled/zombie polecats (session dead, no PR)
# - Detects completed polecats (session dead, PR open)
# - Auto-sweeps completed polecats
# - Signals Refinery when PRs are ready for merge
# - Respawns stalled polecats (re-slings the issue)
# - Runs as a bash loop in tmux, no AI needed

_witness_loop() {
  local rig="$1"
  local repo
  repo="$(rig_repo "$rig")"
  local owner_repo="${repo#https://github.com/}"

  log_event "WITNESS_START rig=$rig"
  echo "[witness/$rig] started — monitoring polecats"

  while true; do
    local now
    now=$(date +%s)

    for f in "$SGT_POLECATS"/${rig}-*; do
      [[ -f "$f" ]] || continue
      local pname
      pname="$(basename "$f")"

      # Source in subshell to avoid polluting
      local p_session p_branch p_issue p_worktree p_created p_repo p_auto_merge
      eval "$(grep -E '^(SESSION|BRANCH|ISSUE|WORKTREE|CREATED|REPO|AUTO_MERGE|BACKEND)=' "$f")"
      p_session="$SESSION"
      p_branch="$BRANCH"
      p_issue="$ISSUE"
      p_worktree="$WORKTREE"
      p_created="$CREATED"
      p_repo="$REPO"
      p_auto_merge="${AUTO_MERGE:-false}"

      local alive=false
      tmux has-session -t "$p_session" 2>/dev/null && alive=true

      if $alive; then
        # Check if Claude Code is idle (finished but tmux still alive)
        local pane_output
        pane_output=$(tmux capture-pane -t "$p_session" -p 2>/dev/null || true)
        # Detect: [SGT] exit marker OR Claude Code idle at ❯ with no recent activity
        local is_idle=false
        if echo "$pane_output" | grep -qE '^\[SGT\] polecat exited'; then
          is_idle=true
        elif echo "$pane_output" | grep -qP '\x{276f}'; then
          # Check if a PR was already opened (work is done)
          local has_pr
          has_pr=$(gh pr list --repo "$p_repo" --head "$p_branch" --json number --jq '.[0].number' 2>/dev/null || true)
          if [[ -n "$has_pr" ]]; then
            is_idle=true
          fi
        fi
        if $is_idle; then
          echo "[witness/$rig] $pname Claude Code finished (idle/exited) — treating as complete"
          log_event "WITNESS_IDLE_DETECTED $pname"
          # Kill the tmux session so the dead-session handler below picks it up
          tmux kill-session -t "$p_session" 2>/dev/null || true
          alive=false
        fi

        if $alive; then
          # Polecat is running — check if it's been running too long (>30 min)
          local created_ts
          created_ts=$(date -d "$p_created" +%s 2>/dev/null || echo "0")
          local age=$(( now - created_ts ))
          if [[ "$age" -gt 1800 ]]; then
            echo "[witness/$rig] $pname has been running for $((age/60))m — still alive"
            log_event "WITNESS_LONG_RUNNING $pname age=${age}s"
          fi
        fi
      fi

      if ! $alive; then
        # Polecat session is dead — check what happened
        local pr_state pr_number
        pr_state=$(gh pr list --repo "$p_repo" --head "$p_branch" --json state,number --jq '.[0].state' 2>/dev/null || true)
        pr_number=$(gh pr list --repo "$p_repo" --head "$p_branch" --json number --jq '.[0].number' 2>/dev/null || true)

        if [[ "$pr_state" == "OPEN" ]]; then
          # PR is open — send to merge queue for refinery (refinery reviews + merges)
          echo "[witness/$rig] $pname completed — PR #$pr_number OPEN, queuing for refinery"
          log_event "WITNESS_PR_READY $pname pr=#$pr_number"

          mkdir -p "$SGT_CONFIG/merge-queue"
          local pr_head_sha
          pr_head_sha="$(_pr_head_sha "$p_repo" "$pr_number")"
          cat > "$SGT_CONFIG/merge-queue/$pname" <<MQSTATE
POLECAT=$pname
RIG=$rig
REPO=$p_repo
BRANCH=$p_branch
ISSUE=$p_issue
PR=$pr_number
HEAD_SHA=$pr_head_sha
AUTO_MERGE=$p_auto_merge
BACKEND=${BACKEND:-$(_ai_backend_default)}
TYPE=polecat
QUEUED=$(date -Iseconds)
MQSTATE

          _wake_refinery "$rig" "pr-ready:$pname:#$pr_number"

          # Clean up polecat worktree + state
          if [[ -d "$p_worktree" ]]; then
            local rpath
            rpath="$(rig_path "$rig")"
            git -C "$rpath" worktree remove --force "$p_worktree" 2>/dev/null || rm -rf "$p_worktree"
          fi
          rm -f "$f"

        elif [[ "$pr_state" == "MERGED" ]]; then
          # Already merged — just clean up
          echo "[witness/$rig] $pname already merged — cleaning up"
          log_event "WITNESS_MERGED $pname"
          if [[ -d "$p_worktree" ]]; then
            local rpath
            rpath="$(rig_path "$rig")"
            git -C "$rpath" worktree remove --force "$p_worktree" 2>/dev/null || rm -rf "$p_worktree"
          fi
          git -C "$(rig_path "$rig")" push origin --delete "$p_branch" 2>/dev/null || true
          rm -f "$f"

        else
          # Dead with no PR — stalled/zombie
          echo "[witness/$rig] $pname is STALLED (dead, no PR)"
          log_event "WITNESS_STALLED $pname issue=#$p_issue"
          _wake_refinery "$rig" "stalled:$pname:#$p_issue"

          # Comment on the issue about the stall
          gh issue comment "$p_issue" --repo "$p_repo" \
            --body "[sgt-witness] Polecat \`$pname\` stalled — session died without opening a PR. Cleaning up and re-slinging." 2>/dev/null || true

          # Clean up the dead polecat
          if [[ -d "$p_worktree" ]]; then
            local rpath
            rpath="$(rig_path "$rig")"
            git -C "$rpath" worktree remove --force "$p_worktree" 2>/dev/null || rm -rf "$p_worktree"
          fi
          git -C "$(rig_path "$rig")" push origin --delete "$p_branch" 2>/dev/null || true
          rm -f "$f"

          # Re-sling: get the issue title and re-dispatch
          local issue_title
          issue_title=$(gh issue view "$p_issue" --repo "$p_repo" --json title --jq '.title' 2>/dev/null || true)
          if [[ -n "$issue_title" ]]; then
            echo "[witness/$rig] re-slinging issue #$p_issue: $issue_title"
            log_event "WITNESS_RESLING $pname issue=#$p_issue"

            # Re-sling with a new polecat (reuse existing issue — don't create a new one)
            _resling_existing_issue "$rig" "$p_issue" "$issue_title" "$p_repo"
          fi
        fi
      fi
    done

    # ── Orphaned PR scan ──
    # Catch PRs on sgt/* branches that have no polecat state file
    # (e.g., polecat completed and was swept before witness could queue it)
    local orphan_prs
    orphan_prs=$(gh pr list --repo "$repo" --json number,headRefName,state \
      --jq '.[] | select(.headRefName | startswith("sgt/")) | "\(.number) \(.headRefName)"' 2>/dev/null || true)

    if [[ -n "$orphan_prs" ]]; then
      while IFS=' ' read -r pr_num pr_branch; do
        [[ -n "$pr_num" ]] || continue

        # Check if any polecat state file references this branch
        local tracked=false
        for pf in "$SGT_POLECATS"/${rig}-*; do
          [[ -f "$pf" ]] || continue
          if grep -q "BRANCH=$pr_branch" "$pf" 2>/dev/null; then
            tracked=true
            break
          fi
        done

        # Check if already in merge queue
        if [[ "$tracked" == "false" ]]; then
          for mqf in "$SGT_CONFIG/merge-queue"/${rig}-*; do
            [[ -f "$mqf" ]] || continue
            if grep -q "BRANCH=$pr_branch" "$mqf" 2>/dev/null; then
              tracked=true
              break
            fi
          done
        fi

        if [[ "$tracked" == "false" ]]; then
          local orphan_pname="${pr_branch#sgt/}"
          local orphan_issue
          orphan_issue=$(gh pr view "$pr_num" --repo "$repo" --json body --jq '.body' 2>/dev/null | grep -oP 'Closes #\K[0-9]+' || true)

          # Security gate: only queue if linked issue has sgt-authorized label
          if [[ -z "$orphan_issue" || "$orphan_issue" == "0" ]]; then
            echo "[witness/$rig] orphaned PR #$pr_num has no linked issue — skipping (unauthorized)"
            log_event "WITNESS_ORPHAN_SKIP_NO_ISSUE pr=#$pr_num branch=$pr_branch"
            continue
          fi

          if ! _has_sgt_authorized "$repo" "$orphan_issue"; then
            echo "[witness/$rig] orphaned PR #$pr_num linked issue #$orphan_issue lacks sgt-authorized label — skipping"
            log_event "WITNESS_ORPHAN_SKIP_UNAUTHORIZED pr=#$pr_num issue=#$orphan_issue"
            continue
          fi

          echo "[witness/$rig] orphaned PR #$pr_num on branch $pr_branch — queuing for refinery"
          log_event "WITNESS_ORPHAN_PR pr=#$pr_num branch=$pr_branch"

          mkdir -p "$SGT_CONFIG/merge-queue"
          local orphan_head_sha
          orphan_head_sha="$(_pr_head_sha "$repo" "$pr_num")"
          cat > "$SGT_CONFIG/merge-queue/$orphan_pname" <<MQSTATE
POLECAT=$orphan_pname
RIG=$rig
REPO=$repo
BRANCH=$pr_branch
ISSUE=${orphan_issue:-0}
PR=$pr_num
HEAD_SHA=$orphan_head_sha
AUTO_MERGE=true
TYPE=polecat
QUEUED=$(date -Iseconds)
MQSTATE

          _wake_refinery "$rig" "orphan-pr:$orphan_pname:#$pr_num"
        fi
      done <<< "$orphan_prs"
    fi

    sleep 30
  done
}

# Re-sling an existing issue (don't create a new one)
_resling_existing_issue() {
  local rig="$1" issue_number="$2" task="$3" repo="$4"
  local backend="${5:-$(_ai_backend_default)}"

  # Security gate: verify issue has sgt-authorized label
  if ! _has_sgt_authorized "$repo" "$issue_number"; then
    echo "[resling] issue #$issue_number lacks sgt-authorized label — skipping"
    log_event "RESLING_SKIP_UNAUTHORIZED issue=#$issue_number rig=$rig"
    return 1
  fi

  local rpath pname branch session_name
  rpath="$(rig_path "$rig")"
  pname="$(polecat_name "$rig")"
  branch="sgt/${pname}"
  session_name="sgt-${pname}"

  git -C "$rpath" fetch origin 2>/dev/null || true
  local default_branch
  default_branch=$(git -C "$rpath" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's|refs/remotes/origin/||' || echo "main")

  local worktree="$SGT_ROOT/polecats/$pname"
  mkdir -p "$SGT_ROOT/polecats"
  git -C "$rpath" worktree add -b "$branch" "$worktree" "origin/$default_branch" 2>/dev/null \
    || git -C "$rpath" worktree add -b "$branch" "$worktree" "$default_branch"

  if [[ -f "$rpath/CLAUDE.md" ]]; then
    cp "$rpath/CLAUDE.md" "$worktree/CLAUDE.md"
  fi
  _write_polecat_claude_md "$worktree" "$issue_number" "$task" "$repo" "$pname" "$branch" "$default_branch" "false"

  cat > "$SGT_POLECATS/$pname" <<PSTATE
RIG=$rig
REPO=$repo
ISSUE=$issue_number
ISSUE_URL=https://github.com/${repo#https://github.com/}/issues/$issue_number
BRANCH=$branch
WORKTREE=$worktree
SESSION=$session_name
DEFAULT_BRANCH=$default_branch
AUTO_MERGE=false
BACKEND=$backend
CREATED=$(date -Iseconds)
STATUS=running
PSTATE

  tmux new-session -d -s "$session_name" -c "$worktree" \
    "$( _ai_cmd "$backend" "Read the CLAUDE.md in this directory. Your task is described in GitHub issue #${issue_number}. The issue title is: ${task}. Work on branch ${branch}. When done, commit your changes, push the branch, and open a PR that closes #${issue_number}." ); echo '[SGT] polecat exited'; sgt _wake-refinery '${rig}' 'polecat-done:${pname}:#${issue_number}' 2>/dev/null"

  log_event "RESLING $pname rig=$rig issue=#$issue_number branch=$branch"
}

cmd_witness_start() {
  local rig="${1:-}"
  [[ -n "$rig" ]] || die "usage: sgt witness start <rig>"
  ensure_init
  ensure_rig "$rig"

  local session="sgt-witness-${rig}"
  if tmux has-session -t "$session" 2>/dev/null; then
    info "witness/$rig already running"
    return
  fi

  tmux new-session -d -s "$session" \
    "SGT_ROOT='$SGT_ROOT' sgt _witness '$rig'"

  log_event "WITNESS_SPAWN rig=$rig"
  info "witness/$rig started (session: $session)"
}

cmd_witness_stop() {
  local rig="${1:-}"
  [[ -n "$rig" ]] || die "usage: sgt witness stop <rig>"

  local session="sgt-witness-${rig}"
  if tmux has-session -t "$session" 2>/dev/null; then
    tmux kill-session -t "$session"
    log_event "WITNESS_STOP rig=$rig"
    info "witness/$rig stopped"
  else
    info "witness/$rig not running"
  fi
}

# ─── Refinery (per-rig review + merge processor) ─────────────────────
#
# The Refinery is the quality gate for all worker output:
# - Workers (polecats/dogs) notify the refinery when done
# - Refinery reviews PR diffs (polecats) or issue comments (dogs) via AI
# - On PASS: merges PR / closes issue, notifies mayor
# - On REJECT: closes PR / reopens issue, dispatches second iteration with feedback
# - No mayor involvement on rejections — refinery handles rework autonomously

# AI review: check PR diff against issue spec
_refinery_review_pr() {
  local repo="$1" pr="$2" issue="$3" rig="$4" backend="$5"
  local owner_repo pr_url issue_url
  owner_repo="$(_repo_owner_repo "$repo")"
  pr_url="$(_repo_pr_url "$repo" "$pr")"
  issue_url="$(_repo_issue_url "$repo" "$issue")"

  echo "[refinery/$rig] reviewing PR #$pr..."

  local diff
  diff=$(gh pr diff "$pr" --repo "$repo" 2>/dev/null || true)
  if [[ -z "$diff" ]]; then
    echo "[refinery/$rig] PR #$pr — no diff, skipping review"
    return 0  # treat as pass (merged/closed already)
  fi

  local issue_title="" issue_body=""
  if [[ "$issue" != "0" && -n "$issue" ]]; then
    issue_title=$(gh issue view "$issue" --repo "$repo" --json title --jq '.title' 2>/dev/null || true)
    issue_body=$(gh issue view "$issue" --repo "$repo" --json body --jq '.body' 2>/dev/null || true)
  fi

  local pr_title pr_body pr_title_field
  pr_title=$(gh pr view "$pr" --repo "$repo" --json title --jq '.title' 2>/dev/null || true)
  pr_body=$(gh pr view "$pr" --repo "$repo" --json body --jq '.body' 2>/dev/null || true)
  pr_title_field="$(_escape_quotes "$pr_title")"

  # Truncate diff if too large
  local diff_truncated="$diff"
  local diff_lines
  diff_lines=$(echo "$diff" | wc -l)
  if [[ "$diff_lines" -gt 500 ]]; then
    diff_truncated="$(echo "$diff" | head -500)"
    diff_truncated+=$'\n\n[... truncated, '"$diff_lines"' total lines ...]'
  fi

  local review_dir="$SGT_CONFIG/refinery-review"
  mkdir -p "$review_dir"

  cat > "$review_dir/review-prompt.md" <<REVIEWMD
# PR Review

Review this PR for completeness. Does it implement what the issue requested?

## Issue #$issue
**Title:** $issue_title
**Description:** $issue_body

## PR #$pr
**Title:** $pr_title
**Body:** $pr_body

## Diff
\`\`\`diff
$diff_truncated
\`\`\`

## Verdict

End with exactly one of:
- VERDICT: APPROVE — if complete and functional
- VERDICT: REJECT — if incomplete, stub, or doesn't match spec

If rejecting, explain what's missing in 2-3 sentences before the verdict.
REVIEWMD

  local review_output
  review_output=$(timeout 180 bash -c "_ai_promptfile '$backend' '$review_dir' '$review_dir/review-prompt.md'" 2>/dev/null || true)

  if echo "$review_output" | grep -q "VERDICT: APPROVE"; then
    echo "[refinery/$rig] PR #$pr APPROVED"
    log_event "REFINERY_REVIEW_APPROVED pr=#$pr"
    _notify_openclaw "[SGT Refinery] review approved rig=$rig repo=$owner_repo pr=#$pr title=\"$pr_title_field\" issue=#$issue pr_url=$pr_url issue_url=$issue_url"
    gh pr comment "$pr" --repo "$repo" \
      --body "[sgt-refinery] **APPROVED** — reviewed and cleared for merge." 2>/dev/null || true
    return 0
  elif echo "$review_output" | grep -q "VERDICT: REJECT"; then
    local reject_reason
    reject_reason=$(echo "$review_output" | grep -B5 "VERDICT: REJECT" | grep -v "VERDICT:" | tail -3)
    echo "[refinery/$rig] PR #$pr REJECTED: $reject_reason"
    log_event "REFINERY_REVIEW_REJECTED pr=#$pr reason=$reject_reason"
    local reject_summary
    reject_summary=$(echo "$reject_reason" | tr '\n' ' ' | sed -E 's/[[:space:]]+/ /g' | cut -c1-160)
    _notify_openclaw "[SGT Refinery] review rejected rig=$rig pr=#$pr issue=#$issue reason=$reject_summary"

    gh pr comment "$pr" --repo "$repo" \
      --body "[sgt-refinery] **REJECTED** — Implementation incomplete.

**Feedback:** $reject_reason

Closing PR and dispatching rework." 2>/dev/null || true
    # Return 1 = rejected, caller handles rework
    REFINERY_REJECT_REASON="$reject_reason"
    return 1
  else
    echo "[refinery/$rig] PR #$pr — review inconclusive, treating as APPROVE"
    log_event "REFINERY_REVIEW_UNCLEAR pr=#$pr"
    return 0
  fi
}

# AI review: check dog output quality against issue spec
_refinery_review_dog() {
  local repo="$1" issue="$2" rig="$3" dname="$4" backend="$5"

  echo "[refinery/$rig] reviewing dog $dname output on issue #$issue..."

  local issue_title issue_body
  issue_title=$(gh issue view "$issue" --repo "$repo" --json title --jq '.title' 2>/dev/null || true)
  issue_body=$(gh issue view "$issue" --repo "$repo" --json body --jq '.body' 2>/dev/null || true)

  # Get the dog's posted comments
  local comments
  comments=$(gh issue view "$issue" --repo "$repo" --json comments \
    --jq '[.comments[] | select(.author.login != "github-actions[bot]")] | .[-3:] | .[].body' 2>/dev/null || true)

  if [[ -z "$comments" ]]; then
    echo "[refinery/$rig] dog $dname — no comments posted, treating as incomplete"
    REFINERY_REJECT_REASON="Dog posted no findings to the issue."
    return 1
  fi

  # Truncate if too large
  local comments_truncated="$comments"
  local comment_lines
  comment_lines=$(echo "$comments" | wc -l)
  if [[ "$comment_lines" -gt 300 ]]; then
    comments_truncated="$(echo "$comments" | head -300)"
    comments_truncated+=$'\n\n[... truncated ...]'
  fi

  local review_dir="$SGT_CONFIG/refinery-review"
  mkdir -p "$review_dir"

  cat > "$review_dir/dog-review-prompt.md" <<REVIEWMD
# Dog Output Review

Review whether this research/analysis task was completed thoroughly.

## Task (Issue #$issue)
**Title:** $issue_title
**Description:** $issue_body

## Dog Output (issue comments)
$comments_truncated

## Verdict

End with exactly one of:
- VERDICT: APPROVE — if research is thorough and addresses the task
- VERDICT: REJECT — if output is thin, off-topic, or missing key deliverables

If rejecting, explain what's missing in 2-3 sentences before the verdict.
REVIEWMD

  local review_output
  review_output=$(timeout 180 bash -c "_ai_promptfile '$backend' '$review_dir' '$review_dir/dog-review-prompt.md'" 2>/dev/null || true)

  if echo "$review_output" | grep -q "VERDICT: APPROVE"; then
    echo "[refinery/$rig] dog $dname APPROVED"
    log_event "REFINERY_DOG_APPROVED dog=$dname issue=#$issue"
    gh issue comment "$issue" --repo "$repo" \
      --body "[sgt-refinery] **APPROVED** — research output reviewed and accepted." 2>/dev/null || true
    return 0
  elif echo "$review_output" | grep -q "VERDICT: REJECT"; then
    local reject_reason
    reject_reason=$(echo "$review_output" | grep -B5 "VERDICT: REJECT" | grep -v "VERDICT:" | tail -3)
    echo "[refinery/$rig] dog $dname REJECTED: $reject_reason"
    log_event "REFINERY_DOG_REJECTED dog=$dname issue=#$issue reason=$reject_reason"
    gh issue comment "$issue" --repo "$repo" \
      --body "[sgt-refinery] **REJECTED** — Research output insufficient.

**Feedback:** $reject_reason

Dispatching second iteration." 2>/dev/null || true
    REFINERY_REJECT_REASON="$reject_reason"
    return 1
  else
    echo "[refinery/$rig] dog $dname — review inconclusive, treating as APPROVE"
    log_event "REFINERY_DOG_REVIEW_UNCLEAR dog=$dname issue=#$issue"
    return 0
  fi
}

_refinery_loop() {
  local rig="$1"
  local repo
  repo="$(rig_repo "$rig")"

  log_event "REFINERY_START rig=$rig"

  # Set up FIFO for event-driven wake
  local fifo="$SGT_CONFIG/refinery-${rig}.fifo"
  [[ -p "$fifo" ]] || mkfifo "$fifo"
  exec 4<>"$fifo"
  echo "[refinery/$rig] started — event-driven (fallback every 30s)"

  while true; do
    # Block on FIFO with timeout — wakes on event OR periodic scan
    local wake_reason=""
    read -t 30 -u 4 wake_reason 2>/dev/null || true
    if [[ -n "$wake_reason" ]]; then
      echo "[refinery/$rig] woken: $wake_reason"
      # Drain queued events
      local extra=""
      while read -t 0.1 -u 4 extra 2>/dev/null; do :; done
    fi

    local merge_dir="$SGT_CONFIG/merge-queue"
    mkdir -p "$merge_dir"

    # ── Process PR queue (polecats) ──
    for f in "$merge_dir"/${rig}-*; do
      [[ -f "$f" ]] || continue
      local mqname
      mqname="$(basename "$f")"

      local mq_pr="" mq_repo="" mq_branch="" mq_issue="" mq_polecat="" mq_auto_merge="" mq_type="" mq_backend="" mq_head_sha=""
      eval "$(grep -E '^(PR|REPO|BRANCH|ISSUE|POLECAT|AUTO_MERGE|TYPE|BACKEND|HEAD_SHA)=' "$f")"
      mq_pr="${PR:-}"
      mq_repo="${REPO:-$repo}"
      mq_branch="${BRANCH:-}"
      mq_issue="${ISSUE:-0}"
      mq_polecat="${POLECAT:-$mqname}"
      mq_auto_merge="${AUTO_MERGE:-false}"
      mq_type="${TYPE:-polecat}"
      mq_backend="${BACKEND:-$(_ai_backend_default)}"
      mq_head_sha="${HEAD_SHA:-}"

      echo "[refinery/$rig] processing $mq_type: PR #$mq_pr ($mq_branch)"
      local mq_owner_repo mq_pr_title mq_pr_title_field mq_pr_url mq_issue_url mq_wake_title
      mq_owner_repo="$(_repo_owner_repo "$mq_repo")"
      mq_pr_title=$(gh pr view "$mq_pr" --repo "$mq_repo" --json title --jq '.title' 2>/dev/null || true)
      mq_pr_title_field="$(_escape_quotes "$mq_pr_title")"
      mq_pr_url="$(_repo_pr_url "$mq_repo" "$mq_pr")"
      mq_issue_url="$(_repo_issue_url "$mq_repo" "$mq_issue")"
      mq_wake_title="$(_escape_wake_value "$mq_pr_title")"

      # Security gate: verify linked issue has sgt-authorized label
      if [[ -n "$mq_issue" && "$mq_issue" != "0" ]]; then
        if ! _has_sgt_authorized "$mq_repo" "$mq_issue"; then
          echo "[refinery/$rig] PR #$mq_pr linked issue #$mq_issue lacks sgt-authorized — skipping"
          log_event "REFINERY_SKIP_UNAUTHORIZED pr=#$mq_pr issue=#$mq_issue"
          rm -f "$f"
          continue
        fi
      else
        echo "[refinery/$rig] PR #$mq_pr has no linked issue — skipping (unauthorized)"
        log_event "REFINERY_SKIP_NO_ISSUE pr=#$mq_pr"
        rm -f "$f"
        continue
      fi

      # Check PR state
      local pr_state
      pr_state=$(gh pr view "$mq_pr" --repo "$mq_repo" --json state --jq '.state' 2>/dev/null || true)

      if [[ "$pr_state" == "MERGED" ]]; then
        echo "[refinery/$rig] PR #$mq_pr already merged — cleaning up"
        git -C "$(rig_path "$rig")" push origin --delete "$mq_branch" 2>/dev/null || true
        rm -f "$f"
        log_event "REFINERY_ALREADY_MERGED pr=#$mq_pr"
        continue
      fi

      if [[ "$pr_state" == "CLOSED" ]]; then
        echo "[refinery/$rig] PR #$mq_pr was closed — removing from queue"
        rm -f "$f"
        log_event "REFINERY_CLOSED pr=#$mq_pr"
        continue
      fi

      if [[ "$pr_state" != "OPEN" ]]; then
        echo "[refinery/$rig] PR #$mq_pr state unknown: $pr_state — skipping"
        continue
      fi

      # Check CI
      local check_status
      check_status=$(gh pr checks "$mq_pr" --repo "$mq_repo" 2>&1 || true)
      if echo "$check_status" | grep -qiE "fail|error"; then
        echo "[refinery/$rig] PR #$mq_pr — CI failing, waiting..."
        continue
      fi

      # Check mergeability
      local pr_mergeable
      pr_mergeable=$(gh pr view "$mq_pr" --repo "$mq_repo" --json mergeable --jq '.mergeable' 2>/dev/null || true)
      if [[ "$pr_mergeable" == "CONFLICTING" ]]; then
        echo "[refinery/$rig] PR #$mq_pr has merge conflicts — requesting rework"
        log_event "REFINERY_CONFLICT pr=#$mq_pr"
        gh pr comment "$mq_pr" --repo "$mq_repo" \
          --body "[sgt-refinery] Merge conflict detected. Closing and re-dispatching." 2>/dev/null || true
        gh pr close "$mq_pr" --repo "$mq_repo" 2>/dev/null || true
        rm -f "$f"
        # Re-sling
        if [[ "$mq_issue" != "0" && -n "$mq_issue" ]]; then
          gh issue reopen "$mq_issue" --repo "$mq_repo" 2>/dev/null || true
          gh issue comment "$mq_issue" --repo "$mq_repo" \
            --body "[sgt-refinery] Merge conflict on PR #$mq_pr. Re-dispatching." 2>/dev/null || true
          local issue_title_resling
          issue_title_resling=$(gh issue view "$mq_issue" --repo "$mq_repo" --json title --jq '.title' 2>/dev/null || true)
          [[ -n "$issue_title_resling" ]] && _resling_existing_issue "$rig" "$mq_issue" "$issue_title_resling" "$mq_repo"
        fi
        continue
      fi

      # === AI REVIEW ===
      REFINERY_REJECT_REASON=""
      if _refinery_review_pr "$mq_repo" "$mq_pr" "$mq_issue" "$rig" "$mq_backend"; then
        # Revalidate immediately before merge to prevent stale queue merges.
        local live_snapshot live_state live_head_sha premerge_reason=""
        live_snapshot=$(gh pr view "$mq_pr" --repo "$mq_repo" --json state,headRefOid --jq '.state + "|" + (.headRefOid // "")' 2>/dev/null || true)
        if [[ -z "$live_snapshot" || "$live_snapshot" != *"|"* ]]; then
          premerge_reason="unable to query live PR state"
        else
          IFS='|' read -r live_state live_head_sha <<< "$live_snapshot"
          if [[ "$live_state" != "OPEN" ]]; then
            premerge_reason="pr state drifted to ${live_state:-unknown}"
          elif [[ -n "$mq_head_sha" && "$live_head_sha" != "$mq_head_sha" ]]; then
            premerge_reason="head sha drifted queued=${mq_head_sha:-unknown} live=${live_head_sha:-unknown}"
            _merge_queue_set_head_sha "$f" "$live_head_sha" || true
          fi
        fi
        if [[ -n "$premerge_reason" ]]; then
          echo "[refinery/$rig] PR #$mq_pr pre-merge revalidation drift — skipping ($premerge_reason)"
          log_event "REFINERY_PREMERGE_SKIP pr=#$mq_pr reason=\"$(_escape_quotes "$premerge_reason")\""
          continue
        fi

        # APPROVED — merge
        echo "[refinery/$rig] merging PR #$mq_pr..."
        local merge_result
        if merge_result=$(gh pr merge "$mq_pr" --repo "$mq_repo" --squash --delete-branch 2>&1); then
          echo "[refinery/$rig] PR #$mq_pr merged successfully"
          log_event "REFINERY_MERGED pr=#$mq_pr issue=#$mq_issue"
          _notify_openclaw "[SGT Refinery] merged rig=$rig repo=$mq_owner_repo pr=#$mq_pr title=\"$mq_pr_title_field\" issue=#$mq_issue pr_url=$mq_pr_url issue_url=$mq_issue_url"
          _wake_mayor "merged:pr#$mq_pr:#$mq_issue:$rig|repo=$mq_owner_repo|title=$mq_wake_title|pr_url=$mq_pr_url|issue_url=$mq_issue_url"
          rm -f "$f"
        else
          echo "[refinery/$rig] merge failed: $merge_result"
          log_event "REFINERY_MERGE_FAILED pr=#$mq_pr: $merge_result"
          gh pr comment "$mq_pr" --repo "$mq_repo" \
            --body "[sgt-refinery] Auto-merge failed: \`$merge_result\`" 2>/dev/null || true
        fi
      else
        # REJECTED — close PR, re-dispatch with feedback
        echo "[refinery/$rig] PR #$mq_pr rejected — dispatching rework"
        gh pr close "$mq_pr" --repo "$mq_repo" 2>/dev/null || true
        rm -f "$f"

        if [[ "$mq_issue" != "0" && -n "$mq_issue" ]]; then
          gh issue reopen "$mq_issue" --repo "$mq_repo" 2>/dev/null || true
          gh issue comment "$mq_issue" --repo "$mq_repo" \
            --body "[sgt-refinery] Previous attempt rejected. Feedback:

$REFINERY_REJECT_REASON

Please address the feedback in the next iteration." 2>/dev/null || true
          local issue_title_resling
          issue_title_resling=$(gh issue view "$mq_issue" --repo "$mq_repo" --json title --jq '.title' 2>/dev/null || true)
          if [[ -n "$issue_title_resling" ]]; then
            echo "[refinery/$rig] re-slinging issue #$mq_issue"
            _resling_existing_issue "$rig" "$mq_issue" "$issue_title_resling" "$mq_repo"
          fi
        fi
      fi
    done

    # ── Process dog queue (check for completed dogs) ──
    if [[ -d "$SGT_CONFIG/dogs" ]]; then
      for df in "$SGT_CONFIG/dogs"/*; do
        [[ -f "$df" ]] || continue
        local dname
        dname="$(basename "$df")"

        local d_session="" d_repo="" d_issue="" d_rig=""
        eval "$(grep -E '^(SESSION|REPO|ISSUE|RIG|BACKEND)=' "$df")"
        d_session="${SESSION:-}"
        d_repo="${REPO:-$repo}"
        d_issue="${ISSUE:-0}"
        d_rig="${RIG:-$rig}"
        local d_backend="${BACKEND:-$(_ai_backend_default)}"
        local d_owner_repo d_issue_title d_issue_url d_wake_title
        d_owner_repo="$(_repo_owner_repo "$d_repo")"
        d_issue_title=$(gh issue view "$d_issue" --repo "$d_repo" --json title --jq '.title' 2>/dev/null || true)
        d_issue_url="$(_repo_issue_url "$d_repo" "$d_issue")"
        d_wake_title="$(_escape_wake_value "$d_issue_title")"

        # Only process dogs for this rig
        [[ "$d_rig" == "$rig" ]] || continue

        # Check if dog is still alive
        if tmux has-session -t "$d_session" 2>/dev/null; then
          continue  # Still running
        fi

        echo "[refinery/$rig] dog $dname finished — reviewing output"

        # Security gate: verify dog's issue has sgt-authorized label
        if ! _has_sgt_authorized "$d_repo" "$d_issue"; then
          echo "[refinery/$rig] dog $dname issue #$d_issue lacks sgt-authorized — skipping"
          log_event "REFINERY_DOG_SKIP_UNAUTHORIZED dog=$dname issue=#$d_issue"
          rm -f "$df"
          continue
        fi

        REFINERY_REJECT_REASON=""
        if _refinery_review_dog "$d_repo" "$d_issue" "$rig" "$dname" "$d_backend"; then
          # APPROVED — close issue, notify mayor
          gh issue close "$d_issue" --repo "$d_repo" 2>/dev/null || true
          echo "[refinery/$rig] dog $dname approved and issue #$d_issue closed"
          log_event "REFINERY_DOG_COMPLETE dog=$dname issue=#$d_issue"
          _wake_mayor "dog-approved:$dname:#$d_issue:$rig|repo=$d_owner_repo|title=$d_wake_title|issue_url=$d_issue_url"
          # Clean up dog state + workspace
          local d_ws=""
          d_ws=$(grep '^WORKSPACE=' "$df" 2>/dev/null | cut -d= -f2)
          [[ -d "$d_ws" ]] && rm -rf "$d_ws"
          rm -f "$df"
        else
          # REJECTED — re-dispatch dog with feedback
          echo "[refinery/$rig] dog $dname rejected — dispatching second iteration"
          log_event "REFINERY_DOG_REWORK dog=$dname issue=#$d_issue"

          # Clean up old dog
          local d_ws=""
          d_ws=$(grep '^WORKSPACE=' "$df" 2>/dev/null | cut -d= -f2)
          [[ -d "$d_ws" ]] && rm -rf "$d_ws"
          rm -f "$df"

          # Re-dispatch dog on same issue
          local issue_title_dog
          issue_title_dog=$(gh issue view "$d_issue" --repo "$d_repo" --json title --jq '.title' 2>/dev/null || true)
          issue_title_dog="${issue_title_dog#\[Dog\] }"
          if [[ -n "$issue_title_dog" ]]; then
            local new_dname="dog-$(head -c4 /dev/urandom | xxd -p)"
            local new_session="sgt-${new_dname}"
            local dog_workspace="$SGT_ROOT/dogs/$new_dname"
            mkdir -p "$dog_workspace"

            cat > "$dog_workspace/CLAUDE.md" <<DOGMD
# Dog Task — $new_dname (REWORK)

You are a research/analysis agent. A previous attempt was insufficient.

## Task
$issue_title_dog

## Previous Feedback
$REFINERY_REJECT_REASON

## Instructions
1. Read the previous comments on issue #$d_issue for context
2. Address the feedback above
3. Post improved findings as a comment on issue #$d_issue:
   \`gh issue comment $d_issue --repo $d_repo --body "<your findings>"\`
4. Do NOT close the issue — the refinery will review again
5. Exit
DOGMD

            mkdir -p "$SGT_CONFIG/dogs"
            cat > "$SGT_CONFIG/dogs/$new_dname" <<DSTATE
RIG=$rig
REPO=$d_repo
ISSUE=$d_issue
SESSION=$new_session
WORKSPACE=$dog_workspace
CREATED=$(date -Iseconds)
STATUS=running
REWORK=true
DSTATE

            tmux new-session -d -s "$new_session" -c "$dog_workspace" \
              "$( _ai_cmd "$(_ai_backend_default)" "Read CLAUDE.md. This is a REWORK — previous attempt was rejected. Address the feedback and post improved findings." ); echo '[SGT] dog exited'; sgt _wake-refinery '${rig}' 'dog-done:${new_dname}:#${d_issue}' 2>/dev/null"

            echo "[refinery/$rig] re-dispatched dog $new_dname for issue #$d_issue"
            log_event "REFINERY_DOG_REWORK_DISPATCHED dog=$new_dname issue=#$d_issue"
          fi
        fi
      done
    fi
  done
}

cmd_refinery_start() {
  local rig="${1:-}"
  [[ -n "$rig" ]] || die "usage: sgt refinery start <rig>"
  ensure_init
  ensure_rig "$rig"

  local session="sgt-refinery-${rig}"
  if tmux has-session -t "$session" 2>/dev/null; then
    info "refinery/$rig already running"
    return
  fi

  mkdir -p "$SGT_CONFIG/merge-queue"
  local fifo="$SGT_CONFIG/refinery-${rig}.fifo"
  [[ -p "$fifo" ]] || mkfifo "$fifo"

  tmux new-session -d -s "$session" \
    "SGT_ROOT='$SGT_ROOT' sgt _refinery '$rig'"

  log_event "REFINERY_SPAWN rig=$rig"
  info "refinery/$rig started (session: $session)"
}

cmd_refinery_stop() {
  local rig="${1:-}"
  [[ -n "$rig" ]] || die "usage: sgt refinery stop <rig>"

  local session="sgt-refinery-${rig}"
  if tmux has-session -t "$session" 2>/dev/null; then
    tmux kill-session -t "$session"
    log_event "REFINERY_STOP rig=$rig"
    info "refinery/$rig stopped"
  else
    info "refinery/$rig not running"
  fi
}

# ─── Deacon (health monitor) ──────────────────────────────────────────
#
# The Deacon patrols the entire sgt system:
# - Checks that Witnesses are running for each rig
# - Checks that Refineries are running for each rig
# - Restarts dead agents
# - Writes heartbeat for Boot to check
# - Runs as a bash loop (no AI needed)

_deacon_loop() {
  log_event "DEACON_START"
  echo "[deacon] started — patrolling sgt system"
  local cycle=0

  while true; do
    cycle=$((cycle + 1))
    local now
    now=$(date -Iseconds)
    local actions=0

    # Write heartbeat
    cat > "$SGT_DEACON_HEARTBEAT" <<HEARTBEAT
{
  "timestamp": "$now",
  "cycle": $cycle,
  "pid": $$
}
HEARTBEAT

    echo "[deacon] patrol cycle $cycle at $now"

    # Ensure witnesses for all rigs
    for rig_file in "$SGT_RIGS"/*; do
      [[ -f "$rig_file" ]] || continue
      local rig_name
      rig_name="$(basename "$rig_file")"

      # Check witness
      if ! tmux has-session -t "sgt-witness-${rig_name}" 2>/dev/null; then
        echo "[deacon] witness/$rig_name is down — restarting"
        log_event "DEACON_RESTART_WITNESS rig=$rig_name"
        cmd_witness_start "$rig_name"
        actions=$((actions + 1))
      fi

      # Check refinery
      if ! tmux has-session -t "sgt-refinery-${rig_name}" 2>/dev/null; then
        echo "[deacon] refinery/$rig_name is down — restarting"
        log_event "DEACON_RESTART_REFINERY rig=$rig_name"
        cmd_refinery_start "$rig_name"
        actions=$((actions + 1))
      fi
    done

    # Check for orphaned polecats (no matching rig)
    for f in "$SGT_POLECATS"/*; do
      [[ -f "$f" ]] || continue
      local pname
      pname="$(basename "$f")"
      local p_rig
      p_rig=$(grep '^RIG=' "$f" | cut -d= -f2)
      if [[ ! -f "$SGT_RIGS/$p_rig" ]]; then
        echo "[deacon] orphaned polecat $pname (rig '$p_rig' no longer exists)"
        log_event "DEACON_ORPHAN $pname rig=$p_rig"
      fi
    done

    if [[ "$actions" -eq 0 ]]; then
      echo "[deacon] all agents healthy"
    else
      echo "[deacon] restarted $actions agent(s)"
    fi

    sleep 60
  done
}

cmd_deacon_start() {
  ensure_init

  local session="sgt-deacon"
  if tmux has-session -t "$session" 2>/dev/null; then
    info "deacon already running"
    return
  fi

  tmux new-session -d -s "$session" \
    "SGT_ROOT='$SGT_ROOT' sgt _deacon"

  log_event "DEACON_SPAWN"
  info "deacon started (session: $session)"
}

cmd_deacon_stop() {
  local session="sgt-deacon"
  if tmux has-session -t "$session" 2>/dev/null; then
    tmux kill-session -t "$session"
    log_event "DEACON_STOP"
    info "deacon stopped"
  else
    info "deacon not running"
  fi
}

# ─── Boot (ephemeral deacon triage) ──────────────────────────────────
#
# Boot is a quick check: is the Deacon alive?
# If deacon heartbeat is stale (>5 min), restart it.
# Runs once and exits — called by the Daemon every tick.

_boot_check() {
  if ! tmux has-session -t "sgt-deacon" 2>/dev/null; then
    echo "[boot] deacon session missing — restarting"
    log_event "BOOT_RESTART_DEACON reason=session_missing"
    cmd_deacon_start
    return
  fi

  if [[ ! -f "$SGT_DEACON_HEARTBEAT" ]]; then
    echo "[boot] no deacon heartbeat file — restarting"
    log_event "BOOT_RESTART_DEACON reason=no_heartbeat"
    tmux kill-session -t "sgt-deacon" 2>/dev/null || true
    cmd_deacon_start
    return
  fi

  local last_ts
  last_ts=$(python3 -c "
import json, sys, datetime
d = json.load(open('$SGT_DEACON_HEARTBEAT'))
ts = d.get('timestamp', '')
try:
    dt = datetime.datetime.fromisoformat(ts)
    print(int(dt.timestamp()))
except:
    print(0)
" 2>/dev/null || echo "0")

  local now
  now=$(date +%s)
  local age=$((now - last_ts))

  if [[ "$age" -gt 300 ]]; then
    echo "[boot] deacon heartbeat stale (${age}s) — restarting"
    log_event "BOOT_RESTART_DEACON reason=stale_heartbeat age=${age}s"
    tmux kill-session -t "sgt-deacon" 2>/dev/null || true
    cmd_deacon_start
  else
    echo "[boot] deacon healthy (heartbeat ${age}s ago)"
  fi
}

# ─── Daemon (mechanical watchdog) ─────────────────────────────────────
#
# The Daemon is the outermost loop — pure bash, no AI:
# - Runs every SGT_DAEMON_INTERVAL seconds (default 3 min)
# - Calls Boot to check Deacon
# - Writes its own PID for management
# - Can be stopped with: sgt daemon stop

_daemon_loop() {
  local pid=$$
  echo "$pid" > "$SGT_DAEMON_PID"
  log_event "DAEMON_START pid=$pid interval=${SGT_DAEMON_INTERVAL}s"
  echo "[daemon] started (pid $pid, interval ${SGT_DAEMON_INTERVAL}s)"

  # Acquire lock
  exec 200>"$SGT_DAEMON_LOCK"
  if ! flock -n 200; then
    die "another daemon is already running"
  fi

  trap '_daemon_cleanup' EXIT INT TERM

  while true; do
    echo "[daemon] tick at $(date -Iseconds)"

    # Run Boot check
    _boot_check

    sleep "$SGT_DAEMON_INTERVAL"
  done
}

_daemon_cleanup() {
  rm -f "$SGT_DAEMON_PID"
  log_event "DAEMON_STOP"
  echo "[daemon] stopped"
}

cmd_daemon_start() {
  ensure_init

  if [[ -f "$SGT_DAEMON_PID" ]] && kill -0 "$(cat "$SGT_DAEMON_PID")" 2>/dev/null; then
    info "daemon already running (pid $(cat "$SGT_DAEMON_PID"))"
    return
  fi

  # Start in background tmux session
  tmux new-session -d -s "sgt-daemon" \
    "SGT_ROOT='$SGT_ROOT' SGT_DAEMON_INTERVAL='$SGT_DAEMON_INTERVAL' sgt _daemon"

  info "daemon started in tmux session sgt-daemon"
}

cmd_daemon_stop() {
  if [[ -f "$SGT_DAEMON_PID" ]]; then
    local pid
    pid=$(cat "$SGT_DAEMON_PID")
    if kill -0 "$pid" 2>/dev/null; then
      # Kill the tmux session which will trigger cleanup
      tmux kill-session -t "sgt-daemon" 2>/dev/null || kill "$pid" 2>/dev/null || true
      rm -f "$SGT_DAEMON_PID"
      info "daemon stopped"
    else
      rm -f "$SGT_DAEMON_PID"
      info "daemon was not running (stale pid)"
    fi
  else
    # Try killing tmux session directly
    if tmux has-session -t "sgt-daemon" 2>/dev/null; then
      tmux kill-session -t "sgt-daemon"
      info "daemon stopped"
    else
      info "daemon not running"
    fi
  fi
}

cmd_daemon_status() {
  if [[ -f "$SGT_DAEMON_PID" ]] && kill -0 "$(cat "$SGT_DAEMON_PID")" 2>/dev/null; then
    info "daemon running (pid $(cat "$SGT_DAEMON_PID"))"
  else
    info "daemon not running"
  fi
}

# ═══════════════════════════════════════════════════════════════════════
# MAYOR — AI-powered global coordinator
# ═══════════════════════════════════════════════════════════════════════
#
# The Mayor is the brain of SGT. Unlike other agents (pure bash loops),
# the Mayor runs Claude Code periodically to make strategic decisions:
# - Cross-rig coordination (dependencies between issues)
# - Re-prioritize stalled work
# - Dispatch new tasks from a backlog
# - Escalation decisions
# - System health analysis
#
# Runs in tmux, wakes every SGT_MAYOR_INTERVAL seconds.

_mayor_build_briefing() {
  local briefing="$SGT_CONFIG/mayor-briefing.md"

  cat > "$briefing" <<'HEADER'
# SGT System Briefing

You are the Mayor — the global coordinator for SGT (Simple GitHub Gastown).
Review this briefing and take action.

HEADER

  # System status
  echo "## System Status" >> "$briefing"
  echo '```' >> "$briefing"
  cmd_status 2>&1 >> "$briefing"
  echo '```' >> "$briefing"
  echo "" >> "$briefing"

  # Recent log
  echo "## Recent Activity (last 30 events)" >> "$briefing"
  echo '```' >> "$briefing"
  tail -30 "$SGT_LOG" 2>/dev/null >> "$briefing" || echo "no log" >> "$briefing"
  echo '```' >> "$briefing"
  echo "" >> "$briefing"

  # Merge queue (refinery handles review + merge)
  echo "## Merge Queue (pending refinery review + merge)" >> "$briefing"
  local mq_count=0
  if [[ -d "$SGT_CONFIG/merge-queue" ]]; then
    for mqf in "$SGT_CONFIG/merge-queue"/*; do
      [[ -f "$mqf" ]] || continue
      mq_count=$((mq_count + 1))
      echo "- $(basename "$mqf"): $(grep '^PR=' "$mqf" | cut -d= -f2)" >> "$briefing"
    done
  fi
  [[ "$mq_count" -eq 0 ]] && echo "Empty" >> "$briefing"
  echo "" >> "$briefing"

  # Open issues across all rigs (sgt-authorized only)
  echo "## Open Issues (all rigs, sgt-authorized)" >> "$briefing"
  for rig_file in "$SGT_RIGS"/*; do
    [[ -f "$rig_file" ]] || continue
    local rname repo
    rname="$(basename "$rig_file")"
    repo="$(cat "$rig_file")"
    echo "### $rname ($repo)" >> "$briefing"
    gh issue list --repo "$repo" --state open --label "sgt-authorized" --json number,title,labels,milestone \
      --jq '.[] | "- #\(.number): \(.title) [\(.labels | map(.name) | join(","))] \(if .milestone then "(" + .milestone.title + ")" else "" end)"' \
      2>/dev/null >> "$briefing" || echo "  (couldn't fetch)" >> "$briefing"
    echo "" >> "$briefing"
  done

  # Open PRs across all rigs
  echo "## Open PRs (all rigs)" >> "$briefing"
  for rig_file in "$SGT_RIGS"/*; do
    [[ -f "$rig_file" ]] || continue
    local rname repo
    rname="$(basename "$rig_file")"
    repo="$(cat "$rig_file")"
    echo "### $rname" >> "$briefing"
    gh pr list --repo "$repo" --state open --json number,title,headRefName,mergeable \
      --jq '.[] | "- PR #\(.number): \(.title) [\(.headRefName)] mergeable=\(.mergeable)"' \
      2>/dev/null >> "$briefing" || echo "  (couldn't fetch)" >> "$briefing"
    echo "" >> "$briefing"
  done

  # Escalation config
  if [[ -f "$SGT_ESCALATION" ]]; then
    echo "## Escalation Rules" >> "$briefing"
    echo '```json' >> "$briefing"
    cat "$SGT_ESCALATION" >> "$briefing"
    echo '```' >> "$briefing"
    echo "" >> "$briefing"
  fi

  # Mayor history (last decisions)
  if [[ -f "$SGT_CONFIG/mayor-decisions.log" ]]; then
    echo "## Recent Mayor Decisions" >> "$briefing"
    echo '```' >> "$briefing"
    tail -20 "$SGT_CONFIG/mayor-decisions.log" >> "$briefing"
    echo '```' >> "$briefing"
    echo "" >> "$briefing"
  fi

  echo "$briefing"
}

_mayor_wake_summary() {
  local reason="$1"
  local summary=""

  if [[ -z "$reason" || "$reason" == "periodic" ]]; then
    echo ""
    return 0
  fi

  if [[ "$reason" =~ ^merged:pr#([0-9]+):#([0-9]+):([^|]+)\| ]]; then
    local pr issue rig repo title pr_url issue_url
    pr="${BASH_REMATCH[1]}"
    issue="${BASH_REMATCH[2]}"
    rig="${BASH_REMATCH[3]}"
    repo="$(_wake_field "$reason" "repo")"
    title="$(_escape_quotes "$(_wake_field "$reason" "title")")"
    pr_url="$(_wake_field "$reason" "pr_url")"
    issue_url="$(_wake_field "$reason" "issue_url")"
    summary="merged PR #$pr (issue #$issue, rig $rig) | rig=$rig repo=${repo:-unknown} pr=#$pr title=\"${title:-unknown}\" issue=#$issue pr_url=${pr_url:-unknown} issue_url=${issue_url:-unknown}"
  elif [[ "$reason" =~ ^merged:pr#([0-9]+):#([0-9]+):(.+)$ ]]; then
    summary="merged PR #${BASH_REMATCH[1]} (issue #${BASH_REMATCH[2]}, rig ${BASH_REMATCH[3]})"
  elif [[ "$reason" =~ ^merged:pr#([0-9]+):#([0-9]+)\| ]]; then
    local pr issue rig repo title pr_url issue_url
    pr="${BASH_REMATCH[1]}"
    issue="${BASH_REMATCH[2]}"
    rig="$(_wake_field "$reason" "rig")"
    repo="$(_wake_field "$reason" "repo")"
    title="$(_escape_quotes "$(_wake_field "$reason" "title")")"
    pr_url="$(_wake_field "$reason" "pr_url")"
    issue_url="$(_wake_field "$reason" "issue_url")"
    summary="merged PR #$pr (issue #$issue, rig ${rig:-unknown}) | rig=${rig:-unknown} repo=${repo:-unknown} pr=#$pr title=\"${title:-unknown}\" issue=#$issue pr_url=${pr_url:-unknown} issue_url=${issue_url:-unknown}"
  elif [[ "$reason" =~ ^merged:pr#([0-9]+):#([0-9]+)$ ]]; then
    summary="merged PR #${BASH_REMATCH[1]} (issue #${BASH_REMATCH[2]})"
  elif [[ "$reason" =~ ^dog-approved:([^:]+):#([0-9]+):([^|]+)\| ]]; then
    local dname issue rig repo title issue_url
    dname="${BASH_REMATCH[1]}"
    issue="${BASH_REMATCH[2]}"
    rig="${BASH_REMATCH[3]}"
    repo="$(_wake_field "$reason" "repo")"
    title="$(_escape_quotes "$(_wake_field "$reason" "title")")"
    issue_url="$(_wake_field "$reason" "issue_url")"
    summary="dog approved $dname (issue #$issue, rig $rig) | rig=$rig repo=${repo:-unknown} title=\"${title:-unknown}\" issue=#$issue issue_url=${issue_url:-unknown}"
  elif [[ "$reason" =~ ^dog-approved:([^:]+):#([0-9]+):(.+)$ ]]; then
    summary="dog approved ${BASH_REMATCH[1]} (issue #${BASH_REMATCH[2]}, rig ${BASH_REMATCH[3]})"
  elif [[ "$reason" =~ ^dog-approved:([^:]+):#([0-9]+)$ ]]; then
    summary="dog approved ${BASH_REMATCH[1]} (issue #${BASH_REMATCH[2]})"
  elif [[ "$reason" =~ ^orphan-pr:#([0-9]+):(.+)$ ]]; then
    summary="orphan PR #${BASH_REMATCH[1]} queued (rig ${BASH_REMATCH[2]})"
  elif [[ "$reason" =~ ^orphan-pr:#([0-9]+)$ ]]; then
    summary="orphan PR #${BASH_REMATCH[1]} queued"
  else
    summary="wake: $reason"
  fi

  echo "$summary"
}

_mayor_loop() {
  set +e  # Mayor loop must never exit on errors
  log_event "MAYOR_START"

  # Set up FIFO for event-driven wake
  [[ -p "$SGT_MAYOR_FIFO" ]] || mkfifo "$SGT_MAYOR_FIFO"
  # Open FIFO read-write on fd 3 to prevent blocking on open()
  exec 3<>"$SGT_MAYOR_FIFO"
  echo "[mayor] started — event-driven (fallback every ${SGT_MAYOR_INTERVAL}s)"

  while true; do
    # Block on fd 3 with timeout — wakes on event OR periodic check
    local wake_reason=""
    local wake_events=()
    local cycle_events=()
    read -t "$SGT_MAYOR_INTERVAL" -u 3 wake_reason 2>/dev/null || true
    if [[ -n "$wake_reason" ]]; then
      echo "[mayor] woken by event: $wake_reason"
      wake_events+=("$wake_reason")
      # Drain any queued events (coalesce rapid-fire wakes)
      local extra=""
      while read -t 0.1 -u 3 extra 2>/dev/null; do
        echo "[mayor] coalescing event: $extra"
        wake_events+=("$extra")
      done
      local deduped_event=""
      while IFS= read -r deduped_event; do
        [[ -n "$deduped_event" ]] || continue
        cycle_events+=("$deduped_event")
      done < <(_dedupe_wake_reasons "${wake_events[@]+"${wake_events[@]}"}")
      wake_reason="${cycle_events[0]}"
    else
      echo "[mayor] periodic check at $(date -Iseconds)"
      wake_reason="periodic"
    fi

    local needs_ai=false
    local issues_found=""
    local actions_taken=""
    local notify_rigger=""
    local ts
    ts="$(date '+%Y-%m-%d %H:%M:%S')"

    if [[ "$wake_reason" != "periodic" ]]; then
      local event_reason wake_summary
      for event_reason in "${cycle_events[@]+"${cycle_events[@]}"}"; do
        wake_summary=$(_mayor_wake_summary "$event_reason")
        if [[ -n "$wake_summary" ]]; then
          _mayor_notify_rigger "$wake_summary"
        fi
        # Trigger at most one AI dispatch decision per cycle, even if
        # merged/dog-approved wake events are replayed within that cycle.
        if _wake_requires_dispatch_decision "$event_reason"; then
          needs_ai=true
        fi
      done
    fi

    # === 1. Check agent health ===
    for agent in daemon deacon; do
      if ! tmux has-session -t "sgt-$agent" 2>/dev/null; then
        issues_found+="  - $agent is DOWN\n"
        echo "[mayor] restarting $agent..."
        sgt "$agent" start 2>/dev/null
        actions_taken+="  - restarted $agent\n"
      fi
    done

    # Check witnesses and refineries
    for rig_file in "$SGT_RIGS"/*; do
      [[ -f "$rig_file" ]] || continue
      local rname
      rname="$(basename "$rig_file")"
      if ! tmux has-session -t "sgt-witness-$rname" 2>/dev/null; then
        issues_found+="  - witness/$rname is DOWN\n"
        sgt witness start "$rname" 2>/dev/null
        actions_taken+="  - restarted witness/$rname\n"
      fi
      if ! tmux has-session -t "sgt-refinery-$rname" 2>/dev/null; then
        issues_found+="  - refinery/$rname is DOWN\n"
        sgt refinery start "$rname" 2>/dev/null
        actions_taken+="  - restarted refinery/$rname\n"
      fi
    done

    # === 2. Check merge queue (refinery handles review + merge) ===
    local mq_count=0
    if [[ -d "$SGT_CONFIG/merge-queue" ]]; then
      for mqf in "$SGT_CONFIG/merge-queue"/*; do
        [[ -f "$mqf" ]] || continue
        mq_count=$((mq_count + 1))
      done
    fi
    if [[ "$mq_count" -gt 0 ]]; then
      issues_found+="  - merge queue has $mq_count item(s)\n"
    fi

    # === 3. Check for stale polecats (running > 30min) ===
    for pf in "$SGT_CONFIG/polecats"/*; do
      [[ -f "$pf" ]] || continue
      local pname started_at now_epoch started_epoch age_min
      pname="$(basename "$pf")"
      started_at="$(grep '^STARTED=' "$pf" 2>/dev/null | cut -d= -f2)"
      if [[ -n "$started_at" ]]; then
        now_epoch=$(date +%s)
        started_epoch=$(date -d "$started_at" +%s 2>/dev/null || echo 0)
        if [[ "$started_epoch" -gt 0 ]]; then
          age_min=$(( (now_epoch - started_epoch) / 60 ))
          if [[ "$age_min" -gt 30 ]]; then
            issues_found+="  - polecat $pname running for ${age_min}m (stale?)\n"
            needs_ai=true
          fi
        fi
      fi
    done

    # === 4. Check for open issues with critical/high labels ===
    for rig_file in "$SGT_RIGS"/*; do
      [[ -f "$rig_file" ]] || continue
      local rname repo critical_issues
      rname="$(basename "$rig_file")"
      repo="$(cat "$rig_file")"
      critical_issues=$(
        {
          gh issue list --repo "$repo" --state open --label "sgt-authorized,critical" \
            --json number,title --jq '.[].title' 2>/dev/null
          gh issue list --repo "$repo" --state open --label "sgt-authorized,high" \
            --json number,title --jq '.[].title' 2>/dev/null
        } | sort -u | head -5
      )
      if [[ -n "$critical_issues" ]]; then
        issues_found+="  - critical/high issues on $rname:\n"
        while IFS= read -r line; do
          issues_found+="    - $line\n"
        done <<< "$critical_issues"
        needs_ai=true
      fi
    done

    # === 5. Check for orphaned PRs (open PRs on sgt/* branches with no polecat) ===
    for rig_file in "$SGT_RIGS"/*; do
      [[ -f "$rig_file" ]] || continue
      local rname repo
      rname="$(basename "$rig_file")"
      repo="$(cat "$rig_file")"
      local orphan_prs
      orphan_prs=$(gh pr list --repo "$repo" --state open \
        --json number,headRefName --jq '.[] | select(.headRefName | startswith("sgt/")) | "#\(.number) [\(.headRefName)]"' 2>/dev/null)
      if [[ -n "$orphan_prs" ]]; then
        while IFS= read -r pr_info; do
          local pr_branch
          pr_branch=$(echo "$pr_info" | grep -oP '\[.*?\]' | tr -d '[]')
          local has_polecat=false
          for pf in "$SGT_CONFIG/polecats"/*; do
            [[ -f "$pf" ]] || continue
            if grep -q "BRANCH=$pr_branch" "$pf" 2>/dev/null; then
              has_polecat=true
              break
            fi
          done
          if [[ "$has_polecat" == "false" ]]; then
            local pr_num
            pr_num=$(echo "$pr_info" | grep -oP '#\d+' | tr -d '#')

            # Security gate: check linked issue has sgt-authorized label
            local linked_issue
            linked_issue=$(gh pr view "$pr_num" --repo "$repo" --json body --jq '.body' 2>/dev/null | grep -oP 'Closes #\K[0-9]+' || true)
            if [[ -z "$linked_issue" || "$linked_issue" == "0" ]]; then
              echo "[mayor] orphaned PR #$pr_num has no linked issue — skipping (unauthorized)"
              log_event "MAYOR_ORPHAN_SKIP_NO_ISSUE pr=#$pr_num"
              continue
            fi
            if ! _has_sgt_authorized "$repo" "$linked_issue"; then
              echo "[mayor] orphaned PR #$pr_num linked issue #$linked_issue lacks sgt-authorized — skipping"
              log_event "MAYOR_ORPHAN_SKIP_UNAUTHORIZED pr=#$pr_num issue=#$linked_issue"
              continue
            fi

            local mergeable
            mergeable=$(gh pr view "$pr_num" --repo "$repo" --json mergeable --jq '.mergeable' 2>/dev/null)
            if [[ "$mergeable" == "MERGEABLE" ]]; then
              local mqf="$SGT_CONFIG/merge-queue/${rname}-pr${pr_num}"
              if [[ ! -f "$mqf" ]]; then
                mkdir -p "$SGT_CONFIG/merge-queue"
                local orphan_head_sha
                orphan_head_sha="$(_pr_head_sha "$repo" "$pr_num")"
                cat > "$mqf" <<MQORPHAN
RIG=$rname
REPO=$repo
PR=$pr_num
BRANCH=$pr_branch
ISSUE=${linked_issue}
HEAD_SHA=$orphan_head_sha
TYPE=polecat
AUTO_MERGE=true
QUEUED=$(date -Iseconds)
MQORPHAN
                actions_taken+="  - queued orphaned PR #$pr_num ($rname) for refinery\n"
                _wake_refinery "$rname" "orphan-pr:#$pr_num"
              fi
            fi
          fi
        done <<< "$orphan_prs"
      fi
    done

    # === Decision & Log ===
    if [[ -z "$issues_found" && -z "$actions_taken" ]]; then
      # Only log periodic all-clears, not event-triggered ones
      if [[ "$wake_reason" == "periodic" ]]; then
        echo "[$ts] all clear" >> "$SGT_CONFIG/mayor-decisions.log"
      fi
      echo "[mayor] all clear"
    else
      {
        echo "[$ts] MAYOR CYCLE (trigger: $wake_reason)"
        [[ -n "$issues_found" ]] && echo -e "  Issues:\n$issues_found"
        [[ -n "$actions_taken" ]] && echo -e "  Actions:\n$actions_taken"
      } >> "$SGT_CONFIG/mayor-decisions.log"
      echo "[mayor] logged issues/actions"

      # Notify Rigger of significant actions via OpenClaw
      if [[ -n "$notify_rigger" ]]; then
        _mayor_notify_rigger "$notify_rigger"
      fi
    fi

    # === AI escalation (only when needed) ===
    if [[ "$needs_ai" == "true" ]]; then
      echo "[mayor] complex issues detected — invoking AI decision..."
      local mayor_workspace="$SGT_CONFIG/mayor-workspace"
      mkdir -p "$mayor_workspace"

      local briefing
      briefing=$(_mayor_build_briefing)

      cat > "$mayor_workspace/CLAUDE.md" <<MAYORMD
# Mayor — Emergency Decision

Issues requiring your judgment:
$(echo -e "$issues_found")

Recent actions already taken:
$(echo -e "$actions_taken")

## System State
$(cat "$briefing")

## Commands
- \`sgt sling <rig> "<task>"\` — Dispatch work
- \`sgt nuke <polecat>\` — Kill stuck worker
- \`sgt sweep\` — Clean finished workers
- \`gh pr merge <pr#> --repo <repo> --squash --delete-branch\` — Merge PR

Decide what to do. Log decisions to $SGT_CONFIG/mayor-decisions.log. Be fast.

If an issue/PR just merged, you should proactively:
- queue the next 1–3 highest-leverage issues (write crisp acceptance criteria)
- prefer keeping each issue small enough for an overnight polecat

After deciding, report your actions: sgt mayor notify "<summary of what you did>"
MAYORMD

      local backend="$(_ai_backend_default)"

      if timeout 300 bash -c "SGT_MAYOR_DISPATCH_REVALIDATE=1 _ai_prompt '$backend' '$mayor_workspace' 'Read CLAUDE.md. Handle the issues described. Be decisive and fast. Log your actions.'" 
        </dev/null 2>&1 | tail -5; then
        log_event "MAYOR_AI_CYCLE completed"
        echo "[mayor] AI decision cycle complete"
      else
        echo "[mayor] AI cycle timed out — will retry next loop"
        log_event "MAYOR_AI_CYCLE timeout"
      fi
    fi

    log_event "MAYOR_CYCLE completed (trigger: $wake_reason)"
  done
}

# Notify Rigger agent via OpenClaw messaging (fire-and-forget)
_mayor_notify_rigger() {
  local message="$1"
  if command -v openclaw &>/dev/null && [[ -f "$SGT_NOTIFY" ]]; then
    _notify_openclaw "[SGT Mayor] $message"
    echo "[mayor] notified Rigger: $message"
    log_event "MAYOR_NOTIFY_RIGGER $message"
  fi
}

# Public command: sgt mayor notify "<message>" — lets AI mayor report to Rigger
cmd_mayor_notify() {
  local message="${1:?usage: sgt mayor notify \"<message>\"}"
  _mayor_notify_rigger "$message"
}

cmd_mayor_start() {
  ensure_init

  local session="sgt-mayor"
  if tmux has-session -t "$session" 2>/dev/null; then
    info "mayor already running"
    return
  fi

  # Create FIFO for event-driven wake
  [[ -p "$SGT_MAYOR_FIFO" ]] || mkfifo "$SGT_MAYOR_FIFO"

  tmux new-session -d -s "$session" \
    "SGT_ROOT='$SGT_ROOT' SGT_MAYOR_INTERVAL='$SGT_MAYOR_INTERVAL' sgt _mayor"

  log_event "MAYOR_SPAWN"
  info "mayor started (session: $session, event-driven + fallback every ${SGT_MAYOR_INTERVAL}s)"
}

cmd_mayor_stop() {
  local session="sgt-mayor"
  if tmux has-session -t "$session" 2>/dev/null; then
    tmux kill-session -t "$session"
    log_event "MAYOR_STOP"
    info "mayor stopped"
  else
    info "mayor not running"
  fi
  # Clean up FIFO
  [[ -p "$SGT_MAYOR_FIFO" ]] && rm -f "$SGT_MAYOR_FIFO"
}

# Public command: wake the mayor on demand
cmd_wake_mayor() {
  local reason="${1:-manual}"
  if ! tmux has-session -t "sgt-mayor" 2>/dev/null; then
    warn "mayor is not running — starting it"
    cmd_mayor_start
    return
  fi
  _wake_mayor "$reason"
  info "mayor woken: $reason"
}

# ═══════════════════════════════════════════════════════════════════════
# DOGS — Lightweight helper pool for non-coding tasks
# ═══════════════════════════════════════════════════════════════════════
#
# Dogs are ephemeral agents like polecats, but for non-coding tasks:
# - Research, analysis, web scraping
# - Document generation, summarization
# - Data collection and formatting
#
# Key difference from polecats:
# - No branch/worktree — they work in a temp directory
# - No PR — they post results as issue comments
# - Lighter weight, faster to spawn

cmd_dog() {
  local rig="${1:-}"
  [[ -n "$rig" ]] || die "usage: sgt dog <rig> <task description>"
  shift

  local task=""
  local backend="$(_ai_backend_default)"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --backend) backend="$2"; shift 2 ;;
      *) task="${task:+$task }$1"; shift ;;
    esac
  done

  [[ -n "$task" ]] || die "no task description provided"
  ensure_init
  ensure_rig "$rig"

  case "$backend" in claude|codex) ;; *) die "invalid backend $backend (expected claude|codex)" ;; esac

  local repo rpath dname session_name
  repo="$(rig_repo "$rig")"
  rpath="$(rig_path "$rig")"
  dname="dog-$(head -c4 /dev/urandom | xxd -p)"
  session_name="sgt-${dname}"

  # Create issue for tracking
  info "creating issue for dog task..."
  _ensure_sgt_authorized_label "$repo"
  local issue_url issue_number
  local issue_body
  printf -v issue_body '## Research/Analysis Task

%s

---

*Created by sgt — dog: `%s`*
*Type: non-coding (results posted as comments)*' "$task" "$dname"
  issue_url=$(gh issue create \
    --repo "$repo" \
    --title "[Dog] $task" \
    --body "$issue_body" \
    --label "dog" --label "sgt-authorized" 2>&1) || {
    # Label might not exist, try without dog label
    issue_url=$(gh issue create \
      --repo "$repo" \
      --title "[Dog] $task" \
      --body "$issue_body" \
    --label "sgt-authorized" 2>&1) || die "failed to create issue: $issue_url"
  }

  issue_number=$(echo "$issue_url" | grep -oP '/issues/\K[0-9]+')
  info "issue #$issue_number created: $issue_url"

  # Create temp workspace
  local dog_workspace="$SGT_ROOT/dogs/$dname"
  mkdir -p "$dog_workspace"

  # Write instructions
  cat > "$dog_workspace/CLAUDE.md" <<DOGMD
# Dog Task — $dname

You are a research/analysis agent. Your job is NOT to write code.
Instead, research the topic and post your findings.

## Task

$task

## Instructions

1. Research the topic thoroughly using available tools
2. Compile your findings into a clear, well-structured report
3. Post your findings as a comment on issue #$issue_number:
   \`gh issue comment $issue_number --repo $repo --body "<your findings>"\`
4. Do NOT close the issue — the refinery will review your work first
5. Exit

## Rules

- Focus on research and analysis, not code
- Be thorough but concise
- Include sources when possible
- If you can't find good information, say so honestly
DOGMD

  # Save dog state
  mkdir -p "$SGT_CONFIG/dogs"
  cat > "$SGT_CONFIG/dogs/$dname" <<DSTATE
RIG=$rig
REPO=$repo
ISSUE=$issue_number
ISSUE_URL=$issue_url
SESSION=$session_name
WORKSPACE=$dog_workspace
CREATED=$(date -Iseconds)
BACKEND=$backend
STATUS=running
DSTATE

  # Spawn in tmux
  info "spawning dog $dname..."
  tmux new-session -d -s "$session_name" -c "$dog_workspace" \
    "$( _ai_cmd "$backend" "Read CLAUDE.md. Complete the research task described there. Post findings to the GitHub issue. Do NOT close the issue." ); echo '[SGT] dog exited'; sgt _wake-refinery '${rig}' 'dog-done:${dname}:#${issue_number}' 2>/dev/null"

  log_event "DOG_SPAWN $dname rig=$rig issue=#$issue_number"
  _wake_refinery "$rig" "dog:$dname:#$issue_number"

  info ""
  info "dog $dname dispatched"
  info "  issue:   $issue_url"
  info "  session: $session_name"
  info "  peek:    sgt peek dog/$dname"
}

cmd_dog_list() {
  ensure_init
  mkdir -p "$SGT_CONFIG/dogs"
  local count=0
  for f in "$SGT_CONFIG/dogs"/*; do
    [[ -f "$f" ]] || continue
    count=$((count + 1))
    local dname
    dname="$(basename "$f")"
    (
      source "$f"
      local alive="dead"
      tmux has-session -t "$SESSION" 2>/dev/null && alive="alive"
      echo "  $dname [$alive]"
      echo "    rig:   $RIG"
      echo "    issue: #$ISSUE ($ISSUE_URL)"
    )
  done
  if [[ "$count" -eq 0 ]]; then
    info "no dogs"
  else
    info "$count dog(s)"
  fi
}

cmd_dog_sweep() {
  ensure_init
  mkdir -p "$SGT_CONFIG/dogs"
  local cleaned=0
  for f in "$SGT_CONFIG/dogs"/*; do
    [[ -f "$f" ]] || continue
    local dname
    dname="$(basename "$f")"
    (
      source "$f"
      if ! tmux has-session -t "$SESSION" 2>/dev/null; then
        echo "CLEAN"
      else
        echo "SKIP"
      fi
    ) | {
      read -r action
      if [[ "$action" == "CLEAN" ]]; then
        # Clean up workspace
        local ws
        ws=$(grep '^WORKSPACE=' "$f" | cut -d= -f2)
        [[ -d "$ws" ]] && rm -rf "$ws"
        rm -f "$f"
        cleaned=$((cleaned + 1))
        log_event "DOG_SWEEP $dname"
        info "swept dog $dname"
      fi
    }
  done
  [[ "$cleaned" -eq 0 ]] && info "no dogs to sweep"
}

# ═══════════════════════════════════════════════════════════════════════
# CREW — Persistent workspace agents
# ═══════════════════════════════════════════════════════════════════════
#
# Crew members are long-running agents that hold project context.
# Unlike ephemeral polecats (spawn, work, die), crew members persist
# across multiple tasks. They're good for:
# - Ongoing maintenance of a codebase
# - Code review (watches for new PRs)
# - Project management (tracks issues, updates docs)
#
# Each crew member has a persistent workspace and identity.

cmd_crew_add() {
  local name="${1:-}" rig="${2:-}" role="${3:-general}"
  [[ -n "$name" ]] || die "usage: sgt crew add <name> <rig> [role]"
  [[ -n "$rig" ]] || die "usage: sgt crew add <name> <rig> [role]"
  ensure_init
  ensure_rig "$rig"

  local repo
  repo="$(rig_repo "$rig")"
  local crew_dir="$SGT_ROOT/crew/$name"
  local session_name="sgt-crew-${name}"

  if [[ -f "$SGT_CONFIG/crew/$name" ]]; then
    die "crew member '$name' already exists"
  fi

  # Clone rig into crew workspace
  mkdir -p "$crew_dir"
  git clone "$repo" "$crew_dir/repo" 2>/dev/null || {
    if [[ -d "$crew_dir/repo" ]]; then
      git -C "$crew_dir/repo" pull --ff-only 2>/dev/null || true
    else
      die "failed to clone $repo"
    fi
  }

  # Write crew member identity
  cat > "$crew_dir/CLAUDE.md" <<CREWMD
# Crew Member: $name

You are a persistent crew member for the $rig project.

## Role: $role

## Your Workspace

Your working directory is $crew_dir/repo — a full clone of the project.
You have your own notes directory at $crew_dir/notes/ — use it to persist context.

## Responsibilities

Based on your role ($role), you should:

### If role = "reviewer"
- Watch for new PRs: \`gh pr list --repo $repo --state open\`
- Review code changes and leave comments
- Approve good PRs, request changes on problematic ones

### If role = "maintainer"
- Keep the repo healthy (dependencies updated, docs current)
- Triage new issues
- Fix small bugs directly (create branch, commit, PR)

### If role = "general"
- Be a knowledgeable project resource
- Answer questions about the codebase
- Help debug issues
- Maintain project documentation

## Persistence

Your notes/ directory persists between sessions. Save important context there:
- \`notes/context.md\` — Current project state, recent changes
- \`notes/decisions.md\` — Architecture decisions, trade-offs
- \`notes/todos.md\` — Things to follow up on

## Commands

- Check PRs: \`gh pr list --repo $repo\`
- Check issues: \`gh issue list --repo $repo\`
- Create PR: \`gh pr create --repo $repo --title "..." --body "..."\`
- Comment: \`gh issue comment <#> --repo $repo --body "..."\`

When you have nothing to do, update your notes and exit. You'll be woken up again.
CREWMD

  mkdir -p "$crew_dir/notes" "$SGT_CONFIG/crew"

  # Save crew state
  cat > "$SGT_CONFIG/crew/$name" <<CSTATE
NAME=$name
RIG=$rig
REPO=$repo
ROLE=$role
WORKSPACE=$crew_dir
SESSION=$session_name
CREATED=$(date -Iseconds)
CSTATE

  log_event "CREW_ADD $name rig=$rig role=$role"
  info "crew member '$name' added (role: $role, rig: $rig)"
}

cmd_crew_wake() {
  local name="${1:-}" task="${2:-Check for new work. Review any open PRs or issues. Update your notes.}"
  [[ -n "$name" ]] || die "usage: sgt crew wake <name> [task]"
  ensure_init

  local cfile="$SGT_CONFIG/crew/$name"
  [[ -f "$cfile" ]] || die "crew member '$name' not found"

  local c_session c_workspace
  eval "$(grep -E '^(SESSION|WORKSPACE)=' "$cfile")"
  c_session="$SESSION"
  c_workspace="$WORKSPACE"

  if tmux has-session -t "$c_session" 2>/dev/null; then
    info "crew member '$name' is already awake"
    return
  fi

  tmux new-session -d -s "$c_session" -c "$c_workspace/repo" \
    "$( _ai_cmd "$(_ai_backend_default)" "Read $c_workspace/CLAUDE.md. Read your notes in $c_workspace/notes/ if they exist. Your task: $task. When done, update your notes." ); echo '[SGT] crew exited'"

  log_event "CREW_WAKE $name task=\"$task\""
  info "crew member '$name' is awake (session: $c_session)"
}

cmd_crew_list() {
  ensure_init
  mkdir -p "$SGT_CONFIG/crew"
  local count=0
  for f in "$SGT_CONFIG/crew"/*; do
    [[ -f "$f" ]] || continue
    count=$((count + 1))
    local cname
    cname="$(basename "$f")"
    (
      source "$f"
      local alive="asleep"
      tmux has-session -t "$SESSION" 2>/dev/null && alive="awake"
      echo "  $cname [$alive]"
      echo "    rig:  $RIG"
      echo "    role: $ROLE"
    )
  done
  if [[ "$count" -eq 0 ]]; then
    info "no crew members"
  else
    info "$count crew member(s)"
  fi
}

cmd_crew_remove() {
  local name="${1:-}"
  [[ -n "$name" ]] || die "usage: sgt crew remove <name>"
  ensure_init

  local cfile="$SGT_CONFIG/crew/$name"
  [[ -f "$cfile" ]] || die "crew member '$name' not found"

  local c_session c_workspace
  eval "$(grep -E '^(SESSION|WORKSPACE)=' "$cfile")"
  c_session="$SESSION"
  c_workspace="$WORKSPACE"

  # Kill session if running
  tmux has-session -t "$c_session" 2>/dev/null && tmux kill-session -t "$c_session"

  rm -f "$cfile"
  log_event "CREW_REMOVE $name"
  info "crew member '$name' removed (workspace kept at $c_workspace)"
}

# ═══════════════════════════════════════════════════════════════════════
# MOLECULES / FORMULAS — Multi-step workflow templates
# ═══════════════════════════════════════════════════════════════════════
#
# A molecule is a YAML file defining a sequence of tasks (a formula).
# When executed, each step becomes a sling with dependency tracking.
#
# Example molecule (saved as molecules/feature.yml):
#   name: feature
#   description: Full feature implementation
#   steps:
#     - task: "Write technical spec for: {description}"
#       type: dog
#     - task: "Implement: {description}"
#       type: polecat
#       depends_on: [0]
#     - task: "Write tests for: {description}"
#       type: polecat
#       depends_on: [1]
#     - task: "Write documentation for: {description}"
#       type: dog
#       depends_on: [1]

cmd_molecule_init() {
  ensure_init
  mkdir -p "$SGT_MOLECULES"

  # Write example molecules
  cat > "$SGT_MOLECULES/feature.yml" <<'MOLML'
name: feature
description: Full feature implementation with spec, code, tests, and docs
steps:
  - task: "Write technical spec for: {description}"
    type: dog
    label: spec
  - task: "Implement: {description}"
    type: polecat
    depends_on: [0]
    label: implementation
  - task: "Write tests for: {description}"
    type: polecat
    depends_on: [1]
    label: tests
  - task: "Write documentation for: {description}"
    type: dog
    depends_on: [1]
    label: docs
MOLML

  cat > "$SGT_MOLECULES/bugfix.yml" <<'MOLML'
name: bugfix
description: Bug investigation and fix with regression tests
steps:
  - task: "Investigate and diagnose: {description}"
    type: dog
    label: investigation
  - task: "Fix bug: {description}"
    type: polecat
    depends_on: [0]
    label: fix
  - task: "Write regression tests for: {description}"
    type: polecat
    depends_on: [1]
    label: regression-test
MOLML

  cat > "$SGT_MOLECULES/research.yml" <<'MOLML'
name: research
description: Multi-angle research with synthesis
steps:
  - task: "Research competitive landscape for: {description}"
    type: dog
    label: competitive
  - task: "Research technical approaches for: {description}"
    type: dog
    label: technical
  - task: "Synthesize findings and write recommendation for: {description}"
    type: dog
    depends_on: [0, 1]
    label: synthesis
MOLML

  log_event "MOLECULE_INIT"
  info "molecules initialized at $SGT_MOLECULES"
  info "available: feature, bugfix, research"
}

cmd_molecule_list() {
  ensure_init
  if [[ ! -d "$SGT_MOLECULES" ]]; then
    info "no molecules — run: sgt molecule init"
    return
  fi

  for f in "$SGT_MOLECULES"/*.yml; do
    [[ -f "$f" ]] || continue
    local name desc
    name=$(grep '^name:' "$f" | head -1 | sed 's/name: *//')
    desc=$(grep '^description:' "$f" | head -1 | sed 's/description: *//')
    local step_count
    step_count=$(grep -c '^ *- task:' "$f" || echo 0)
    echo "  $name ($step_count steps) — $desc"
  done
}

cmd_molecule_run() {
  local molecule="${1:-}" rig="${2:-}"
  [[ -n "$molecule" ]] || die "usage: sgt molecule run <molecule> <rig> <description>"
  [[ -n "$rig" ]] || die "usage: sgt molecule run <molecule> <rig> <description>"
  shift 2

  local description="$*"
  [[ -n "$description" ]] || die "no description provided"
  ensure_init
  ensure_rig "$rig"

  local mol_file="$SGT_MOLECULES/${molecule}.yml"
  [[ -f "$mol_file" ]] || die "molecule '$molecule' not found at $mol_file"

  local repo
  repo="$(rig_repo "$rig")"

  # Create a convoy (milestone) for this molecule run
  local convoy_name="mol-${molecule}-$(date +%s)"
  info "creating convoy for molecule run: $convoy_name"
  cmd_convoy_create "$convoy_name" "$repo" 2>/dev/null || true

  # Ensure sgt-authorized label exists
  _ensure_sgt_authorized_label "$repo"

  # Parse steps and dispatch non-dependent ones immediately
  # For simplicity, dispatch all steps as issues with dependency notes
  # The Mayor will coordinate execution order
  local step_idx=0
  local step_issues=()

  while IFS= read -r line; do
    if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*task:[[:space:]]*(.*) ]]; then
      local raw_task="${BASH_REMATCH[1]}"
      # Remove quotes
      raw_task="${raw_task#\"}"
      raw_task="${raw_task%\"}"
      raw_task="${raw_task#\'}"
      raw_task="${raw_task%\'}"
      # Substitute {description}
      local task="${raw_task//\{description\}/$description}"

      # Get type (next line might have it)
      local step_type="polecat"
      local step_label=""
      local step_deps=""

      # Read ahead for type, depends_on, label (simplified YAML parsing)
      step_idx=$((step_idx + 1))

      # Create issue with dependency info in body
      local issue_url issue_number
      local issue_body
      printf -v issue_body '## Molecule: %s (step %s)

%s

**Convoy:** %s

---
*Part of molecule run. Dispatched by sgt.*' "$molecule" "$step_idx" "$task" "$convoy_name"
      issue_url=$(gh issue create \
        --repo "$repo" \
        --title "[${molecule}/${step_idx}] $task" \
        --body "$issue_body" \
        --label "sgt-authorized" 2>&1) || warn "failed to create issue for step $step_idx"

      if [[ -n "$issue_url" ]]; then
        issue_number=$(echo "$issue_url" | grep -oP '/issues/\K[0-9]+')
        step_issues+=("$issue_number")
        info "step $step_idx: issue #$issue_number — $task"

        # Add to convoy
        gh issue edit "$issue_number" --repo "$repo" --milestone "$convoy_name" 2>/dev/null || true
      fi
    fi
  done < "$mol_file"

  info ""
  info "molecule '$molecule' dispatched with ${#step_issues[@]} steps"
  info "convoy: $convoy_name"
  info "the Mayor will coordinate execution order"

  log_event "MOLECULE_RUN molecule=$molecule rig=$rig steps=${#step_issues[@]} convoy=$convoy_name"
}

# ═══════════════════════════════════════════════════════════════════════
# ESCALATION — Severity-based routing
# ═══════════════════════════════════════════════════════════════════════
#
# Issues can be labeled with severity levels:
# - critical: Immediate dispatch, Mayor notified, timeout 15min
# - high: Priority dispatch, 30min timeout
# - normal: Standard dispatch (default)
# - low: Queued, dispatched when capacity available
#
# Escalation config is stored in $SGT_ESCALATION

cmd_label_init() {
  local rig="${1:-}"
  if [[ -n "$rig" ]]; then
    ensure_init
    ensure_rig "$rig"
    local repo
    repo="$(rig_repo "$rig")"
    _ensure_sgt_authorized_label "$repo"
    info "created sgt-authorized label on $rig"
  else
    # Apply to all rigs
    ensure_init
    for rig_file in "$SGT_RIGS"/*; do
      [[ -f "$rig_file" ]] || continue
      local repo rname
      rname="$(basename "$rig_file")"
      repo="$(cat "$rig_file")"
      _ensure_sgt_authorized_label "$repo"
      info "created sgt-authorized label on $rname"
    done
  fi
}

cmd_escalation_init() {
  ensure_init

  cat > "$SGT_ESCALATION" <<'ESCJSON'
{
  "levels": {
    "critical": {
      "timeout_minutes": 15,
      "max_retries": 3,
      "notify": true,
      "auto_dispatch": true
    },
    "high": {
      "timeout_minutes": 30,
      "max_retries": 2,
      "notify": true,
      "auto_dispatch": true
    },
    "normal": {
      "timeout_minutes": 60,
      "max_retries": 1,
      "notify": false,
      "auto_dispatch": false
    },
    "low": {
      "timeout_minutes": 120,
      "max_retries": 0,
      "notify": false,
      "auto_dispatch": false
    }
  }
}
ESCJSON

  # Create labels on all rigs
  for rig_file in "$SGT_RIGS"/*; do
    [[ -f "$rig_file" ]] || continue
    local repo
    repo="$(cat "$rig_file")"
    for level in critical high normal low dog; do
      gh label create "$level" --repo "$repo" --force 2>/dev/null || true
    done
    _ensure_sgt_authorized_label "$repo"
    info "created escalation + sgt-authorized labels on $(basename "$rig_file")"
  done

  log_event "ESCALATION_INIT"
  info "escalation initialized at $SGT_ESCALATION"
}

cmd_escalation_show() {
  ensure_init
  if [[ ! -f "$SGT_ESCALATION" ]]; then
    info "escalation not configured — run: sgt escalation init"
    return
  fi
  cat "$SGT_ESCALATION"
}

# ─── Up / Down (start/stop everything) ───────────────────────────────

cmd_up() {
  ensure_init
  info "starting sgt system..."

  # Start workers first (bottom-up: witnesses + refineries, then deacon, then daemon)
  for rig_file in "$SGT_RIGS"/*; do
    [[ -f "$rig_file" ]] || continue
    local rig_name
    rig_name="$(basename "$rig_file")"
    cmd_witness_start "$rig_name"
    cmd_refinery_start "$rig_name"
  done

  # Start deacon (monitors witnesses + refineries)
  cmd_deacon_start

  # Give deacon a moment to write its first heartbeat
  sleep 2

  # Start daemon last (monitors deacon via boot)
  cmd_daemon_start

  # Start mayor (AI coordinator)
  cmd_mayor_start

  log_event "SYSTEM_UP"
  info "sgt system is up"
}

cmd_down() {
  ensure_init
  info "stopping sgt system..."

  # Stop all witnesses and refineries
  for rig_file in "$SGT_RIGS"/*; do
    [[ -f "$rig_file" ]] || continue
    local rig_name
    rig_name="$(basename "$rig_file")"
    cmd_witness_stop "$rig_name" 2>/dev/null || true
    cmd_refinery_stop "$rig_name" 2>/dev/null || true
  done

  # Stop mayor
  cmd_mayor_stop 2>/dev/null || true

  # Stop deacon
  cmd_deacon_stop 2>/dev/null || true

  # Stop daemon
  cmd_daemon_stop 2>/dev/null || true

  log_event "SYSTEM_DOWN"
  info "sgt system is down"
  info "(polecats left running — use 'sgt nuke' to kill individual workers)"
}

# ─── Log ──────────────────────────────────────────────────────────────

cmd_log() {
  local lines="${1:-50}"
  tail -n "$lines" "$SGT_LOG" 2>/dev/null || info "no log entries"
}

# ─── Trail (recent activity feed) ─────────────────────────────────────

cmd_trail() {
  local lines="${1:-20}"
  ensure_init
  echo "=== Recent Activity ==="
  tail -n "$lines" "$SGT_LOG" 2>/dev/null || info "no activity"
}

# ─── CLAUDE.md Templates ─────────────────────────────────────────────

_write_claude_md() {
  local rpath="$1"
  [[ -f "$rpath/CLAUDE.md" ]] && return 0

  cat > "$rpath/CLAUDE.md" <<'CLMD'
# Project Context

This repository is managed by sgt (Simple GitHub Gastown).
Workers (polecats) operate on feature branches and submit PRs.

## Workflow

1. Read your assigned GitHub issue for the task description
2. Work on your feature branch
3. Commit frequently with clear messages
4. Push your branch
5. Open a PR that references the issue (use "Closes #N")
6. Exit when done
CLMD
}

_write_polecat_claude_md() {
  local worktree="$1" issue="$2" task="$3" repo="$4" pname="$5" branch="$6" default_branch="$7" auto_merge="$8"

  cat >> "$worktree/CLAUDE.md" <<CLMD

# SGT Polecat Instructions

You are polecat \`$pname\`, an ephemeral coding agent.

## Your Assignment

- **Issue**: #$issue
- **Task**: $task
- **Branch**: \`$branch\`
- **Target**: \`$default_branch\`

## Protocol

1. Read the issue description for full context
2. Implement the requested changes
3. Write tests if appropriate
4. Commit your work with clear commit messages referencing #$issue
5. Push your branch: \`git push -u origin $branch\`
6. Open a PR: \`gh pr create --title "<concise title>" --body "Closes #$issue" --base $default_branch\`
7. Exit the session

## Rules

- Stay focused on the issue — don't scope-creep
- If blocked, comment on the issue explaining the blocker, then exit
- Never force-push or modify the default branch directly
- Keep commits atomic and well-described
CLMD
}

# ─── Main Dispatch ────────────────────────────────────────────────────

cmd_help() {
  cat <<EOF
sgt $SGT_VERSION — Simple GitHub Gastown

Usage: sgt <command> [args]

Core Commands:
  init                          Initialize sgt workspace
  rig add <name> <repo>         Add a repository as a rig
  rig list                      List registered rigs
  rig remove <name>             Remove a rig
  sling <rig> <task> [opts]     Dispatch coding work (issue + branch + polecat)
    --convoy <name>               Add to milestone
    --label <label>               Add label (repeatable)
    --auto-merge                  Auto-merge PR on CI pass
    --backend <claude|codex>      Select AI backend for this polecat (default: SGT_AI_BACKEND)
  status                        Show all agents, polecats, dogs, crew
  peek <target>                 View output (polecat, witness/<rig>, refinery/<rig>,
                                deacon, mayor, dog/<name>, crew/<name>)
  nuke <polecat>                Kill polecat and clean up
  sweep                         Clean up completed polecats

Agent Commands:
  up                            Start full system (daemon + deacon + witnesses + refineries + mayor)
  down                          Stop all agents (polecats keep running)
  daemon start|stop|status      Control the watchdog daemon
  deacon start|stop             Control the health monitor
  witness start|stop <rig>      Control per-rig polecat monitor
  refinery start|stop <rig>     Control per-rig merge queue
  mayor start|stop|notify       Control the AI coordinator
  wake-mayor [reason]           Wake the mayor on demand (event-driven)
  nudge <target> <message>      Send message to agent's tmux session

Dogs (non-coding helpers):
  dog <rig> <task> [--backend <claude|codex>]  Dispatch research/analysis task
  dog list                      List active dogs
  dog sweep                     Clean up completed dogs

Crew (persistent agents):
  crew add <name> <rig> [role]  Add a crew member (roles: reviewer, maintainer, general)
  crew wake <name> [task]       Wake up a crew member with optional task
  crew list                     List crew members
  crew remove <name>            Remove a crew member

Molecules (workflow templates):
  molecule init                 Create default molecule templates
  molecule list                 List available molecules
  molecule run <mol> <rig> <desc>  Execute a multi-step workflow

Security:
  label init [rig]              Create sgt-authorized label (on rig or all rigs)

Escalation:
  escalation init               Set up severity labels and config
  escalation show               Show escalation rules

Communication:
  mail send <repo> <#> <msg>    Comment on a GitHub issue
  mail check <repo>             Show recent issue comments
  convoy create <name> <repo>   Create a convoy (milestone)
  convoy status <repo>          Show convoy progress

Diagnostics:
  log [lines]                   Show recent log entries
  trail [lines]                 Show recent activity feed
  version                       Show version
  help                          This help

Agent Hierarchy:
  daemon     Mechanical watchdog (bash loop, every 3 min)
   └─ boot   Ephemeral triage — checks deacon health
       └─ deacon   Health monitor — ensures witnesses + refineries alive
           ├─ witness/<rig>    Polecat lifecycle manager (+ orphan PR scanner)
           └─ refinery/<rig>   Merge queue processor
  mayor      AI coordinator (event-driven, fallback every 10 min)
  dogs       Ephemeral non-coding helpers (research, analysis)
  crew       Persistent project agents (review, maintenance)

Environment:
  SGT_ROOT              Workspace root (default: ~/sgt)
  SGT_DAEMON_INTERVAL   Daemon tick interval in seconds (default: 180)
  SGT_MAYOR_INTERVAL    Mayor cycle interval in seconds (default: 600)
  SGT_MAYOR_DISPATCH_COOLDOWN  Suppress duplicate dispatches for N seconds (default: 21600, set 0 to disable)
  SGT_AI_BACKEND        AI backend: claude|codex (default: claude)
  NO_COLOR              Disable ANSI color output

Examples:
  sgt init
  sgt rig add myapp owner/repo
  sgt up                                        # Start full system
  sgt sling myapp "Add user authentication"
  sgt sling myapp "Fix login bug" --label critical --convoy v1.0
  sgt dog myapp "Research competitor pricing"    # Non-coding task
  sgt crew add alice myapp reviewer             # Add persistent reviewer
  sgt crew wake alice "Review latest PRs"       # Wake up crew member
  sgt molecule init                             # Create templates
  sgt molecule run feature myapp "User dashboard"  # Multi-step workflow
  sgt escalation init                           # Set up severity levels
  sgt status
  sgt peek mayor                                # Check mayor decisions
  sgt peek dog/dog-a1b2c3d4
  sgt down                                      # Stop agents
EOF
}

main() {
  local cmd="${1:-help}"
  shift 2>/dev/null || true

  case "$cmd" in
    # Internal commands for tmux agent sessions (not user-facing)
    _witness)       _witness_loop "$@" ;;
    _refinery)      _refinery_loop "$@" ;;
    _deacon)        _deacon_loop ;;
    _daemon)        _daemon_loop ;;
    _boot)          _boot_check ;;
    _mayor)         _mayor_loop ;;

    init)           cmd_init ;;
    rig)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        add)    cmd_rig_add "$@" ;;
        list|ls) cmd_rig_list ;;
        remove|rm) cmd_rig_remove "$@" ;;
        *)      die "unknown rig command: $sub (try: add, list, remove)" ;;
      esac
      ;;
    sling)          cmd_sling "$@" ;;
    status|st)      cmd_status ;;
    peek)           cmd_peek "$@" ;;
    nuke)           cmd_nuke "$@" ;;
    sweep)          cmd_sweep ;;
    convoy)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        create)  cmd_convoy_create "$@" ;;
        status)  cmd_convoy_status "$@" ;;
        *)       die "unknown convoy command: $sub (try: create, status)" ;;
      esac
      ;;
    up)             cmd_up ;;
    down)           cmd_down ;;
    daemon)
      local sub="${1:-status}"
      shift 2>/dev/null || true
      case "$sub" in
        start)  cmd_daemon_start ;;
        stop)   cmd_daemon_stop ;;
        status) cmd_daemon_status ;;
        *)      die "unknown daemon command: $sub (try: start, stop, status)" ;;
      esac
      ;;
    deacon)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        start)  cmd_deacon_start ;;
        stop)   cmd_deacon_stop ;;
        *)      die "unknown deacon command: $sub (try: start, stop)" ;;
      esac
      ;;
    witness)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        start)  cmd_witness_start "$@" ;;
        stop)   cmd_witness_stop "$@" ;;
        *)      die "unknown witness command: $sub (try: start, stop)" ;;
      esac
      ;;
    refinery)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        start)  cmd_refinery_start "$@" ;;
        stop)   cmd_refinery_stop "$@" ;;
        *)      die "unknown refinery command: $sub (try: start, stop)" ;;
      esac
      ;;
    mayor)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        start)   cmd_mayor_start ;;
        stop)    cmd_mayor_stop ;;
        notify)  cmd_mayor_notify "$@" ;;
        *)       die "unknown mayor command: $sub (try: start, stop, notify)" ;;
      esac
      ;;
    wake-mayor) cmd_wake_mayor "$@" ;;
    _wake-refinery) _wake_refinery "$@" ;;
    dog)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        list|ls)  cmd_dog_list ;;
        sweep)    cmd_dog_sweep ;;
        *)
          # If first arg looks like a rig name, it's a dispatch
          if [[ -f "$SGT_RIGS/$sub" ]]; then
            cmd_dog "$sub" "$@"
          else
            die "unknown dog command: $sub (try: <rig> <task>, list, sweep)"
          fi
          ;;
      esac
      ;;
    crew)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        add)     cmd_crew_add "$@" ;;
        wake)    cmd_crew_wake "$@" ;;
        list|ls) cmd_crew_list ;;
        remove|rm) cmd_crew_remove "$@" ;;
        *)       die "unknown crew command: $sub (try: add, wake, list, remove)" ;;
      esac
      ;;
    molecule|mol)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        init)   cmd_molecule_init ;;
        list|ls) cmd_molecule_list ;;
        run)    cmd_molecule_run "$@" ;;
        *)      die "unknown molecule command: $sub (try: init, list, run)" ;;
      esac
      ;;
    label)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        init)  cmd_label_init "$@" ;;
        *)     die "unknown label command: $sub (try: init)" ;;
      esac
      ;;
    escalation|esc)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        init)  cmd_escalation_init ;;
        show)  cmd_escalation_show ;;
        *)     die "unknown escalation command: $sub (try: init, show)" ;;
      esac
      ;;
    nudge)          cmd_nudge "$@" ;;
    mail)
      local sub="${1:-}"
      shift 2>/dev/null || true
      case "$sub" in
        send)   cmd_mail_send "$@" ;;
        check)  cmd_mail_check "$@" ;;
        *)      die "unknown mail command: $sub (try: send, check)" ;;
      esac
      ;;
    log)            cmd_log "$@" ;;
    trail)          cmd_trail "$@" ;;
    version|--version|-v) echo "sgt $SGT_VERSION" ;;
    help|--help|-h) cmd_help ;;
    *)              die "unknown command: $cmd (try: sgt help)" ;;
  esac
}

main "$@"
